start,duration,text
0.0,17.96," Okay. So last lecture, we started talking about the idea of decomposition and abstraction,"
17.96,3.719999999999999, and we talked a little bit about what that means and how it ties into what we've already
21.68,5.240000000000002," been doing. Today, we're going to do a real-world example of decomposition and abstraction,"
26.92,5.640000000000001, and then we'll see exactly how we can achieve this in programming. So let's start by talking
32.56,8.600000000000001," about an example in the real world, the smartphone. So a lot of us have it, but for a lot of us,"
41.160000000000004,5.359999999999999," it's really just a black box. For me, I know it is. For most of the people in the world,"
46.52,6.399999999999999, the phone is a black box. We basically view the phone in terms of its inputs and in terms
52.92,7.68," of its outputs. So the phone has some buttons, you can scroll, you can touch things, but we don't"
60.6,5.279999999999994, really know exactly how all of these buttons and scrolling and all these internal workings
65.88,6.560000000000002," actually do their job. And in fact, we don't need to know how they do their job. To us as the user,"
72.44,6.240000000000009, all we really care about is the interface between us and what task we want to achieve. Okay.
78.76,6.159999999999997," So what we need to know, that interface is basically the relationship between the input we give to"
84.92,6.88000000000001," the phone and the output we get. So when we push that button, the phone turns off. When we push"
91.80000000000001,6.640000000000001," this other button, the volume increases. Okay. And so that's the idea of abstraction. Right?"
98.44000000000001,5.439999999999998," The phone is basically abstracted away all of those hardware details, all of those"
103.88,5.519999999999996, implementations that make it actually work for the user. Right? So the user doesn't need to know
109.39999999999999,7.040000000000006," how it works in order to use it. Now, abstraction actually enables decomposition. What does that mean?"
117.32,7.760000000000005," Well, once we abstract away details, we can have different manufacturers working on different"
125.08,7.6000000000000085, components of the phone to build these different components. And if different manufacturers are
132.68,5.280000000000001," working to build these hundreds of distinct parts within the phone separately, they need to have"
137.96,6.47999999999999, some way to put these parts back together. And when they're working on their on their pieces
144.44,6.0800000000000125," separately, that's the idea of decomposition. How do they know that what they're working on will"
150.52,5.1200000000000045," actually fit in with the rest of the components? Well, they use the idea of decomposition. They're"
155.64000000000001,6.47999999999999," basically following a specification, they're following a set of inputs that may become into their"
162.12,5.759999999999991, component and a set of outputs that maybe their component needs to give to other components.
168.6,6.240000000000009, And all these different manufacturers that are building these different parts need to know is
174.84,4.719999999999999, that interface bit. They don't need to know how other manufacturers build their components.
179.56,6.640000000000015, All they need to know is what functionality those other components have. And so all of these
186.20000000000002,4.399999999999977, different manufacturers can build all these different components. The interfaces are going to be
190.6,6.47999999999999," sort of standardized, so to speak. And that's all that they care about. So once you know the"
197.07999999999998,5.760000000000019," interface, you can come together and put all these different components together to work towards"
202.84,6.239999999999981," a common goal as in to make a phone work. So this is true for hardware as in the phone example,"
209.07999999999998,4.0800000000000125, but it's also true for software. And that's exactly what we will be doing in this in this
213.16,6.639999999999986, lecture on functions. We're going to achieve decomposition and abstraction in programming. So
219.8,7.280000000000001, treating code as a black box and making a large program kind of splitting it up into these
227.08,7.1200000000000045," different self-contained parts. Okay, so in programming, we want to suppress details as well,"
234.20000000000002,5.52000000000001," right? Not just in hardware, like with the phone, we want to suppress details in programming as well."
239.72000000000003,8.0, And we do this using this idea of abstraction. So we will be writing code as we have already
247.8,8.0, been doing. With the thought that the code we're writing will be written only once. We will have
255.8,5.519999999999982, some functional piece of code that will do a very useful task. And then after we've written that code
261.32,5.360000000000014," and debugged it and made sure it works well, we'll treat that code as a black box. So from there on"
266.68,4.71999999999997," out, as long as we know what inputs that piece of code needs and what outputs that piece of code"
271.4,5.600000000000023," gives back to somebody else or to us, we don't care exactly how it does it. We just care that it is"
277.0,6.160000000000025," there and it is available for use. Okay, so today's lecture, we're going to be seeing how we can"
283.16,5.919999999999959, actually create these little functional pieces of code. We can then give these pieces of code to
289.8,4.079999999999984, ourselves. We can definitely use these functional pieces of code that we're written or we can give
293.88,7.360000000000014," them to other people so that they can use them as well. Okay, so we're going to write these functional"
301.32,9.120000000000005," pieces of code and we'll call them functions or procedures. And in fact, we've already been using"
310.44,6.800000000000011," functions, believe it or not. These three are examples of functions we've already been using in"
317.24,7.439999999999998," Python. So max is a function, so it's some useful piece of code that when we use it in this particular"
324.68,6.9599999999999795," way, it says it's taking in two inputs and it gives me back the biggest of those two inputs."
332.68,6.9599999999999795," The middle one, ABS is the absolute value function and its input is one number, an integer,"
340.28000000000003,7.839999999999975, and it gives back to me the absolute value of that number. And LAN is also a really useful one that
348.12,7.279999999999973, we've been using with strings and basically its input is a string and its output is going to be
355.4,5.2000000000000455, how many characters are in the string. So we've already been using functions. The point of
360.6,6.7999999999999545," today's lecture is you're going to start to write your own functions, hopefully useful ones."
369.4,5.920000000000016," Okay, so the idea of a function is that we want to abstract away exactly how that function"
375.32,6.319999999999993," achieves something useful, right? Some useful task. And so the way that we're going to tell other"
381.64,6.079999999999984, people how to use our function is using this idea of abstraction and we capture what the function
387.71999999999997,6.560000000000002, does with these things called specifications. They're also called doc strings and the doc string
394.28,5.0400000000000205, is kind of like a contract between somebody who creates this useful function and somebody who wants
399.32,5.28000000000003," to use the function. The person who uses the function might be you, the person who wrote it or it"
404.6,5.199999999999989," might be somebody else. And in the contract, the things that we're going to mention are what are"
409.8,7.1200000000000045," the inputs to the function? So in the length function, you know, it needs a string. What is the"
416.92,6.079999999999984, function doing? And what is the output of the function? What is the function give back to somebody
423.0,7.439999999999998, who uses this function? And we haven't actually done this explicitly but you've probably seen
430.44,6.399999999999977, this as you type your code in. So here's an example of the absolute value function and it comes
436.84,4.960000000000036," up with this little pop-up here whenever you type it in. So for example, ABS parenthesis,"
442.52,6.0," right here or if you hover over a function in your file editor, you'll see it pop up this little"
448.52,5.680000000000007, text box that says the specification or the doc string. And here you see exactly sort of the
454.2,5.28000000000003," signature of the function. So it takes in one input, the x, the value you want to find the absolute"
459.56,6.080000000000041, value of and then some text here which is what the function does. So the specification of the
465.64000000000004,6.079999999999984, doc string is literally just a multi-line comment. There's nothing special about it. As long as you
471.72,4.9599999999999795," kind of hit those points, the inputs, what the function does and what the function gives back to"
476.68,9.520000000000039," you, you've written a good specification. Okay. Oh, so I should mention that these contracts,"
486.2,6.160000000000025," even though I call them contract, they're not actually enforced by Python. So it's really just"
492.36,5.839999999999975, up to the person who writes the code to make sure that their specification is really detailed and
498.68,4.9599999999999795," your function does what you say you will, right? So if your function can take in both positive and"
503.64,4.8799999999999955," negative integers, for example, then you better make sure that the function itself doing whatever"
508.52,6.7999999999999545," task it needs to do can handle both positive and negative integers. So once we write these functions,"
515.88,6.720000000000027," we now have these little bits of code that perform some useful task, right? Given some input,"
522.6,5.039999999999964, it'll perform this task and give me back some output. And now that we have these different
528.4399999999999,7.759999999999991," little pieces of functionality, we can go ahead and take this large file of code, which you might"
536.5200000000001,5.519999999999982, write from now on and kind of see exactly which pieces of code maybe are getting repeated.
542.6,4.560000000000059," That's a clue that that's something that you can kind of abstract away into a little module,"
547.1600000000001,5.919999999999959," aka a function. And then you can just use these functions to break up the code, a very large piece"
553.08,6.159999999999968, of code into smaller little self-contained modules. And then maybe the bulk of the work that the code
559.24,6.400000000000091," is doing is just saying, hey, you know, this module, please give me this answer. And then this module"
565.64,3.3600000000000136, will give me the answer and then putting those values back together again.
571.16,4.8799999999999955, So these reusable pieces of code are called functions or procedures. We're basically going to try to
576.04,6.560000000000059," capture some sort of computation, a very useful task that you'd want to do over and over again."
583.4,6.480000000000018," And we're going to see some details about how to write functions, but essentially it's just going"
589.88,6.639999999999986," to be code that you've already been writing, just written in a special way that makes it reusable."
598.68,4.080000000000041, So we're going to have to kind of switch the way we've been thinking about code for a bit.
602.76,4.720000000000027," Now that we're introducing functions, because right now when we've been writing functions in a file,"
607.48,6.639999999999986, we basically write some code top to bottom. And then we think about that code as being executed
614.12,7.2000000000000455," line by line top to bottom. But now that we're creating these things called functions, little blocks"
621.32,5.279999999999973," of code that we can use many times in many different places in our code, we're actually going to"
626.6,4.559999999999945, introduce the idea of defining a function. So that means we're going to write a piece of code.
632.2,5.519999999999982, And all that piece of code is going to do is tell Python that this is a module or a function that
637.72,8.240000000000009, exists in my program. All we're doing is defining the function. But we're not actually going to run
645.96,5.519999999999982, the function when we define it. And that's kind of the difference that the way that we're going
651.48,5.2000000000000455," to have to shift our thinking here. So when you define a function, you just tell Python that here is"
656.6800000000001,6.0, some useful piece of code that exists that does something. But it doesn't actually run until you
662.68,6.240000000000009," call the function. And the cool thing about writing a function is once you wrote it once, you can"
668.92,6.0, make 100 different function calls to that one piece of code that you wrote later on in your program.
675.8,4.240000000000009," So you can call the function many times with different inputs to give you different outputs,"
680.04,5.439999999999941," but you only had to write it one time. So I would compare this to when we write code in a file,"
685.4799999999999,5.840000000000032," right? When we write code in a file, yes, we can write a whole bunch of lines, but this code"
691.32,6.639999999999986," isn't running as we're writing it, right? We have to actually push the run button to run that file."
698.7600000000001,4.0," So similarly, when we're telling Python that I'm going to create this function that does something"
702.7600000000001,7.279999999999973," useful, it's not actually running those lines. We have to tell Python that we want to run this function."
712.2,4.960000000000036, So the first thing we're going to do in this lecture is just actually create a function. I'm
717.16,4.480000000000018, going to show you how to define a function. So tell Python that this function exists. And then we'll
721.64,6.079999999999927, see how to actually run the function to give us some useful values. So the function characteristics
727.7199999999999,5.920000000000073," are going to be the function has to have a name. So just like when you create variables, right,"
733.64,5.919999999999959," that store some useful value like pi to 20 decimal digits that you want to reuse over and over again,"
739.56,5.920000000000073, we're going to create a function and that name is kind of like a handle for us to refer to this
745.48,6.639999999999986, large chunk of code that does something useful for us. A function has some inputs called parameters
752.12,6.8799999999999955, or arguments. It could have no inputs or more or one or more. And a function should have a doc
759.0,5.440000000000055," string. So this is the specification. Again, just a multi-line comment that tells the user, the"
764.44,4.719999999999914," person who wants to use this function, the inputs, what the function does, and what the output, or the"
769.16,7.039999999999964," return, or whatever this function will do for you. And then the body of the function is just Python"
776.1999999999999,5.360000000000014," code. Exactly the kind of code we've already been writing except not wrapped in a function, right?"
781.56,4.639999999999986," So if you found yourself writing a piece of code that did something useful, you can totally wrap"
786.1999999999999,5.680000000000064," that in a function and we'll see how to do that today. Right, so the body of the function is just"
791.88,5.919999999999959, a bunch of lines of code that do this useful task. The only difference in the body is that at some
797.8,5.840000000000032," point this function has to end, right? It has finished its task. It figured out a final value, this"
803.64,5.759999999999991, useful thing that's kind of the result of your task. And you want to give this value back to
810.12,5.1200000000000045," somebody who's using this function. And we do that using this return keyword, as we're going to"
815.24,8.319999999999936, see in the next slide. So here's an example of a really simple function. So it's just a definition.
823.56,5.840000000000032," So again, these lines of code do not run. Here we're just telling Python that we're creating a"
829.4,7.039999999999964, function that does something. So we kick that off with a D-E-F defined keyword. So notice it's
836.4399999999999,5.919999999999959," blue. If you type it in your code, you'll notice it changes color. So D-E-F tells Python we're"
842.3599999999999,4.400000000000091," defining a function. The next is the name of the function. So this should be something descriptive,"
846.76,4.4799999999999045," usually an action word, right? Because a function does something. So you want kind of like an"
851.24,9.279999999999973," action type name for your function. Then we have parentheses. And inside the parentheses, you have"
860.52,5.360000000000014," any of the inputs, the parameters, the arguments to the function, right? So what should the user give"
865.88,7.600000000000023," you as input to this function? And then of course a colon. So in that line right there, the only thing"
873.48,5.360000000000014," that is sort of customizable, quote unquote, is the name of the function and the parameters. If"
878.84,4.159999999999968," there's zero parameters, you put nothing in there. If there's more than one, you separate them by"
883.0,7.1200000000000045," commas. Everything else should be standard. The D-E-F, the parentheses, and the colon at the end."
891.72,5.1200000000000045," Since we have a colon at the end, then we, that means we have to indent the next bit of code."
897.96,4.7999999999999545," That, the indentation will tell Python that the rest of this is part of the function. So"
902.76,5.040000000000077," everything from here on out is part of the function definition. So we have our doc string, of course."
908.84,4.480000000000018," You start with triple quotes and you end it with triple quotes. And in it, you can write whatever you"
913.32,6.8799999999999955," want. Just treat it like a comment that's on multiple lines. And you can see here, I've said that"
920.2,7.199999999999932," this function takes in an input, i, which i restrict to be a positive integer. And then I say what the"
927.4,7.040000000000077, input gives back to the user. So it will return true if i is an even number and it will turn false
934.44,5.840000000000032, otherwise. So I've hit all the points. The input is what the function does and what it gives
940.2800000000001,7.600000000000023," back to whoever wants this function to run. Beyond that, we have the body of the function."
948.9200000000001,5.67999999999995," So here, you notice, it's just lines of code that you would have written otherwise. If you were given"
955.24,6.6400000000001," the problem on a quiz that said, given i defined for you, write some code that prints true if the"
961.88,5.440000000000055," number is odd, is even in false if the number is odd. This is basically lines of code that you would"
967.32,10.159999999999968, type in. The only difference is this little return here. The function is sort of some lines of code
977.48,8.480000000000018," that do a task. And that task, when it finishes, has to give something back. It can't just sit there,"
985.96,9.200000000000045, I guess. And the thing that it gives back to whoever wants this function to run is set up by this
995.1600000000001,8.079999999999927," return statement here. So if the number is divisible by zero, we return true and else we return false."
1003.24,5.440000000000055," So one of these, either true or false values, will be returned by the function. So this is kind of"
1008.68,9.279999999999973," you can think of it like the output of the function. Okay. Okay, questions so far, does this make"
1017.9599999999999,7.040000000000077," sense? Again, this is just us creating this function inside the computer inside Python. We're not"
1025.0,10.559999999999945," actually running these lines of code yet. Okay. So if you are given sort of a larger problem, I just"
1035.56,5.3599999999999, want to take a couple of slides to talk about how you think about writing the function. This was a
1040.9199999999998,7.680000000000064, really easy one. So obviously it's not that hard to write. But sort of what is the thought process
1048.6,5.039999999999964, if you were given a larger problem like in English or something like that and you wanted to translate
1053.6399999999999,6.720000000000027, this into a piece of code that does something functionally interesting. Okay. So you'd think about
1060.36,6.960000000000036, what the problem is. So our problem is given an integer figure out if it's even or odd. Okay.
1067.32,6.960000000000036," So given this statement, you could you could come up with the name of this piece of code that's"
1074.28,7.679999999999836, functionally interesting. So is underscore even is a good name. And give and and we can also come
1081.9599999999998,5.920000000000073," up with the inputs for this function. Right. So I, we are only given one number. So there's no need"
1087.88,6.160000000000082," for this function to take in any other inputs. And then using that description, we can now start"
1094.0400000000002,4.7999999999999545," to fill in the dox string that says well, our input is going to be a positive integer. Right. We could"
1098.8400000000001,5.2000000000000455, use sort of math to figure out restrictions on the inputs. And then we can write the dot the rest
1104.0400000000002,4.720000000000027, of the dox string that tells us what to return and what. Right. What the function is doing.
1110.5200000000002,6.399999999999864," And once you have that, you can just solve the problem. So for us, we solve the problem by basically"
1116.92,5.3599999999999," saying if the remainder when we divide i by 2 is zero, we return true. And otherwise, we return false."
1122.8400000000001,5.759999999999991," Okay. So that's some, that's code that you could have already written, right, without actually"
1128.6000000000001,5.279999999999973, this function lecture. But now we're putting it in the context of a function definition. So we're
1133.88,4.720000000000027, going to be able to run this function with many different inputs to give us a bunch of different
1138.6000000000001,6.1599999999998545," outputs, whether a bunch of these different numbers are, are even or not. Okay."
1144.92,5.599999999999909," So when we're writing the body of the code, the only difference is from what you've been doing is"
1150.52,5.599999999999909," the return statement, right. Instead of printing something out to the console, we're going to return a"
1156.12,7.680000000000064, value to somebody who wants to know whether the number i is even or odd. The function can also print
1163.8,5.039999999999964, stuff to the console. But the key thing here is you want to return a value to the user.
1169.24,5.519999999999982," And after you wrote code, you know, right off the bat and you tested and made sure it works, you can"
1174.76,8.639999999999873, improve the code a little bit. So here we're improving it by noticing that i%2 equal equals zero
1183.9599999999998,8.6400000000001," here is actually already a Boolean, right. If i is even, 3%2 equal equals zero is true. And"
1192.6,6.720000000000027," otherwise it's already false. So this line, these four lines of code basically say if true return true"
1199.9599999999998,8.240000000000009, else return false. So our improvement can just be to return whether i%2 equal equals zero right off
1208.1999999999998,6.880000000000109, the bat. Okay. So here we're going to return either true or return false based on what i is.
1215.96,7.839999999999918," So at this point, again, sorry, i'm stressing this enough, too much, but it's really important to"
1223.8,5.440000000000055," understand that once we write these lines of code in the context of a function definition,"
1229.8,9.680000000000064, these lines of code do not run. They basically just sit in Python saying that there are these lines
1239.48,9.519999999999982, of code that correspond to some function object whose name is even. That's it. So what we need to do now
1249.0,7.519999999999982," is to actually tell Python to run these lines of code. To do that, we make a function call. And again,"
1256.52,5.2000000000000455," we've already been doing function calls just to functions that already exist in Python, right,"
1261.72,6.319999999999936," just Python itself, max, absolute, lenn, all that stuff. But now we're making a function call to"
1268.04,7.119999999999891," something that we wrote, right, this nice piece of code that tells us if a number the input is even"
1275.1599999999999,8.960000000000036," or not. So here I've got an, I'm going to invoke the name of my function. So I'm, okay, I'm going to call"
1284.12,5.440000000000055," the name of my function. I'm basically just typing in the name of my function in the code, parentheses,"
1289.56,4.400000000000091," and then the inputs the function expects. There's only one, right, the number I want to figure out if"
1293.96,6.6400000000001," it's even or odd. And then that's it, right. So I've got the name of my function and then all the"
1300.6000000000001,7.199999999999818," input, the parameters that this function expects. At this point, Python goes into the function body."
1307.8,7.8400000000001455, It runs the function and it returns back a value. So whatever the value is associated with the return
1316.76,6.6400000000001," is that value will immediately be given back to whoever called it. What does that mean? Well,"
1323.4,11.920000000000073, that return value will completely replace this function call. Okay. So let's think back to
1335.3200000000002,4.639999999999873, expressions. Do you remember when we were learning about Python expressions? And I said you have
1339.96,5.680000000000064," something like object operator object, like three plus two. That was an expression. And Python went"
1345.64,7.599999999999909," in, evaluated that expression and replaced that entire expression by the value. Five. This is"
1353.24,5.040000000000191," exactly the same thing. In fact, functions are kind of like Python expressions. They do something"
1358.2800000000002,5.3599999999999," useful, right? It's just that it's not math or something like that that gets evaluated. It's a"
1363.64,7.440000000000055," bunch of lines of code that get evaluated. But in the end, that function returns back only one value."
1371.08,8.480000000000018, Okay. And that value replaces the entire function call. So this entire function call is going to be
1379.56,6.480000000000018," basically replaced by false, right? Because it's an odd number. And the next one is going to be"
1386.04,9.3599999999999," replaced by true, right? The return from the function. So the way that the code looks, just this"
1395.3999999999999,5.519999999999982, definition of is even and then running a function call is this. This is all that we would have
1400.92,5.759999999999991," in our in our file, right? So here we have our function definition. And then at the same"
1406.68,4.559999999999945," indentation level, we have a function call, right? Because it's not the call is not part of the"
1411.24,6.6400000000001, function. The call is just making use of the function that we wrote. Okay. So what exactly happens?
1417.88,4.079999999999927, We'll do a little bit of step by step now going a little bit into more detail as to what exactly
1421.96,6.6400000000001," happens when we make the function call. So when we make the function call, so again, function"
1428.6,6.480000000000018," definition, this just tells Python we have this function that does something in our in our"
1435.08,7.3599999999999," program. And then here we have the function call. When as soon as Python sees the function call,"
1442.4399999999998,5.2000000000000455," that's when it starts doing something useful. Up here, it just sort of stores this in memory."
1448.4399999999998,5.519999999999982," So as soon as it sees the function call is even three, it looks at the input parameter to the"
1453.96,7.599999999999909," function call. And here you see we have a value, right? It's an actual tangible object. It's not"
1461.56,7.519999999999982, a some random variable. It's not something abstract. It's a number three. The i up here from our
1469.08,5.440000000000055," function definition is called a formal parameter. It's abstract, right? We wrote the body of the"
1474.52,5.360000000000127," function, assuming the user will eventually give us a value for i. But in the actual body of the"
1479.88,5.920000000000073," function, i is just a variable we're using. Kind of like in the quizzes, right? For now, I've been"
1485.8000000000002,5.039999999999964," saying, you know, assume you're given some number and that's defined for you. Write the code,"
1490.8400000000001,4.480000000000018, assuming you know this number. It's the exact same thing. We write the code of the body of the
1495.3200000000002,7.2000000000000455," function, assuming we know a value for i. So when Python sees this function call with three,"
1502.5200000000002,5.039999999999964," it goes into the body of the function and says, all right, what are my parameters? There's only one"
1507.56,6.400000000000091, it's i and it's going to map them one by one to all the actual parameters given in the function
1513.96,7.519999999999982, call. So basically just maps i to three. And then it executes the body of the function. So replaces
1521.48,5.199999999999818," everywhere you see i. So it might have a longer bit of code here, but here we just have one line."
1526.6799999999998,8.320000000000164," It replaces i with three. So we have 3% 2 equal equals zero. Now we have a tangible value, right?"
1535.0,8.720000000000027, False. So this expression is replaced with false. And so this line of code here will return false.
1543.72,5.920000000000073," And as soon as Python sees that return value, it immediately exits the function and gives back"
1549.64,6.7999999999999545, the value that you're returning to whoever called it. So this entire function call here will be
1556.44,12.0," replaced by false. Okay, that was very step by step, but does it make sense? Okay, so this is a"
1568.44,6.319999999999936," program that doesn't do anything, right? If somebody were to write this program and run it, it doesn't"
1574.76,6.880000000000109," actually show anything to the user. That's because in our program, it's like we had just written a"
1581.64,7.839999999999918," line of code that said false. Does that get printed to the output? No, right? What we need to do is"
1589.48,7.360000000000127, do something useful now that we have the result of a function call. So one useful thing we can do
1596.8400000000001,7.279999999999973," is to actually print the result of the function call. Right, so here we have print. And then I have my"
1604.1200000000001,5.759999999999991," function call I had up here. I'm just sticking it inside the print statement. And Python will, as"
1609.88,5.599999999999909," before, evaluate is even three. This is replaceable false and this line essentially becomes print false."
1619.3200000000002,4.7999999999999545," And so the way this looks in our actual code is this, right? So here I have"
1627.3200000000002,6.7999999999999545," this is even function, the inefficient way of writing it. I've got two function calls here,"
1634.12,6.079999999999927," but if I run the code, it doesn't print anything, right? I need to do something useful with them and"
1640.1999999999998,4.720000000000027, one useful thing we can do is to print the result of these function calls. So now that I've wrapped
1644.9199999999998,8.480000000000018," these calls inside a print statement, I see the output in my console. Okay, so we're writing, so we're"
1653.3999999999999,5.839999999999918," kind of separating ourselves, right, when we're writing code now. One, we're defining a function,"
1659.24,6.7999999999999545," some code that does something useful. And then two, we're using this function that we wrote to"
1666.04,5.680000000000064, make function calls. And the beauty about writing the function is we only write it once and debug it
1671.72,6.7999999999999545," once, but now we can run it as many times as we'd like. Without functions, we'd find ourselves copying"
1678.52,5.680000000000064," and pasting, right, that piece of code that does something useful in many places in our code,"
1684.2,4.559999999999945," which could lead to errors. The code is hard to modify, it's hard to debug, you might,"
1688.76,7.920000000000073," oh, that's tough. Okay, I'll give you a chance to try this out for about a minute. So let's have"
1696.68,4.559999999999945," you write this code. So here I'm giving you the function specification. Most of the time, I'll give"
1701.24,5.8400000000001455, it to you even in quizzes. I want you to write for me a function called div underscore by. This one
1707.08,8.6400000000001, takes in two parameters. Both integers greater than zero and d. And this function will return true
1715.72,10.079999999999927, if d divides n evenly and false if it does not divide n evenly. So if you test it out with
1725.8,4.7999999999999545," those two values, the first one should give us false and the second one should give us true."
1731.48,6.7199999999998," So as usual, this is down in the Python file. So we have around line 28 is where you should start"
1738.1999999999998,11.759999999999991," typing in your code. Does anyone have a start for me? It should be very similar to what we just,"
1749.96,6.960000000000036, yeah. d percent and like double equals zero then correct true.
1767.24,1.2000000000000455," Else,"
1770.8400000000001,4.7199999999998," right false. Okay, so let's run the function."
1775.56,4.880000000000109, Let's just do it with one. So the first one I'm expecting to print false.
1784.76,5.119999999999891," It does print false but it also prints this weird non-write after it. Actually, this is something"
1789.8799999999999,6.0, we want we're going to talk about next lecture. But does anyone know an improvement we can make
1795.88,9.039999999999964," to the code? Yes. Yes, actually, you're right. So instead of printing true,"
1805.48,6.080000000000155," right, remember it's a function, we want it to give us back the value true, right? So instead of"
1811.5600000000002,8.0," printing, we'll do a return true and we don't need the parentheses in this case. And then we'll do a"
1819.56,12.720000000000027, return false. So now we don't have that weird non-write after it. That's something I want. I was
1832.28,7.680000000000064," going to talk about next lecture. But basically, when we had prints here, what did the function return?"
1839.96,7.279999999999973," Did it have every turn statement inside it? No, right? And so if there's no return statement inside"
1847.24,5.680000000000064," the function, Python automatically returns this special none. This is something we'll talk about"
1852.92,5.599999999999909, next lecture more in detail. But the return true return false is correct here. Yes.
1858.52,10.240000000000009, Did you use the return? Yes. You don't need the if else just like before so we can just do return
1868.76,14.720000000000027," this directly, right? Then we can run it with the other one. So the second one should actually return"
1883.48,10.480000000000018," true. But it returned false. Does anyone know the problem? Yes. Yes, exactly. So actually, we want the"
1893.96,8.319999999999936," remainder when we divide n by d, right? So this is just flipped around and percent d equals zero."
1905.48,3.9200000000000728, So it's a good thing we had two test cases to test for that. And you don't have to test them with
1909.4,6.079999999999927, such big numbers. You could obviously test them with some smaller numbers as well. So let's zoom out
1915.48,4.6400000000001," a little bit and talk about how exactly functions are stored in memory, right? Because I mentioned"
1920.12,6.240000000000009, this thing about defining a function and that just doesn't do anything really that we can see.
1926.36,5.440000000000055," But what exactly happens in memory? Well, let's think about what happens when we create variables."
1933.32,6.7999999999999545," So we don't create a is equal to three inside memory or the program scope, again we'll talk about"
1940.12,5.3599999999999, this next lecture. But you can think of this as the memory. What happens is a is becomes a variable
1945.56,5.759999999999991," that's bound to value three, B equals four is a variable B bound to value four and C is going to be bound"
1951.32,7.2000000000000455," to value seven. Clear, right? We already know this. What happens when we create a function? So again,"
1958.52,6.079999999999927, this is something I might write in a code file. The top bit is my function definition. So as soon as
1964.6,6.720000000000027," Python sees this df keyword, everything that's indented, that's part of the function definition and"
1971.32,10.400000000000091," the body is essentially just some code, right? To Python, it does not care at this point what"
1981.72,7.439999999999827, that code is or what that code does. All it knows is that there is a function object and functions
1989.1599999999999,7.040000000000191, are actually objects in Python. There is a function object whose name is even. That is all it
1996.2,5.3599999999999," knows when we get to this point here in the code right after we define a function, right before a"
2001.56,7.600000000000136," equals. So we think about the function as kind of like a variable, quote unquote, it's not actually"
2009.16,6.7999999999999545," variable, but it's like a variable whose name is even and it points to its bound to some code in"
2015.96,5.2000000000000455, memory. And we don't care what that code is right now because we might never use it. We only care
2021.16,6.720000000000027, what the code is when we make function calls. So down here is where the action actually happens
2028.44,6.240000000000009," when we make our function calls. I have a is going to be as usual a variable, right? That's going to"
2034.68,8.0," be bound to some value. So the function definition is kind of just like a black box, right? Once you"
2042.68,5.839999999999918," wrote it once and you know it works, you don't care anymore how it actually achieves its task."
2048.52,6.1599999999998545, All you care is that it takes in a number and tells you whether that number is even or odd via true
2054.68,6.160000000000309," false. So down here where we make our function calls, we're just using our black box."
2062.84,4.879999999999654, And we're using the black box by making function calls. So a is going to be a variable
2068.68,6.720000000000255, that's bound to the value returned by is even. So it's going to be based on the function call
2075.4,5.920000000000073, false. And then here I have another function call. I'm using this useful piece of code that I wrote
2081.32,6.559999999999945, up here. And b is going to be a variable that's bound to true. And c is going to be a variable that's
2087.88,8.960000000000036," bound to true, right? Does that make sense? Kind of separating the code we write, which doesn't run"
2096.84,5.519999999999982, until we actually make function calls. That's the thing about functions and that's how it helps us
2102.36,10.960000000000036, write more robust code. So now here we can have a more complex piece of code where we're using
2113.32,6.0," the function that we wrote. Not just making a function call and printing the result, but we're"
2119.32,6.320000000000164, actually using it inside a more interesting program. So here I've got a program that will print for
2125.6400000000003,5.7599999999997635, me the numbers between one and ten and it'll print whether that number is odd or even. So if you
2131.4,5.760000000000218," were just to read this code, it's pretty easy to read, right? We have a loop that goes through the"
2137.1600000000003,9.039999999999964," numbers one to ten, not including ten. And then I have this if is even. Well that's cool. Here I'm"
2146.2000000000003,8.239999999999782," using the function that I wrote kind of just in the middle of another piece of code, right? Which is"
2154.44,8.320000000000164," fine because as I said a few slides ago, function calls are basically just expressions, right? They"
2162.76,5.679999999999836," get run, they get evaluated, you get one value back out of them, and then that value replaces the"
2168.44,7.2800000000002," function call. So that's fine. Let's use the is even result, the return from the is even method"
2175.7200000000003,8.639999999999873," inside a conditional. If I, if calling is even with I returns true, that means if the number"
2184.6,7.120000000000346," is even, we print that value comma even. Else we print that value comma odd. So here I'm not defining a"
2191.7200000000003,4.7199999999998, function. Notice it's not wrapped in the df or anything like that. I'm just using a function that I
2196.44,9.840000000000146," already wrote. So inside here, just comment that out. This is the code we just had on the slide. So"
2206.28,4.799999999999727," again, notice it's not with it, it's not wrapped within a function. It's just a loop that tells me"
2211.16,4.800000000000182," the numbers one at a time, whether they're odd or even, right? So prints one comma, yeah."
2220.2,8.16000000000031," Oh, when I select everything, I just use spiders like ability to, so I do control one or command one"
2228.36,6.0," probably on a Mac, and it just comments and uncomments things in batch. Yeah, very useful. Yeah."
2236.04,4.7199999999998," And so this code is now very easy to modify, right? I can just choose 100 and then I can run it"
2240.76,5.039999999999964," again, and it gives me the numbers one through 100 odd or even. And you can imagine using your"
2245.8,7.119999999999891," is even function in a more complex setting, right? And is even is a really simple function to write,"
2252.92,5.360000000000127," but again, you can imagine writing a more complex function. And then that complex function isn't a"
2258.28,5.119999999999891," whole chunk of code that just gets stuck into this program, this loop. It's going to be a function"
2263.4,5.200000000000273, that you call that you can just easily read the specification for and you don't need to completely
2269.08,11.11999999999989," understand how it works in order to use it. Okay, so we're going to go through one other example"
2281.24,6.079999999999927, to write a little function. And this will also showcase kind of the best practices for writing a
2287.3199999999997,5.040000000000418," function and writing code, especially maybe in a quiz situation or something like that, how to"
2292.36,5.4399999999996," write incremental code, how to test it a little bit at a time, and so on. So the last example I"
2297.8,5.8400000000001455, want to go through is I want to write some code that adds all the odd integers between and including
2303.6400000000003,8.879999999999654, A and B. It might be something you're asked on a quiz. The first thing you do when you're faced with
2312.52,6.320000000000164," such a task is to think about a nice name for the function, so some odd or some odds is a reasonable"
2318.84,4.960000000000036," name. The inputs to the function, well, I've got two endpoints, I want to sum odd numbers in between,"
2323.8,7.119999999999891, so the inputs might well be my two endpoints. And then what is the thing you function achieves?
2330.92,5.360000000000127," Right? Well, in the end, it's going to give me some sum. So let's call that sum a variable sum"
2336.28,6.880000000000109," underscore of underscore odds and we'll return it at the end of our function. And between,"
2343.1600000000003,7.119999999999891," we're going to have some code. Okay, so first thing to do is to not write code right away when"
2350.28,5.199999999999818," you're faced with a task again on a quiz or something like that. It's best to take a piece of paper,"
2355.48,6.320000000000164," write a little bit, one example, and try to think about how you'd solve it not like a human would,"
2361.8,5.599999999999909," because for us, we would immediately know the sum, right? It's very easy for humans to identify"
2367.4,5.360000000000127," solutions to these problems, but try to think about how you would write, what kind of a recipe"
2372.76,4.800000000000182, would work for this? Would you loop? Would you have a conditional? Would you use a for loop or a
2377.56,6.320000000000164, while loop? And a bunch of other concepts that we'll learn about in the following lectures. But
2383.88,4.799999999999727," the key thing is to just not write code right away. So if we draw, start with a really simple"
2388.68,8.640000000000327," example on paper, we can say let's choose endpoints, A is 2 and B is 4. On paper, I would probably"
2397.32,6.1599999999998545," write out 2, 3, 4 in a row, right? So I know the numbers I need to look at. I would say 2 is my A,"
2403.48,7.039999999999964, 4 is my B. I need to look at every one of these numbers one at a time. Reasonable. I can do
2410.52,4.800000000000182, another example. Sorry. And I know what the answer should be. So I figure out what the answer should
2415.32,5.519999999999982," be so that when I write my code, I actually know what I'm looking for. I look at another example."
2420.84,4.639999999999873," Let's say a little bit more complicated, a bigger range, A is 2, B is 7. I try to use the same"
2425.48,6.0," strategy I used, same recipe. I used to solve that simpler example in this harder one. So again,"
2431.48,5.440000000000055," I'm going to write out all the numbers between 2 and 7, inclusive. This is my first, this is my last."
2437.56,6.079999999999927," And my strategy was to go through one at a time. And if it's odd, I take it to my running some,"
2443.64,5.519999999999982," and add it to my running some, and if it's even I don't, I ignore it. And again, I know the answer"
2449.16,6.320000000000164," for this should be 50. So with these two examples in mind, I can start writing code. But instead of"
2455.48,5.8400000000001455," writing code for the big problem, that might include some nuances or some edge cases, I can actually"
2461.32,5.599999999999909," try to solve a similar problem. So instead of summing all the odd numbers between A and B,"
2466.92,5.200000000000273, let's just sum all the numbers between A and B. And see if we can get code working for that.
2472.1200000000003,4.319999999999709," Once we do, figuring out the odd ones should be a small tweak to our code."
2478.36,4.320000000000164," So if we start with figuring out some of all the odd numbers between an including A and B,"
2483.4,4.559999999999945," that sounds like a loop because I knew when I wrote my example on paper, I'd have to touch each"
2487.96,6.559999999999945, number between an including A and B. So I know I need to loop through every one of these values.
2495.7200000000003,5.199999999999818," While or a for loop, your choice in the slides, I'll do both, just to see what it looks like."
2501.56,4.639999999999873," So with a for loop, it's easy. It's just for i and rnjb. But with a while loop, remember,"
2506.2,6.880000000000109," we have to initialize our loop variable if we have one, i equals a. Our loop condition is while i"
2513.08,5.039999999999964, is less than or equal to B. So we're going to loop through while I'm looking at all these values
2518.12,5.199999999999818, up to an including B. And I need to remember to increment my loop variable within the loop.
2524.2799999999997,7.680000000000291," By one each time in this case. Okay. And then what do I do within my loop? Well, I'm going to,"
2531.96,4.239999999999782," remember, we're solving a similar problem. I'm going to keep a running sum. So as soon as I see a"
2536.2,7.2800000000002," new i, I'm going to add it to my sum. I realize here, probably my IDE, which showed me that there's"
2543.48,4.0, an error. I didn't initialize some of odd. So I remember to initialize some of odd's right before
2547.48,4.7199999999998, the loop. And then this is a good place to test the code for a little bit. So we'll test it with
2552.2,8.079999999999927," a really simple example, 2,4. Okay. If we test it with 2,4, the for loop gives me a 5, but the"
2560.76,6.480000000000018, the while of gives me a 9. So you guys might have noticed what the problem is. My for loop goes
2567.2400000000002,7.599999999999909," through up to, but not including the end variable, right? The B. So we can add a print statement in"
2574.84,4.559999999999945," case you didn't figure that out. And the print statement would actually tell us, right? It tells us"
2579.4,7.2800000000002," what we're incrementing. First it's 2, then it's 3, but I never hit the 4. So the fix is to just"
2586.68,5.440000000000055, change my end range to bb plus 1. And then we run it again and we see the answers match.
2594.12,6.400000000000091," And this solves the bigger problem. So now all we need to do is adding the nuance, the piece where"
2600.52,6.079999999999927," we just grab the odd numbers. And here we say, well, if I'm just grabbing the odd numbers, I only want"
2606.6,8.159999999999854, to add i to my sum of odds when I see an odd number. So here I could use my is even function that
2614.76,5.8400000000001455," I already wrote. I would say if not is even, or I can just do it all over again. If I percent 2"
2620.6000000000004,7.839999999999691," equi equal 1, then we do this. And now we can run it again. And hopefully this now matches with"
2628.44,6.320000000000164, example I had on paper. And it does. So the idea here is to try to solve a simpler problem first.
2634.76,4.480000000000018," And then as you see more nuances to the problem, add in the functionality just a little bit at a"
2639.24,5.760000000000218, time. So you don't actually get bogged down by a whole bunch of problems issues that might come up
2645.0,5.679999999999836, when you wrote a whole bunch of code. The last step is just to test it on the other example just
2650.68,6.0," to make sure that it still works. And so if we print some of odds between 2 and 7, again, this matches"
2656.68,6.960000000000036," what I had written down on paper. If you don't want to use print statements, the Python tutors also"
2663.64,6.480000000000018," a great debugging tool. So testing code often, very useful. I think I've stressed this in"
2670.12,4.7199999999998, previous lectures as well. Using prints or the Python tutor did debug is also very useful.
2675.64,5.920000000000073," I don't actually intend to go through this you try it, but this along with a bunch of other"
2681.56,7.920000000000073, examples or things to try at home are in the Python file. So just functions you can write is
2689.48,7.760000000000218," palindrome, keep consonants, read the function specification and try to write code that matches"
2697.2400000000002,5.039999999999964," the specification. And as usual, the answers are in the Python file, but please try to do them on"
2702.28,9.519999999999982," your own first before looking at the answers. Okay, a quick summary. Functions are very useful,"
2711.8,5.279999999999745," allows us to abstract certain useful tasks, right? Basically, I've tracked away functionality that"
2717.08,6.559999999999945," we might reuse many times in our program. Functions take an inputs, they have something to return."
2723.64,6.320000000000164, We're going to see next time what happens when we don't return anything. Creating a function
2729.96,5.359999999999673," is different than running the function, right? So you create the function once, but you can run it"
2735.3199999999997,5.680000000000291," many, many times. And that's what makes functions useful. It makes code easy to write, read, debug,"
2741.0,4.079999999999927," modify, leads to very nice robust code. Okay."
