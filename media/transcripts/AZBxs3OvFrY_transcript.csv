start,duration,text
0.0,22.0," Okay, let's get started with today's lecture."
22.0,4.879999999999999," It's going to be more of a chill lecture than what we've done in the past, even though"
26.88,5.080000000000002, we've got quite a few things to cover as you can see from this title slide. I'm not going
31.96,4.279999999999994," to go super duper fast, so please feel free to ask lots of questions, and then the second"
36.239999999999995,4.480000000000004, half of the lecture will be really chill because we're going to be talking about testing
40.72,6.840000000000003," and debugging strategies. So super high level topic. But first, we're going to tie up some"
47.56,5.679999999999993, loose ends related to lists and relating to functions. So we're not going to introduce
53.24,6.280000000000001," a lot of new syntax. These ideas are sort of more optional in your day to day coding,"
59.52,5.240000000000002," but they're just really, really nice to know. So let's first start talking about this idea"
64.76,9.159999999999997," of a list comprehension. So you've been writing functions that deal with lists, and one really"
73.92,6.239999999999995, common pattern that I hope you've seen so far is the following. So this code right here
80.16,4.480000000000004," shows something that we've definitely coded together, and you've definitely coded in"
84.64,5.0, the finger exercises and the quizzes. And so it is a really common pattern. So the idea
89.64,5.8799999999999955, here is you have a function that creates a new list where the elements of this new list
95.52,6.679999999999993, are a function of the input list. So the pattern here is we create a new empty list inside
102.19999999999999,6.400000000000006," the function. We have a loop over every element in the input, and to each one of these elements"
108.6,4.040000000000006," in the input, we apply the same function. So in this particular case, we're taking that"
112.64,5.8799999999999955," element and squaring it. And each one of these elements were appending to this new list,"
118.52,5.519999999999996," originally empty, until we've reached, we've done this function to every element in L,"
124.03999999999999,6.560000000000002, and then we return this newly created list. So since this is a really common thing that
130.6,8.280000000000001," programmers do, Python allows you to do this exact functionality with one line of code."
138.88,5.0, And the way we do this is using something called the list comprehension. So the way that
143.88,5.639999999999986," we do a list comprehension, essentially taking these four lines of code from this function,"
149.51999999999998,6.480000000000018, we are going to write them in this one line of code that looks something like this. So
156.0,5.8799999999999955," the idea here is with this one line of code, we're going to create a new list, we're going"
161.88,4.920000000000016," to have an iterator that goes through some sort of sequence of values, and we're going to"
166.8,5.839999999999975, apply the same function to every one of those elements. And the other optional piece that
172.64,5.28000000000003, we can add inside this list comprehension is to only apply that function if some condition
177.92000000000002,8.0, holds. So let's look at this example and see how we can convert this into a new list.
186.39999999999998,7.160000000000025, These four lines of code to one line of list comprehension code. So we've got creating a new
193.56,10.279999999999973," empty list. This is going to tell Python to create a new empty list for us. Okay, so just open"
203.83999999999997,5.280000000000001," and close square brackets. And within these open and close square brackets, we're going to write"
209.12,7.960000000000008, a one-liner expression. And this one liner is going to encapsulate these two lines of code
217.08,7.079999999999984," here. So the expression, sorry, the function we're going to apply to every element in L is"
224.16,4.0, going to be taking that element and squaring it. So on the right hand side here in the list
228.16,6.800000000000011," comprehension, we've got some e squared. Well, what is e? Well, it's going to be every"
234.96,6.719999999999999," element e in L. Okay, so if we read this in English, we basically say L news going to contain"
241.68,6.0800000000000125," elements e squared for e in L. Right, so it sounds weird, but it kind of makes sense even if we"
247.76000000000002,7.759999999999991," read it in English. And behind the scenes, Python will take one by one, each element in L, square"
255.52,9.119999999999976," it. And that's the sequence of elements it will populate this L new width. Okay, now what if we add"
264.64,7.439999999999998, a condition to that? So let's say we want to create this new list of elements only for even
272.08,6.319999999999993," elements. So we only want to square the even elements within my original list L. Well, if we were"
278.4,5.360000000000014," to write a function that does that, we have to add this extra condition here. So everything else"
283.76,7.360000000000014, is the same except for this if e percent 2 equal to 0. This tells Python to only grab elements that
291.12,7.199999999999989," are even, right, divisible by 2. So how do we write this in list comprehension form? So here's a"
298.32,6.240000000000009," new list and this is the function to apply only if the test is true. In list comprehension, this is"
304.56,10.240000000000009, my new list. I've got the for loop is over here and then the test to apply is at the end here
314.8,4.8799999999999955, if e percent 2 equal equal 0. And then what is the function we're applying? It's just e squared
319.76,6.240000000000009, like before. So the test just gets appended to the end of this list comprehension expression here.
328.72,10.879999999999995, Yeah. Does it run faster? I'm not sure actually. It might run marginally faster but probably not
339.6,6.9599999999999795," significantly. The reason to do this is because as you get more practice with it, this will be easier"
346.56,7.1200000000000045," to read in code. And often if you see a large chunk like this, your eyes will glaze over, right?"
353.68,4.8799999999999955," You're not going to want to read a chunk like that. But if you see it all in one line, you're going"
358.56,6.639999999999986," to think, well, how bad can it be? And so you can come up with really complicated list comprehension"
365.2,7.600000000000023," expressions. But usually we reserve them for really simple, really quick ways to create these lists"
372.8,5.600000000000023, that you just populate with some values right off the bat. So it just makes the code a lot easier to read.
381.68,5.600000000000023," Okay. So list comprehension are pretty useful. If you get a little bit of practice with them,"
387.28000000000003,6.639999999999986, you'll find yourself kind of using them all over the place. And they basically replace code that
393.92,6.480000000000018, looks like this. Okay. So these lines of code is a very generic way of writing this one
401.12,7.359999999999957, liner list comprehension. So here I've got a function f that I would like to apply. This xpr
409.44,5.439999999999998, expression is the function I would like to apply to each element. This is the list I would like
414.88,6.7999999999999545," to apply that function to. And the test is going to be the conditional. In this particular case,"
421.67999999999995,6.240000000000009," this test means I apply it to every single element. But you can imagine having a function which,"
428.56,5.920000000000016," in the previous case, we would say lambda x, x percent, 2 equals 0 as our conditional. And then"
434.48,5.680000000000007," the function that we're essentially replacing is this with list comprehension. Right, we create"
440.16,5.0400000000000205," this new list. Again, this is the pattern that we saw in the previous slide. We loop through every"
445.20000000000005,5.759999999999991," element in the list if that condition holds, append that function applied to each element."
451.68,5.360000000000014," And then at the end, return the list. Okay. So this is just a very generic way to write a list"
457.04,8.560000000000002," comprehension. So let's look at some concrete examples. So here, I'm not applying the function"
465.6,6.639999999999986, e squared to a particular set of elements from a list. I'm applying it to the sequence of values
472.24,4.400000000000034," given by range. Remember when we were talking about four loops iterating through things,"
476.64000000000004,7.599999999999966," they can iterate through integers following some pattern like range 6, range 1, 9, 2, something"
484.24,5.199999999999989," like that. As long as you have a sequence of values you can iterate over, you can plop that"
489.44,5.520000000000039, into the list comprehension. So you could iterate over lists. You could iterate over two pulls.
494.96000000000004,5.759999999999991, You could iterate over these direct ranges. You could iterate over range of the length of a list.
500.72,5.359999999999957," Whatever creates an iterable for you, you can put that in the list comprehension."
506.8,5.0400000000000205," So in this particular case, the way I read this is I've got something that I'm squaring. And what's"
511.84,5.999999999999943, the thing that I'm squaring? It's going to be each value in range 6. So I think about it like
517.8399999999999,4.240000000000009," what is the sequence of values that I'm going to operate on? Well, it's going to be the number 0,"
522.0799999999999,5.360000000000014," 1, 2, 3, 4, 5. And the thing that I'm going to do to them is square each one of those values."
528.0799999999999,6.720000000000027," So the end list that I get out of this one liner here is a list containing 0 squared, 1 squared,"
534.8,6.720000000000027," 2 squared, 3 squared, 4 squared, and 5 squared. We can add a condition to that. So here,"
541.52,8.960000000000036," I've got the each element squared for e and range 8, only if e is even. So then, the way I think"
550.48,5.439999999999941," about it is, let's start off with what every element in the range is. Well, it's 0, 1, 2, 3, 4, 5, 6, 7."
556.8,4.960000000000036," The condition I'm applying to that is that it's even. So the numbers I I'm going to end up with,"
561.76,7.919999999999959," I'm filtering all those to only contain 0, 2, 4, and 6, because we go up to but not including 8."
570.2399999999999,4.720000000000027, And then I'm going to square every one of those. So the end result from this list comprehension is
574.9599999999999,8.879999999999995," a list containing the element 0 squared, 2 squared, 4 squared, and 6 squared. And lastly,"
584.56,5.360000000000014," you know, we've been doing just single integers in the resulting list. But as I mentioned,"
589.92,6.0, we can do more complicated things. So as long as we can write a little expression here for the
595.92,5.2000000000000455," thing that we'd like to calculate or add to the list, we can put it in the list comprehension."
601.8399999999999,6.800000000000068," So in this particular case, the element that I'm adding to my resulting list from the"
608.64,6.079999999999927, list comprehension is a list itself. So each element in my resulting list is another list.
616.4799999999999,6.000000000000114, And that inner list is going to contain two elements every time. The thing I'm actually iterating
622.48,10.32000000000005," over and it's square. And I've got a condition here. So I've got the elements 0, 1, 2, and 3."
632.8000000000001,6.399999999999977, That's the range. But I'm only grabbing the odd ones in this particular case. So the resulting
639.2,7.67999999999995, set of numbers that I'm going to I'm going to apply this to is going to be the number is the
646.88,8.159999999999968, numbers 1 and 3. Because those are the two odd numbers in range 4. And so the resulting list
655.92,5.680000000000064, is going to contain two elements. So this outer square bracket is the list that I've created.
661.6,6.959999999999923, And its elements will be the element that I have actually iterated over and it's square as a list.
669.52,10.079999999999927," So 1 and 1 squared for e and e squared when e is 1. And then 3 and 9, 3 squared when e is 3."
682.8,0.8799999999999955, Questions about that?
686.4799999999999,5.5200000000000955, Okay. So pretty cool. It's a really nice way to create lists really quickly. Like if you wanted to
692.0,6.240000000000009," create a list full of zeros, full of 100 zeros, no need to do a loop. You basically do a"
698.24,7.600000000000023, list comprehension that says square brackets 0 for e and range 101 or 100. And then you've got
705.84,8.480000000000018, yourself a nice list full of 100 zeros. All right. So think about this and then tell me what
714.32,8.32000000000005, the answer is. So the idea here is we have this list comprehension. And just go through it step
722.6400000000001,5.279999999999973, by step. It looks a little bit intimidating. But the first step is to look at the for loop and ask
727.9200000000001,6.0, yourself what are the values I'm iterating over. Then look at the condition if there is one.
733.9200000000001,4.559999999999945, There is one. In this case it's at the end here. So now what subsets of those original things
738.48,5.1200000000000045," you're iterating over are you actually keeping? And then from those things that you're keeping,"
743.6,5.840000000000032, what function are you applying? It's the one right at the beginning. So think about it and then
749.44,9.919999999999959," I'll ask you to tell me. So step one, what are the values I'm iterating over? The full values,"
759.36,9.200000000000045," not including the condition. Someone yell it out. Yeah, that list in the middle. Awesome. Okay."
768.56,11.200000000000045," So x, y, abcd, right. And then seven. And then what's the last thing? Is it the number 4.0 or a"
779.76,8.799999999999955," string? Yeah, exactly 4. Okay. String, string. Step two, from this list, what are the values that I'm"
788.56,7.1200000000000045," actually keeping, right, based on the condition? If they're a string. All right, which one's a string?"
795.68,12.799999999999955," Is x, y? Yes. Is abcd? Yeah. Is seven? Nope. Is four? 0. Yes, except. Okay. Okay. So then these are the"
808.4799999999999,4.560000000000059, elements that I'm keeping. And now what's the function I'm applying and what's the result going to be?
813.68,10.080000000000041," It's going to be a list containing, yeah, three, two, four, three, two. Because that's length two,"
823.76,5.67999999999995," four, because that's length four, and three, because that's length three. Great. And we've got"
829.4399999999999,6.480000000000018," ourselves a nice little list based on that condition, that sequence of values, and that function applied. Yeah."
838.64,6.240000000000009," Why does it return a list? The whole thing? Or like, I guess like, I thought it was return like two,"
844.88,4.960000000000036," four, three, and something like that. Oh, yeah. So we're not printing things out here. When we're"
849.84,4.8799999999999955," writing this as a list comprehension, we're essentially telling Python to create this resulting"
854.72,5.440000000000055, list of values. That's just what a list comprehension does. And so just kind of this expression here
860.1600000000001,5.039999999999964, with these outer square brackets around our entire expression tells Python that the resulting
865.2,12.240000000000009," thing is a list. Yeah, this is a good question. Other questions? Okay. Okay. So that, oh yeah, question."
880.72,6.480000000000018," Does it support multiple conditions? Yes. So at the end here, you know, you would say if,"
887.9200000000001,6.319999999999936," and then you could wrap them in parentheses. I think, I don't know if you have to, but just to be safe,"
894.24,5.440000000000055, I would wrap my conditions in parentheses. And you'd use AND or whatever you want to combine the
899.68,9.200000000000045, expressions or the conditions with. Does it question? Yeah. This one? The lambda?
910.88,4.639999999999986," Here, this is a lambda function that we talked about. I forget when a couple lectures ago."
916.4,4.959999999999923, It's basically an anonymous function. And all it does is return true all the time.
922.16,9.600000000000023," So the test will always be true, which means that when we do if test parentheses E, this will always"
931.76,5.1200000000000045, be true in this particular case. But we're given a different lambda function. That might not be the case.
939.12,5.919999999999959," Okay. So let's move on to the next topic. The next, I guess, two topics. We'll be dealing with functions."
945.04,5.280000000000086, And I want to wrap up a couple things here just to give you a couple more ideas regarding function.
950.32,5.440000000000055, So the first one is actually related to this last question is the idea of a default parameter.
955.7600000000001,7.839999999999918, So this is going to be a way for us to add parameters to our functions that get some default value.
963.6,5.920000000000073, And that's what that lambda thing actually was in that example. But hopefully this piece of the
969.5200000000001,4.079999999999927, lecture makes that a little bit more clear. And then the second part regarding functions we're going
973.6,6.32000000000005, to go over is the idea of functions as objects kind of working up on that. And we're going to see
980.0,6.639999999999986, what happens when we return a function object from another function. We've seen functions as parameters
986.64,4.319999999999936," to other functions, but we're going to see what happens when you make a function be the return"
990.9599999999999,6.240000000000009," value of another function. But that's in a little bit. For now, let's look at default parameters."
998.64,8.480000000000018, Okay. We've seen this code before. Triggering flashbacks. So this is by section root. I'll go over it
1007.68,6.960000000000036," just to remind ourselves what it does. We've got this code inside this function. We wrote a long,"
1014.64,5.680000000000064, long time ago. And then we decided to wrap it in a function so that it's a really nicely
1020.32,5.919999999999959," useful piece of code that we can run many, many times. So the parameter to this function was x."
1026.8,7.039999999999964," Of value, we'd like to approximate the square root of. And the code we're using to approximate"
1033.84,7.839999999999918," is using the bisection search algorithm, which initializes some variables, namely epsilon,"
1041.6799999999998,6.0," how, how, sort of how close we want to be to the final answer, low and high end points. We remember"
1047.6799999999998,7.2000000000000455," that. And then initial guess, the halfway between low and high. And then we keep making guesses"
1054.8799999999999,8.079999999999927," between low and high, right? Being the midpoint of low and high. As long as we're not close enough to"
1062.96,6.559999999999945," the final, we're not close enough to the final answer, right? So we're going to either"
1070.4,5.2000000000000455, reinitialize our low end point or our high end point depending on whether that guess was too low or
1075.6000000000001,6.7999999999999545," too high. And then within the loop, we make another guess using those changed values of either low"
1082.4,6.0, or high based on if or else. And then we keep doing this process of making more guesses at the
1088.4,8.88000000000011," halfway point as long as we're still farther than epsilon away. Okay, that was a recap of what we've"
1097.2800000000002,5.599999999999909," done so far. The interesting thing that we had done with this function was, or when we turned it"
1102.88,6.240000000000009, into a function was to return our approximation. So this guess instead of just printing it to the
1109.1200000000001,5.839999999999918," to the user, we returned it so that it could be useful in other parts of the code. And so when we"
1114.96,9.039999999999964," called the function, we just said name a function and then some value of x. Now there are situations"
1124.0,6.240000000000009," where a user would want to change the value of epsilon, right? Right now, with the way we wrote this"
1130.24,6.960000000000036," code, epsilon is set to 0.01. And whenever you run the function, it always finds the approximation"
1137.2,6.319999999999936," to the square root of x to that precision, 0.01. Now sometimes, you know, depending on the"
1143.52,6.7999999999999545," application, the user might want an even better approximation, so 0.0001, or they might not care"
1150.32,5.2000000000000455," to be as precise and they want, you know, maybe approximated to 1 or to 0.5 or something much bigger"
1155.52,7.440000000000055," than 0.01. So what are the options in this particular case, right? For these scenarios? One option"
1162.96,5.759999999999991," would be obviously to go inside our function and say, well, I'm going to change epsilon to be"
1168.72,7.039999999999964," something super duper precise, 0.0001. And so people who call this function will always get an"
1175.76,4.880000000000109," approximation to that precision. But what about people who don't want it that precise, right?"
1181.68,5.3599999999999," So all the function calls are going to be affected by making that change, and so that's not really"
1187.04,4.480000000000018, desirable. We'd like to let the person who makes the function call be in charge of what precision
1191.52,6.080000000000155," they'd like. Another option is to put epsilon outside the function. So to say, okay, well,"
1198.32,6.319999999999936," the only parameter is going to be x, and let's not set epsilon within the function. Let's let the"
1204.6399999999999,6.0," user maybe set epsilon outside the function, and then they can use, and then our code will basically"
1210.6399999999999,4.079999999999927, pop up one level to the global scope and use the epsilon that the user chose.
1216.24,7.519999999999982," Not a good idea, because as soon as we allow somebody using our code to kind of make their own"
1223.76,6.480000000000018," variables within our code, we're putting our trust in somebody else's hands, and they might"
1230.24,5.920000000000073," forget to reset epsilon, or they might forget to set it to begin with. And so that's just using"
1236.16,4.959999999999809, global variables is not a good idea in the first place. We'd like to keep control of the epsilon
1241.12,7.2000000000000455," that's being used inside our function. So, unsurprisingly, the last option is going to be our best"
1248.32,8.480000000000018, option. Let's just add epsilon as another parameter to the function. So there it is. We've got
1257.9199999999998,6.800000000000182," bisection root, again, as a function. We've got a parameter x, and we have epsilon as a second"
1264.72,10.7199999999998," parameter that the user can call the function with. So other than that, the function body is exactly"
1275.44,5.920000000000073," the same, right? Except that right now, when we make a function call, we have to pass in epsilon"
1281.3600000000001,9.3599999999999," as the second parameter. So in terms of code, this is the bisection root with epsilon as a parameter,"
1290.72,8.960000000000036," and so now the user can find the approximation to 123 to 0.1. It's 11.088, in case you're wondering."
1299.68,6.720000000000027," And then the approximation to underturni3, 2.0001, which is 11.095."
1309.1200000000001,7.519999999999982," So much better, the user can now be in charge of deciding how close they'd like the approximation"
1316.64,7.440000000000055," to be for every one of their values. But notice that this code is kind of verbose,"
1324.72,6.559999999999945," and really most of the time, maybe the users don't want to be in charge of setting the epsilon."
1331.28,5.2000000000000455," Maybe they don't know what a good epsilon might be, right? So how do they know that they should"
1336.48,4.879999999999882, choose 0.0 on by default? Maybe that's something you could put in the function specification for
1341.36,6.480000000000018," anyone using your function. But it's, you know, you're going to rely on users reading your"
1347.84,7.519999999999982," specification, and that's a little bit scary. So instead, the functionality that would really like"
1355.36,8.160000000000082," to have is to say, okay, I want to write a function that does take into parameters. But by default,"
1363.52,4.960000000000036, one of those parameters is something that I set as the person who's writing this function.
1369.76,5.199999999999818, So what I would really like to have is epsilon to have some sort of a default value.
1375.68,5.3599999999999," So if users don't know what to call it with, the code will just use that default value."
1381.6000000000001,5.599999999999909," And otherwise, if the user is more experienced, and they know they'd like an epsilon of, you know,"
1387.2,4.480000000000018," one times 10 to the negative 10 or whatever it might be, then they can be in charge of setting it."
1392.4,5.599999999999909," So most of the time, we want to call the bisection root function without an epsilon parameter,"
1398.0,5.279999999999973, so that it may use a default one. But sometimes we'd like to allow the user to actually set the
1403.28,6.559999999999945," epsilon. And so to that end, we're introducing the idea of keyword parameters, also known as"
1409.84,8.559999999999945," default parameters, and they are set like this. So the bisection function definition still takes"
1418.3999999999999,5.920000000000073," in the thing we'd like to approximate the square root of, x. But the second parameter here,"
1424.32,5.920000000000073," epsilon, will be equal to something inside the function definition. So we as the people who are"
1430.24,4.720000000000027," writing this function, or they're going to say the default value of epsilon is .01."
1438.64,6.639999999999873," So that means when we call the function down here, if the user makes a function call without"
1445.28,6.079999999999927," explicitly passing in a second parameter, Python will use the default one that the person"
1451.36,6.720000000000027, who wrote the function set. So Python will run bisection root of 123 with epsilon being .01.
1458.56,6.079999999999927," And otherwise, if the user does want to override that epsilon, they can just pass it in themselves."
1464.6399999999999,8.720000000000027," And that default value of .01 will be overwritten to be .5. And so in our code here,"
1475.36,5.600000000000136," this is the bisection root with the default values. And so you can see here, if I run it with 123,"
1480.96,3.6799999999998363," even though there are two parameters here for the bisection square function,"
1485.3600000000001,6.240000000000009," it's, Python doesn't complain because it's using epsilon as .01. So I run it and it runs just fine."
1493.3600000000001,6.319999999999936," But in the second line here, if I actually want to use .5 as my default, as my epsilon value,"
1499.68,5.360000000000127, it overrides my default parameter and it calculates the square root of 123 with epsilon being .5.
1505.28,1.3599999999999, Okay.
1509.6,0.7999999999999545, Questions so far?
1514.8,6.240000000000009," So now that we've introduced default parameters, there's a few sort of rules about making function calls."
1522.32,4.160000000000082," When you create the function definition, so over here, right, when you're the one defining a"
1526.48,5.3599999999999," function and you decide to allow some default parameters in your parameter list, everything that's"
1531.84,5.119999999999891, a default parameter needs to go at the end. You can't switch these around. You can't say
1536.9599999999998,8.0," epsilon equals .01, x. Python will not allow that. So anytime you have default parameters, they always"
1544.9599999999998,6.720000000000027," have to go to the end. That's the only rule for making the function, or making defining the"
1551.6799999999998,5.2000000000000455," function with default parameters. And then once you have default parameters, you can actually call"
1556.88,4.960000000000036," the function in many, many, many different ways. Okay. And I know these, some of these will be"
1561.8400000000001,4.639999999999873, confusing. You might not know whether they're allowed or not. You can never go wrong with the last
1566.48,6.6400000000001," one, as we're going to see in a bit. So the first one here showcases what happens when you give values"
1573.1200000000001,6.079999999999927," for everything that's not a default parameter. Right. In this case, just x. If you just give a value"
1579.2,5.039999999999964," for non-default parameters, Python sets default parameters for everything else. Not a big deal."
1584.24,6.880000000000109," Alternatively, you can pass in just like we have in the past when we write our own functions"
1591.1200000000001,5.3599999999999, with multiple parameters. You can pass in one at a time in the same order values for every one of
1596.48,5.039999999999964," those parameters. Default or not. And if you pass in values for all of them, Python will not be"
1601.52,7.680000000000064," confused, and it'll just match them one at a time. Variations on that, you can always pass in a"
1609.2,9.039999999999964," value for a parameter name. Okay. So looking at the function definition, we can see the parameter"
1618.24,6.7999999999999545," names, the formal parameters are named x and epsilon. So when you make your function calls, you can"
1625.04,7.759999999999991," actually explicitly tell Python something like this x equals 123, epsilon equals 0.1. Right. And if"
1632.8,4.240000000000009," you have more parameters, you say that parameter equals whatever value you want to run it with."
1637.76,4.319999999999936," And so that will not confuse Python. And if you do it in that way, you can actually"
1643.04,5.039999999999964, do it in any order you'd like. Because Python will just assign each one of these variables to be
1648.08,6.079999999999927," whatever you told them to. Okay. So, you know, worst case, you just do something like this,"
1654.1599999999999,3.8400000000001455," right, where you want at a time, you just say what the formal parameter is and its value. And then"
1658.0,5.2000000000000455," Python will not get confused. The ones at the bottom, though, is where we run into trouble."
1664.16,6.0," So for example, if you put the default parameter first and then you put an actual parameter,"
1670.16,4.720000000000027," sorry, you put the default parameter first and then any parameter that's not a default one"
1674.88,6.559999999999945," afterward, Python gives an error because the default ones have to go after the non-default ones."
1682.4,5.919999999999845," And the last one doesn't actually give an error, but Python remember matches parameters one by one."
1688.8799999999999,7.680000000000064, So it's actually going to find the approximation to the square root of 0.001 to an epsilon of 123.
1698.1599999999999,4.960000000000036," Okay, because it's just mapping the parameters one at a time. And so that's not an error,"
1703.12,5.039999999999964, but it's not exactly what we wanted to do. Questions about this.
1712.1599999999999,0.3200000000001637, Okay.
1713.2,8.240000000000009," So now, let's move on to another thing, another sort of nuance about functions."
1723.1200000000001,4.1599999999998545, And we're going to go back to the idea of functions being objects in Python.
1728.72,7.119999999999891," So I drew this picture back when we first learned of objects, of functions as objects."
1735.84,4.880000000000109, So I'll just do it again just to jog your memory. So remember that when we make a function
1740.72,9.759999999999991," definition inside the memory, Python creates an object, right? As soon as we see just this function"
1750.48,6.480000000000018," definition, Python doesn't care what code is inside here. This code does not run, right? It only"
1756.96,4.0," runs when it's being called. And right here, I have not made a function call at all."
1761.84,4.560000000000173, All Python knows at this point is that there's a function object inside memory.
1766.5600000000002,9.3599999999999," And it's the name, its name is is even. And this is exactly the same as creating an integer"
1775.92,5.599999999999909," object inside memory and giving it the name R through a line like this, or creating a float"
1781.52,4.800000000000182," object in memory and giving it the name Pi, right? It's just some object with some name."
1787.6000000000001,7.3599999999999," And so that means that we can have some code that looks like this, which is going to essentially"
1795.04,8.6400000000001, create an alias for that function object in memory. Okay? So here the name is even refers to that
1803.68,6.720000000000027, function object. And I'm telling Python that I would like to refer to that function object using
1810.4,7.759999999999991, the name MyFunk as well. So both MyFunk and is even are names that point to this object in memory.
1819.1200000000001,5.759999999999991," It's not a function call, right? I'm not trying to figure out if some number is even. I am"
1824.88,6.480000000000018," literally giving another name to this function, this code, right? That does this thing here."
1833.44,6.720000000000027," Okay. And so that means that if I have two names that point to the same object, if I am going to"
1840.16,7.3599999999999," invoke those two names, as I do here, with some parameters, Python is going to say, well,"
1847.52,5.3599999999999, I'm going to run the code pointed to by these names with these parameters. So they will both
1853.52,5.440000000000055," run the code that they're pointing to, right? This is even. And so it's just going to return"
1858.96,8.399999999999864," true or false. We've seen the two. Okay. So remember, just another name for that object in memory."
1868.56,5.039999999999964, So we've seen already how we can pass functions as parameters to other functions.
1874.48,7.039999999999964, And now we're going to see what happens when we return a function from another function.
1881.52,6.240000000000009," So we're not returning a function call here, right? We are returning a function object."
1888.8799999999999,5.680000000000064," So in this particular code, we have only one function. It's named MakeProd."
1896.08,5.119999999999891, And it happens to have some stuff going on inside it. So what's the stuff that this function will
1901.2,8.6400000000001," do? Well, this function itself will create another function. So this G only exists whenever MakeProd"
1909.8400000000001,7.519999999999982," exists. The main program, at, you can think of it as sort of this level of the code, right, in"
1917.3600000000001,8.0, terms of indentation. The main program does not know about G. G is only defined inside MakeProd.
1925.3600000000001,4.1599999999998545," Right? So when we first run this program as is, there's no function call being done. So the main"
1929.52,7.039999999999964, program does not know anything about the internals of MakeProd. Okay. So MakeProd creates its own
1936.56,6.720000000000027, function here. And then all it does is return this function object. Right? Notice it's not a
1943.28,5.920000000000073, function call. There's no open-close parentheses with a parameter in it. It's just the name G. It's
1949.2,10.079999999999927, this function object. That's the key thing here. So let's run two codes. This one and this one.
1959.28,8.559999999999945, They will do the exact same thing. They're going to call MakeProd with some parameters. And then
1967.84,5.920000000000073, we're going to see what happens when we return this G. And notice already it's looking slightly
1973.76,5.839999999999918," different than what we've been doing before. Yes, we have a call to MakeProd here, but we've kind"
1979.6,6.720000000000027, of chained another function call right after MakeProd. Right? We've got MakeProd parentheses
1986.32,5.920000000000073," two parentheses three. And so this is kind of like, I think of it as chaining a bunch of function calls"
1992.24,6.1599999999998545," together. And this is possible, as we're going to see when we step through the function environments"
1998.3999999999999,6.880000000000109," that are being created. This is made possible because MakeProd, this function call, returns a function"
2005.28,8.720000000000027, itself. Okay. So let's step through the code on the left very carefully. And then I'll step
2014.0,4.880000000000109," through the code on the right, which will do the exact same thing. And hopefully it will clear"
2018.88,6.879999999999882, up confusions if we do it twice. So this is the code from the left. Let's say we have this exact
2026.32,7.279999999999973, program here. I've got one function definition. And then I've got one function call here. And then
2033.6,7.440000000000055, I'm going to print the return value. So as soon as I run my code Python creates my global environment.
2041.04,6.6400000000001," And in the global environment, this is the scope of, you know, the main program. What do we have?"
2047.68,5.519999999999754," Well, we have one function definition, which has some code within it. I don't care what it is at"
2053.2,8.16000000000031, this point because I don't have a function call. So then the next thing that I need to do is go down
2061.36,6.879999999999654, here and say val equals. So I'm going to create a variable val in my global environment. And I'm
2068.24,5.679999999999836," going to make a function call. So function calls are done left to right, right? Just like expressions."
2074.4799999999996,4.5600000000004, And the first thing Python sees is this function call make prod parentheses to.
2081.2799999999997,6.2400000000002365, It's a function call. So we need to create another orange box because a new environment gets created
2087.52,7.7599999999997635," every time we create, we make a function call. So here I have my scope, my environment for make"
2095.28,5.8400000000001455, prod. And I'm currently just stuck here trying to figure out what this is going to return.
2101.1200000000003,5.279999999999745," And just the red box here. Well, every time I have a function call, I need to look at the function"
2106.4,6.640000000000327," definition. And the function definition says, well, there's one formal parameter A that I need a map"
2113.0400000000004,6.479999999999563," to the actual parameter. So the thing I'm calling make prod with is two. It should be pretty straightforward,"
2119.52,10.960000000000036," right? And then I can move on to do the body of make prod. Okay. So the body of make prod says,"
2131.68,5.519999999999982, I would like to create a function definition. The name of this function is G. So there's G.
2138.0,4.480000000000018," And it contains some code. Again, I don't care what this code is because I'm not making a"
2142.48,9.760000000000218," function call to G yet. Right? Right now I'm just defining G. Okay. So far so good. So this G,"
2152.88,10.159999999999854," I want you to notice, only exists inside this call to make prod. The global environment does not"
2163.04,8.720000000000255," know about G at this point, right? Because we only define G inside make prod. It's here, right? I"
2171.76,5.440000000000055," didn't define it outside of make prod. So the global scope doesn't know about it, but make prod does"
2177.2000000000003,8.7199999999998, know about it. Okay. And so the only way that the global environment can know about G is if this make
2185.92,11.840000000000146," prod function somehow returns G. Okay. So if we pass G back as a parameter, as a value, sorry,"
2197.76,6.400000000000091," to the main program scope, the main program can know about G. But otherwise, G is kind of stuck in"
2204.1600000000003,5.199999999999818," this little, you know, little subtask little environment of make prod. And the main program doesn't"
2209.36,6.480000000000018," know about it. And so that's what this code is doing. It's essentially saying, well, I've made"
2215.84,8.559999999999945," my definition. And now I return G. So here, this G, the code, and it's code, and the associated code,"
2224.4,7.440000000000055, right? So this object pointed to by G is going to be returned back to the main program.
2232.7200000000003,7.119999999999891," Okay. So now the main program knows about this object, G, that has some code associated with it,"
2239.84,9.039999999999964, right? This line here where it returns a star B. So the thing that I've boxed and read down here
2249.6,10.5600000000004, is the return value from make prod two and make prod two return G. So this you can essentially say is G.
2263.6,6.0," Is that okay? Does that make sense? We're passing functions along, right? Not function calls. And so"
2269.6,8.720000000000255," this is just a function named G. And so now this line of code, val equals, if we replace the red"
2278.32,12.800000000000182," box with G, val equals G parentheses three. So G parentheses three is another function call, right?"
2291.1200000000003,4.7199999999998," Just clearly we look at it. It's a function call. It's got a function name, parentheses, and a"
2295.84,5.760000000000218," parameter. And so since it's a function call, we create another scope for this function call."
2302.56,6.960000000000036," As before, we look at what G takes in as a parameter. It's about a variable named B, right?"
2309.52,7.039999999999964," The formal parameter B. And we map it to three. Because that's our function called G, parentheses three."
2318.96,8.0," And then we have to do the body of G. The body of G says return A multiplied by B. Well, I know"
2326.96,6.320000000000164," what B is. It's three because you just called me with that value. But what is A, right? The scope"
2333.28,8.559999999999945," of G has no A within it. So thinking back to our function, our lecture on functions, if a function"
2341.84,6.1599999999998545," call doesn't know about a variable name within its environment, within its scope, it moves up,"
2348.0,6.880000000000109," sort of the function call hierarchy. So it says who called me, right? Where was G defined?"
2355.84,7.119999999999891," Well, G was defined inside make prod. And so it was called from make prod. Does make prod have a"
2362.96,7.2800000000002," variable named A? It does, right? And its value was two. So we didn't need to go any further up the"
2370.2400000000002,6.1599999999998545, hierarchy. We've already found a variable named A. So Python will use B as three and A as two.
2376.88,9.840000000000146, Okay? Multiplies that to B6. And then the G function call can return six. It returns it back
2386.7200000000003,4.079999999999927," to the main program because that's where this function call was being done, right? Remember,"
2390.8,6.960000000000036," we had this replace with G, parentheses three out in this global scope here. And so that six gets"
2397.76,11.679999999999836, returned back to the main program and then Val becomes six. And we print six. Okay. So that was
2409.44,7.360000000000127, showing you how to chain function calls together. And this was only made possible because make prod
2417.36,6.2400000000002365," has a function, returned another function object. If make prod returned, I don't know, a"
2423.6,6.639999999999873," tuple or an integer or something that was not a function, this code would fail because the return"
2430.24,5.920000000000073," from make prod would be, let's say it returned the number 10. The return from make prod would be"
2436.16,5.2800000000002, replaced with 10. And then Python would see this line as 10 parentheses three. What the heck is that?
2443.6,5.039999999999964, And so it would completely fail. And so this is only made possible by the fact that this make prod
2448.64,5.360000000000127, function returns a function object. And so we're able to chain these function calls together.
2457.04,4.799999999999727," So let's look at the exact same code except this time instead of chaining them in a row,"
2462.8799999999997,8.320000000000164, let's explicitly save the intermediate steps. Okay. So what I'm going to do is say make prod
2471.2,10.0," parentheses two. I'm going to save as a variable. And then make that variable call the three,"
2481.2,5.519999999999982," right, the second part of my chain from the previous line. And it's going to do the exact same thing."
2487.8399999999997,7.360000000000127, So here I've got the global scope just like before. I've got a function definition for make prod. So
2495.2,5.360000000000127, this is the name make prod it can it's points to some code. And then I've got this variable
2500.56,6.960000000000036, double or that's going to equal something. So it's a function call. The function call says here's
2507.52,7.199999999999818," my environment for make prod with its scope. So in this particular scope, I've got my formal"
2514.72,7.519999999999982, parameter a that maps to two. And then the function body itself creates this variable G. That's
2522.24,9.360000000000127, just some code exactly the same as before. Any questions so far based on what happened last in
2531.6,11.039999999999964," the last sort of example and here, or is this okay so far? Okay. So now I've set up my my code and"
2542.64,6.480000000000018, this is where the interesting part comes in right make prod is going to finish its call by saying
2549.12,8.480000000000018, I'm going to return something and the thing it returns is G. So it returns this name G just
2557.6,5.440000000000055, happens to have it happens to be a function object but think of it as anything else. We're basically
2563.04,5.8400000000001455, saying double or equals 10 or double or equals some list or some tuple. Double is going to be some
2568.88,8.639999999999873," some value right. This value is just code associated with a function. So in my main program scope,"
2577.52,5.360000000000127, I've got doubler equals G which based on the memory diagram we did like five or ten slides ago
2582.88,6.559999999999945, right. It's like when we had my funk equals is even. I basically have two names for the same
2589.44,8.559999999999945, function object right. Doubler is a name and G is the other name and they both point to this
2598.08,12.400000000000091, function object. Does that make sense? That's okay. Okay. So now that I've got two names that point
2610.48,9.039999999999964," to the same function object, we can just use this doubler in the next line and this doubler is like"
2619.52,9.2800000000002, saying G parenthesis three. Okay. Except that I'm using the name doubler which I saved it as on
2628.8,7.7599999999997635, the previous line. So G parenthesis three is another function call. Create another environment for
2637.68,6.079999999999927, for G or doubler or whatever name. And here I've got one formal parameter B.
2643.76,6.079999999999927, It's values three and then we do the same trick where you ask what is the value of A. I'm going
2649.84,7.440000000000055, to look up the hierarchy of things that got called to see what the first value of A that I grab.
2657.28,5.360000000000127, And the first value of A that we grab is the two right. And so we're going to multiply the two
2662.6400000000003,5.599999999999909, with the three and that six gets returned back to whoever called it which was out here in the main
2668.24,15.440000000000055, program scope. And so this val will be equal to six. And that's it. Questions. Which one was
2683.68,4.960000000000036, easier to understand? This one or the one where we did the chaining? Just show of hands. Who liked
2688.64,7.440000000000055," this one more? Who liked the chaining more? Oh, interesting. Okay. Was the chaining just easier to"
2696.08,4.880000000000109," grasp? Because there were less names. Okay, cool. I'm glad I showed it first then."
2704.0,2.0, Any questions though? Yeah.
2711.52,6.400000000000091," No reason. In fact, you would want to do the chaining way because then you avoid extra lines of code."
2717.92,4.960000000000036," And again, with practice, it just becomes really easy to know what's going on. Yeah."
2726.3199999999997,11.600000000000364, Okay. So that might have been confusing. Why do we bother doing that? Because that particular
2737.92,8.639999999999873," example, all we were doing is multiplying to, I guess, doubling a number. Okay. We could have"
2746.56,9.2800000000002," easily written that code to, you know, to double a number and without actually returning a function."
2755.84,6.879999999999654," That seemed way overkill for what that code was trying to do. Well, it was kind of showing you"
2762.72,6.800000000000182," what you can do with an easy example. And you would definitely never, ever write, you know, functions"
2769.52,10.480000000000018, returning other functions for such simple examples. But it's really a method for cases where you
2780.0,7.2800000000002," have larger pieces of code that you'd like to write. Because if you're trying to, so if you're"
2787.28,5.839999999999691," writing a larger piece of code, right, some software project, and every single function you'd ever"
2793.12,6.0, want to use is kind of defined at the top level in the main program. It would become really messy.
2800.24,5.440000000000055, And so there are cases where you would like some functions to only be visible or accessible
2805.68,6.1599999999998545, by other functions. And so you'd only define those functions within the scope of other functions.
2811.8399999999997,8.88000000000011, That's one thing. The other thing is using this sort of chaining method allows you to have some
2820.72,7.920000000000073, control over the flow of control of a program. And so you can imagine in the example here where
2830.7999999999997,6.880000000000109," you basically create this, you have this line here. And at some point you return g, right?"
2838.48,5.199999999999818," And you don't want to do the doubling right away, right? So you don't want to do val equals"
2843.68,5.519999999999982, double or right away. You can imagine having a bunch more lines of code here that do other stuff
2849.2,7.8400000000001455," before you actually do the doubling, right? And so in that case, in this larger, more complex"
2857.04,5.039999999999964," program, you're essentially interrupting the flow of control here. You're not doing the doubling"
2862.08,5.440000000000055," right away, but you did grab this function back. And then you can maybe do other things with that"
2867.52,8.319999999999709," function before finally doing the doubling. And so in that case, you can basically execute some"
2875.84,6.639999999999873," code partially, do some other operations, and then finish executing at the end after you've"
2882.48,6.0," done these operations. So again, for this example, it doesn't make much sense, but in a larger"
2888.48,7.360000000000127," piece of code, this idea of functions, returning functions is just another tool to achieve these"
2895.84,5.760000000000218," ideas of decomposition abstraction, which lead you to write more organized code, more robust code,"
2901.6,6.480000000000018," more easy to read code, and so on and so on. So you don't have to do this, but you do have to"
2908.08,6.880000000000109, understand what it means for a function to return another function. Any other questions?
2917.44,7.279999999999745, Okay. So now we're going to do the last piece of today's lecture ideas of testing and debugging.
2925.68,9.759999999999764," This lecture is usually pretty dry, so I'm going to try to make it more fun as fun as I can."
2936.72,7.2800000000002," The reason why we introduced this lecture now is because I'm hoping that by this point in the course,"
2944.0,5.679999999999836," you've had a chance to do some testing and debugging strategies on your own, by kind of a trial"
2949.68,6.239999999999782," and error thing on quizzes and on p-sets. So you've gotten a chance to maybe use the Python tutor,"
2955.9199999999996,5.760000000000218," you've got a chance to use print statements, various things like that, and see what works best for"
2961.68,4.960000000000036," you, what doesn't work at all, and things like that. So you've maybe gotten a little bit burned by"
2966.64,5.679999999999836," some of these strategies, but I hope that by you being burned by some things that you've tried,"
2972.3199999999997,4.2400000000002365," that worked, that didn't work, you'll maybe appreciate this lecture a little bit more than if I just"
2976.56,7.119999999999891," showed you this lecture back on day one or day two or something like that, because it's a lot"
2983.68,6.400000000000091," of common sense stuff, but there's a little bit of actual strategy as well in this particular"
2990.72,6.160000000000309," set of slides. So your programming experience so far, I know this is certainly mine, as I hope that"
2996.88,6.639999999999873," when I run my code, it immediately runs perfectly. But instead, what is happening for me is I run my"
3003.52,5.760000000000218, code and it immediately crashes. I've got my red errors on the side and I get a little bit flustered.
3010.24,6.400000000000091, So this is exactly what happens probably for you too. And the idea here is that you want to
3016.64,7.440000000000055," write the code in such a way that it makes it easy to test and debug. And I know I always say this,"
3024.08,6.480000000000018," and I actually don't always practice it, but it's important to write the code by writing it with"
3030.72,7.680000000000291," by adding comments as you're writing the code. So writing specifications, writing comments for"
3038.4,5.440000000000055," yourself as you're actually writing the code, not when you finished it is very important. It helps you"
3043.84,3.119999999999891, as you're writing it or coming when you're coming back to it in a couple days.
3048.32,5.039999999999964, Modularizing the programs also helps. So if you see a chunk of code that you're copying and
3053.36,5.919999999999618," pasting all over the place, you'll want to plop it out in a little function that you call multiple"
3059.28,8.320000000000164, places. So ideas like that kind of employ the defensive programming mechanism. And it allows you to
3068.8,7.199999999999818," perform really easy testing and validation when it comes time to do that, and then possibly debugging"
3076.0,5.519999999999982, when it comes time to do that. So the lecture is going to be divided into two pieces. The first we're
3081.52,5.440000000000055," going to talk about testing and validation, some nice testing strategies, and then we're going to"
3086.96,7.039999999999964, talk about some strategies for debugging as well. So the testing and validation part is where you come
3094.0,7.8400000000001455, up with a set of input test cases and expected outputs. And all you're doing is running your code to
3101.84,4.960000000000036, make sure that the expected output matches the output that you actually get from running the code.
3108.2400000000002,6.799999999999727, The debugging part is where one of your tests don't match the expected output.
3116.0,4.559999999999945," One of the outputs that you get don't match the expected output. And at that point, you have to figure"
3120.56,7.599999999999909," out why the code is not working. Obviously. So before you even test your code, as I mentioned before,"
3128.16,7.760000000000218," you have to set yourself up to do the testing and debugging. So to ease this part, it's important to"
3135.92,4.319999999999709," write documentation very well. So when you're writing your own function, not functions that we've"
3140.24,4.880000000000109," given you, document the doc string. What are the inputs you expect? What should the function do?"
3145.12,5.279999999999745, What should the function return? Things like that. If you're writing the code in a sort of a strange
3150.3999999999996,5.440000000000055," way, or if you use some piece from Stack Overflow or something like that, document it to make sure"
3155.8399999999997,4.400000000000091," that if you're looking at it a week from now, you still remember what that piece of code did. So"
3160.24,4.400000000000091," really, really simple things like that can make a really big difference when it comes time to test"
3164.64,7.119999999999891," and debug. Breaking up the code, obviously, into smaller chunks is very important. Because if you're"
3171.7599999999998,5.920000000000073," copying and pasting the same piece of code over and over again, you remember to make a change in one"
3177.68,5.599999999999909, place. You might forget to make that same changes in all these different places. And so that will be
3183.2799999999997,7.920000000000073, very frustrating when it comes time to actually run and debug the code. So once you have code that's
3191.2,8.7199999999998," written, you would start the testing process. You remove all the errors, static semantic errors and"
3199.9199999999996,4.480000000000018," syntax errors are really easy to remove. Python immediately tells you, right, index error on this"
3204.3999999999996,6.720000000000255, line or syntax error on this line. Those are really easy to figure out. Using a paper and pen or
3211.12,9.360000000000127," typing it out on your Python file, you come up with a bunch of test cases. And for each one of"
3220.48,7.599999999999909," those test cases, the way we write on your micro quiz test cases, you say what you expect the"
3228.08,4.720000000000255," output to be. So when you actually run it, you don't need to remember what this output should be."
3232.8,8.639999999999873, It's just written down somewhere on paper or on the screen. So when you're creating a bunch of
3241.44,6.480000000000018," test cases, you can create some different classes of tests. So hopefully, we're modularizing our"
3247.92,5.760000000000218," programs, which means that we're creating functions. The simplest classes of tests are called unit"
3253.6800000000003,9.4399999999996, tests. And these tests basically test a function with different inputs. Okay. So what you're going to do
3263.12,6.720000000000255, is come up with a bunch of different test cases for one particular function and run these test
3269.92,8.159999999999854," cases on the function. If they all work perfect, but if they don't or if you find a bug as you're writing"
3278.08,6.2400000000002365," test cases in the code, you want to perform regression testing. And regression testing means that as"
3284.32,8.320000000000164," you find a bug, you add a new test case for them. Or as you fix a bug, you run the code, you run"
3292.6400000000003,6.239999999999782, the same code with all of the previous test cases to make sure that the bug you fixed didn't introduce
3298.88,5.599999999999909, errors in a previous test case. Okay. So you there's a bunch of iterations of unit testing and
3304.48,5.2800000000002," regression testing to test all of these different modules, all the functions in your program. And at"
3309.76,5.359999999999673," some point, you're ready to do integration testing. And in integration testing, you've got all these"
3315.12,4.480000000000018," modules, for example, as you did in Hangman, you've got all these little functions that do"
3319.6,5.920000000000073," individual things. You put them all together into a larger program. In Hangman, it was a bunch of"
3325.52,4.1599999999998545, big while loop where you check all these different things that the user might input and then you
3329.68,7.039999999999964," call the different functions you wrote. And as you find errors in the integration, when you've"
3336.72,6.400000000000091," written code that integrated all these different pieces together, you might have to go back and do"
3343.12,7.119999999999891," more unit tests for some of the functions that you wrote. Okay. So you've done unit testing,"
3350.24,5.440000000000055," regression testing, and integration testing. What are some actual testing approaches? How do you"
3355.68,7.679999999999836, actually create these test cases to run your code with? So I guess the most natural way to write a
3363.3599999999997,7.039999999999964," test case is just intuition about the problem. So given a dog string, what are going to be some"
3370.3999999999996,4.640000000000327," natural boundaries, some natural values of x and y for which you test this code with? You guys"
3375.04,9.840000000000146, tell me. What's some values that we could test this code with? Think about the boundaries to the
3384.88,11.759999999999764, question. Right. Yeah. Three and four is good. So x is less than y is a good one. Vice versa.
3396.64,6.079999999999927, Right. Four and three is another one where y is greater less than x. We could test them being
3402.72,5.039999999999964," equal, right? What about zero and zero? What about a thousand and a thousand? So we could do extremes,"
3407.7599999999998,5.920000000000073, we could do bigger than less than we could do equal things like that. So mathematical functions are
3413.68,5.119999999999891, kind of easy to apply this idea to because they just have natural boundaries. But often there are
3418.7999999999997,5.440000000000055, functions which don't have these natural boundaries and then we might be stuck doing random testing.
3424.24,5.199999999999818," And in random testing, obviously the more test cases you have, the better chance you have of finding a"
3429.44,6.639999999999873, bug. But there are actual techniques for coming up with test cases. So the first one is called
3436.08,8.079999999999927," black box testing. Second is called glass box testing. Now in black box testing, you're going to treat"
3444.16,7.040000000000418, the code of the function as a black box. So we don't even look at what the code is doing. All we're
3451.2000000000003,6.959999999999582," looking at to guide writing our test cases is the specification, the dog string. Right. And so"
3458.16,4.880000000000109, hopefully the person who wrote this function wrote a really nice dog string because that's what
3463.04,6.7199999999998, we're going to use to write our test cases. So the way that we're going to write a test case for
3469.7599999999998,8.480000000000018, the square root function is by saying what is the value of x and epsilon according to these constraints
3478.24,5.039999999999964, here. Right. So obviously we're not going to test the code with values that don't match those
3483.2799999999997,4.720000000000255, constraints because the person who wrote this function doesn't guarantee that this function will work.
3488.0,7.519999999999982, For those out of you know those those weird values. So the good thing about black box testing is
3495.52,5.519999999999982," if we're the ones testing this function, we're only using the specification to write the test cases."
3501.04,5.519999999999982," So if for example this person implemented square root using approximation method, I don't care."
3507.2,5.920000000000073, My test cases will work if the person changes their implementation to use the bisection method.
3513.12,5.8400000000001455, Right. My set of test cases will still work even if the person who wrote this function change the
3519.92,6.559999999999945," the black box, right. The implementation. So it's black box testing is is is really nice in that"
3526.48,5.7599999999997635, respect. And so for this particular function here's a bunch of test cases that I would run it with.
3532.24,5.760000000000218, Right. So obviously x being a zero perfect square less than one are are are kind of you know nice
3538.08,6.960000000000036, ones to test irrational values and then a bunch of extremes is also good to test. And then epsilon
3545.04,6.639999999999873, the same we've got some reasonable values of epsilon and then some extremes and we can even you know
3551.68,5.600000000000364, mix and match we can have zero and extremes epsilon and perfect squares and extremes epsilon and
3557.28,5.519999999999982, things like that. So lots more test cases than this but this is a really good start.
3563.76,6.320000000000164, In glass box testing we're going to use the code itself to guide the test cases that we write.
3570.7200000000003,6.480000000000018, So if we write something test a test suite that's path complete that means that we're going to
3577.2000000000003,6.1599999999998545, hit every single path inside the program. So that means we have to look at the code to guide the
3583.36,4.720000000000255, test cases that we're writing which means that we're going to have to write a test case for
3588.56,4.7199999999998, the code hitting the if part of a branch we have to write a test case for the code hitting the
3593.2799999999997,4.480000000000018, else part of a branch or the L if part of the branch if we have a for loop we need to write a
3597.7599999999998,3.7600000000002183, test case where the code doesn't go through the loop at all it goes through once or goes through
3601.52,4.7199999999998, many times through the loop right same with while loops we write a test case so that the code
3606.24,4.559999999999945, doesn't go through the while loop at all it matches the condition once or matches the condition
3610.7999999999997,5.8400000000001455, many times. So you can imagine that this glass box testing leads to a whole lot more test cases
3616.7999999999997,5.2800000000002, especially when we have a whole bunch of different combinations of all of these conditionals
3622.08,6.0, and loops and things that we'd like to hit. The problem with glass box testing and having a complete
3629.44,6.319999999999709, path complete test suite is that we might accidentally miss a bug. So here's an example of a code
3635.7599999999998,6.400000000000091, that's not correct so it finds absolute value of x. If x is less than negative 1 we return negative
3642.16,7.599999999999909, x else we return x. So a path complete test suite could be testing 2 and negative 2. The 2
3650.96,6.239999999999782, brings us through the else so we return 2 and the negative 2 brings us through the if so we return 2.
3659.3599999999997,6.400000000000091, We might say this code works but it doesn't right we already can tell that negative 1 is returned
3665.76,8.239999999999782, incorrectly as negative 1. And so in addition to testing all the paths through the code we'll also
3674.0,5.200000000000273, want to look at boundary condition especially for conditionals when we do a glass box testing.
3681.28,5.360000000000127, Okay so we have a whole bunch of test cases we've run our code with all these test cases and then
3686.6400000000003,6.559999999999945, at some point we've gotten an output from a test case that does not match what we expected to do.
3693.9199999999996,6.080000000000382, Then we have to do the debugging process. Okay and this is where this is where
3703.4399999999996,6.160000000000309, a little creativity is required. There is no recipe like there was in glass box testing and
3709.6,6.319999999999709, black box testing for writing test cases. There is no similar sort of you know recipe for debugging
3715.9199999999996,6.0, a program. There is a lot of experience that's needed right a lot of times that you've seen a bug
3721.92,5.360000000000127, crop up in order to figure out sort of what the problem might be and so a lot of experience
3727.28,7.7599999999997635, writing code is very useful in the debugging process. There are tools to help you do the debugging
3735.04,4.800000000000182, process but there aren't many tools to actually do the debugging you kind of just have to do it.
3739.84,7.279999999999745, So there's tools built into anaconda they're not very good I've used them. Python tutor obviously
3747.12,5.039999999999964, is a really good one especially for small programs because you get to just go step by step and see
3752.16,6.639999999999873, the values of each variable as the code is running. I so I like that a lot. Print statements are
3758.7999999999997,5.200000000000273, also really good but you have to know where to put them right and you have to use them effectively.
3765.2,4.639999999999873, So in that sense you know if you're not as familiar with print statements Python tutor might be a
3769.8399999999997,5.360000000000127, better suited for debugging but no matter what it's important to be systematic. Don't just start
3775.2,5.8400000000001455, changing random variables or random conditions and then run the code through the tester again.
3781.04,6.079999999999927, That's not going to work very well. When we see error messages in the debugging process these
3787.12,6.799999999999727, are really easy to figure out right index error. Oh shoot I got to check my indices. Maybe I went
3793.9199999999996,5.760000000000218, over. If you see an index error you should probably print out the variable that you're indexing
3800.64,8.400000000000091, into or indexing with type errors. Oh man look I'm casting a list to an integer. What is that
3809.04,5.119999999999891, going to do? Nothing it's going to give us an error or here I'm dividing a string by an integer.
3814.16,6.079999999999927, Again something really simple to fix. Name errors of course here's I have a here I have a variable
3820.24,6.559999999999945, that I've never initialized and then syntax errors basically mean things like your indentations off
3826.8,7.199999999999818, or you're missing a parentheses or something like that. Logic errors are a lot harder okay these
3834.0,7.519999999999982, ones you cannot just look at the line and say this is where the problem is. These ones happen when
3841.52,7.600000000000364, your output is does not match the expected output and this is where kind of engaging another part
3849.1200000000003,5.279999999999745, of your brain is very important. I've definitely done this a lot I've had some errors I went for a walk
3854.4,6.320000000000164, come back and I figured out I figured out in the shower or I figured out in bed right. So thinking
3861.44,4.880000000000109, a little bit before you even start the problem is good for this for these logic errors.
3866.32,4.880000000000109, Drawing a picture is taking a break talking to friends all these are really good explaining the
3871.2000000000003,4.960000000000036, code to something else somebody else is also a really nice thing to do. That's me explaining the
3876.1600000000003,5.839999999999691, code for something we're going to do in a couple minutes to my son he's seven now and he's doing
3882.0,4.079999999999927, scratch so that's pretty cool but he was helping me debug and now I'm helping him debug.
3887.44,6.559999999999945, Yeah or you can explain code to some inanimate object like a rubber duckie. Now having said that
3894.88,10.079999999999927, you guys came on a good day because you will all get to have your own rubber duck
3905.12,7.760000000000218, different kinds grab your personality duck that matches your personality after class I've got
3912.88,7.920000000000073, Minecraft ducks giraffe ducks princess ducks police ducks elephant ducks whatever ducks you'd like
3920.8,7.920000000000073, come grab one use it for your quizzes use it for your pea sets whatever you'd like to use it for
3929.68,9.599999999999909, go for it okay so hopefully it comes in handy use it well all right so we're not quite done yet
3939.2799999999997,11.760000000000218, though okay so I will give you a little bit of debugging tips though so I know it's I said it's a
3951.04,6.239999999999782, creative process I said it's really hard to come up with a recipe to do the actual debugging
3957.28,7.679999999999836, but there are there there is maybe one way one really nice way to do it so the idea behind
3964.96,5.440000000000055, debugging is basically use the scientific method like I said don't just randomly change things
3970.4,5.680000000000291, expecting for it to work out what you want to do is look at a bunch of test cases that failed
3976.0800000000004,4.879999999999654, it's possible that they're all they all have something in common and that might lead you to a small
3980.96,5.440000000000055, piece of code in your program that is the one that you should be focusing on changing right so you
3986.4,6.0, want to look at the data for my hypothesis and try to see if another test case also fails that
3992.4,7.2800000000002, particular one as you're as you're doing the debugging method right if you really have no idea
3999.6800000000003,7.4399999999996, about where to start try putting print statements at reasonable places in the code so when you first
4007.12,5.600000000000364, enter functions when you first enter a loop right all the values of the loop variable and all
4012.72,4.639999999999873, the variables that you're creating in the loop or modifying in loop and things like that and if
4017.3599999999997,6.400000000000091, all else fails using the bisection method is a really nice way to try to solve the problem so
4023.7599999999998,5.360000000000127, bisection method in debugging basically says put a print statement about halfway in the code
4030.16,5.119999999999891, if everything looks right for all the variables at that point you know the problem is after this
4035.2799999999997,4.639999999999873, if something is wrong you know the problem is in the first half of the code then put a print
4039.92,6.1599999999998545, statement in the quarter of the code right and then at that point see if the values all the values
4046.08,5.600000000000364, at that point match what you expect them to be if do great you know the problems in the second
4052.4,4.800000000000182, quarter I guess yes the second quarter and if they don't you know the problem is in the first
4057.2000000000003,7.279999999999745, quarter okay so the bisection method is is a nice way to try to debug the code so what we're
4064.48,3.9200000000000728, going to do in the last bit of lecture is we're going to debug some code together that's in the
4068.4,8.800000000000182, Python file and then what I have is included in today's zip file is actually a wordal game that I
4077.2000000000003,7.039999999999964, wrote it's like 12 underscore world dot pie or whatever and it's buggy so I'm I introduce some bugs
4084.2400000000002,6.639999999999873, in it and I would if you'd like to practice debugging you can try to fix the wordal game to get
4090.88,4.639999999999873, it to work and then you can play yourself or you can amaze your friends and get them to play your
4095.52,8.240000000000236, game in case you'd like to do something like that okay so before we end I would like to actually
4103.76,7.760000000000218, do some debugging with you just to show you the the bisection method for debugging so the code
4111.52,7.919999999999163, we're going to debug is this one right here and I've already included sort of the the fixed code
4119.44,9.4399999999996, step by step but we're going to talk through it together so this function is buggy it's a
4128.879999999999,9.360000000000582, function called is pal that takes in a list x and it's supposed to return true if the list elements
4138.24,10.960000000000036, are a palindrome and false otherwise okay so using the input a b c b a cast as a list so you know
4149.2,6.0, the input is going to be the string a string b string c string b string a this list is a
4155.2,6.5600000000004, palindrome right because it's the same forwards as it is backwards so if I run it it should print
4161.76,6.960000000000036, true okay so that test case worked well but now what about the second test case surprise it's not
4168.72,6.319999999999709, going to work if I pass in the list a b right so my input is going to be the string a in the string
4175.5199999999995,7.360000000000582, this is not a palindrome right so I expect it to print false but it prints true so I have a nice
4182.88,7.039999999999964, test case here that I can I can make fixes with and see whether it actually gets fixed now of course
4189.92,6.960000000000036, a b c d f g h i j k l m this also doesn't work right so this is another test case that's not going
4196.88,5.199999999999818, to work but I don't want to use this long one as my test case I want to use the simplest test
4202.08,4.800000000000182, case I can find that doesn't work right so a b seems like a really nice one to test with
4208.08,5.680000000000291, okay so now the first thing we want to do that one that we figured out the input I'd like to test
4213.76,6.079999999999927, with is put a print statement about halfway through the code yes there's only like five lines of
4219.84,6.399999999999636, code here so there's only probably one place that makes sense to put a print statement but let's
4226.24,7.359999999999673, just work with me here so the print statement could be put right here right before the if statement
4233.599999999999,4.720000000000255, right so I've got two lines of code that do something and then an if so let's just put it right
4238.32,7.920000000000073, before the if scroll down step two here I go I've put my print statement right before the if
4249.84,4.639999999999418, now we can run the code again so I'm not going to run the one that worked let me try to run the
4254.48,5.600000000000364, one that didn't work to figure out what the problem is so I run this the print statement is
4260.08,9.359999999999673, printing the temp so the reverse of x and x so what I'm expecting in and I should have probably
4269.44,5.760000000000218, written this over here what I've what I'm expecting to get what I'm expecting is to see the
4275.2,9.4399999999996, reverse of a b so ba and then the original x a b but I don't so I see a b and a b this first one
4284.639999999999,8.0, should be ba so already I have something that's unexpected and so I know the problem is going to
4292.639999999999,7.520000000000437, be in these first two lines of code right somewhere in here all right so then what I would like to do
4300.16,5.039999999999964, is figure out which one of these lines of code is the problem so I'm going to put another print
4305.2,5.119999999999891, statement a quarter of the way through the code okay well there's only one more place to put it
4310.32,6.480000000000473, so let's put it in here I've got another print statement right before the reverse so what I'm
4316.8,6.719999999999345, going to be checking is before the reverse the value of my temp variable and my original variable
4324.160000000001,8.0, and after the reverse the value of my reverse variable and the original variable so what I'm
4332.160000000001,8.88000000000011, expecting to see is this one here they should be the same a b a b but this one here I'm expecting
4341.040000000001,10.239999999999782, to see ba a b so run it with this buggy example so before the reverse I'm expecting a b and a b
4351.84,7.119999999999891, and I do get that so that's good I'm happy to see that and then after the reverse that's by problem
4358.96,8.399999999999636, right I'm expecting this one to be reversed but it's not so now I know the problem lies here
4367.36,6.0, temp dot reverse because here in this print statement here temp and x were as expected so what do you
4373.36,6.800000000000182, think the fix should be to the reverse yeah yeah exactly we need to add parentheses this is a function
4380.16,9.039999999999964, we need to call it like a function right so let's do that fix we've done it here so here I've
4389.2,8.480000000000473, added the parentheses to the reverse and run it again so now what I'm expecting is before the
4397.68,6.399999999999636, reverse I need to see a b a b so this one should be the same we shouldn't change because I didn't
4404.08,6.880000000000109, do anything to that temp equals x and after the reverse I'm expecting the temp to be ba and the
4410.96,6.720000000000255, x to be a b unchanged all right let's run it so before the reverse everything looks okay temp and
4417.68,7.279999999999745, x are the same after the reverse look at that I've got my ba as my reversed variable I'm happy
4425.44,14.160000000000764, but then my x has also changed I'm sad yes exactly there's a clue the right we see a clue we've
4439.6,7.6799999999993815, made a change to temp and x has also changed so as was suggested from the back we need to make a
4447.28,9.600000000000364, copy of x what we've done here is called on when I did temp equals x on a mutable variable what did I
4456.88,16.639999999999418, make an alias exactly right so let's make a copy of that x right here right so hopefully that
4473.52,6.1599999999998545, fixes things because I've run out of lines to fix so we run this code again with a b and
4480.8,7.280000000000655, see the output before the reverse temp and x should be the same and they are they're both a b a b
4488.64,7.119999999999891, and after the reverse the temp should be the reversed ba and it is and the x should remain the same a b
4496.64,7.680000000000291, and it's false so it's not a palindrome last thing I need to do is double check my
4505.280000000001,5.039999999999964, for original test case the one that actually worked before I made all my changes to see whether it
4510.320000000001,8.399999999999636, still works and it does okay so that particular list is a palindrome so that still returns true
4519.04,7.200000000000728, okay so that's it so I got a couple or just one I guess list comprehension for you to try
4527.12,4.800000000000182, on your own to write and then of course the buggy wordle game for you to try as well
