start,text
0.0, All right.
13.34, Let's begin today's lecture.
15.200000000000001," So last class, we began our adventure with creating our own data types."
21.6, Today we're going to start off with a little bit of a recap just to remind you some of the
26.8, details about creating our own data types.
29.560000000000002, And then we're going to build upon that coordinate class.
33.08, We started in a last class.
35.24, We'll build a circle class and then we'll build some fraction data types.
41.28, All right.
41.44, So the first thing I'd like to mention is to remind you guys about sort of writing code from
48.68," these two different perspectives, right?"
50.6," So just like when we wrote functions, we were kind of writing the definition of the function,"
56.12, telling Python we have this function that we're defining abstractly and this is what
60.12, it does.
61.12," And then we were calling the function later on in a program many, many times."
65.12, Well the same idea exists now that we're creating our own data types.
71.2, We have to write code from the point of view of somebody who's implementing the class.
75.08, So deciding all of these details that goes into creating the class itself versus somebody
80.96, who's just using a class that's already been written where we create instances a bunch
86.6, of different objects that just happen to be this data type.
90.63999999999999," So when we implement the class, what were some of the things we did?"
94.19999999999999," Well, we're telling Python that this object now exists."
98.28," We're telling Python the name of the data type that we're creating, something we choose."
102.75999999999999," We're deciding, we're making these design decisions where we decide what attributes"
107.24, make up our class.
108.32," So the attributes are either data, like the properties, what are the variables that make"
112.63999999999999," up your object, and the behaviors through methods."
117.91999999999999, So that's implementing the class.
119.32," And then when we're using the class, we're now saying, all right, let's assume that this"
124.19999999999999, class definition exists.
126.0, There's this object that has these behaviors and these data attributes.
130.07999999999998, Let's now create a whole bunch of objects that are of this type.
134.84, And this is when we're creating these instances and then manipulating all of these instances
138.6," by running methods on them, things like that."
141.52," So when we're implementing the class, right, this thing on the left-hand side, we're"
145.64000000000001," basically telling Python in abstract terms, what are the common properties and behaviors"
152.4, of our data type.
154.04," And then when we're using the class, the thing on the right-hand side here, we're creating"
158.44, actual objects with very specific values for their data attributes that we can manipulate
164.64, in different ways.
167.0, So let's remember this coordinate class that we wrote last lecture.
171.76," This is not new, but I will just go over it real quick."
175.48, So first line here tells Python we're creating a new data type.
179.95999999999998," Its name is coordinate, and this keyword class tells Python we're creating the data type."
185.07999999999998," The parentheses here is object, which stands for the Python object data type."
190.76, So it's something really generic.
193.72, And this in the parentheses here is the parent of our class.
198.2," So anything that a regular Python object can do, the very basic things our class can do"
203.76, as well.
204.76," Last lecture I mentioned, an example of such a basic thing is to take a variable name and"
209.76, assign it to an object type that we create.
214.2, The very first method that we should write for a new data type that we create is the init
219.23999999999998, method.
220.24, This I called a dunder method because it starts with double underscores before the init and
228.12, ends with double underscores after the init.
229.96," That's the actual name of this method, double underscore init, double underscore."
235.64000000000001, So this method is like a constructor for the class.
238.36, It tells Python how do you create an actual object of this type?
242.4, So it's a function.
245.44, It's just a function that works only with objects of type coordinates.
249.08," So as a function, it takes parameters."
252.56," You can see it takes three parameters here, the self, the x and the y."
258.08000000000004," Now when we're actually creating objects of type coordinate, we only pass in parameters"
263.08000000000004, for everything other than self.
265.48, Because self is a variable name that we use to describe having an instance of the class
272.44, without actually creating one yet.
274.72, Because remember what we're doing here in this definition.
277.0, We're telling Python that this object type now exists.
280.44, We're writing it as we speak.
282.64," But we don't have an actual instance to manipulate yet, right?"
285.44, This is just the definition.
287.24," And so the self tells Python that when we're writing this code, we're going to use the"
292.76, self variable name as sort of a formal name to be able to run this method on.
299.88, So we're going to see in the next slide exactly what maps to self when we run it.
304.52, That's what the self means inside the parameter list here and here.
309.96," And then beyond that, we use self within the init method to tell Python which one of these"
316.44, variables are actually data attributes versus which of these variables are just plain old
321.35999999999996, variables as we've been working with.
323.64," So any variable that's defined using self dot, so here I got self dot x and self dot y,"
329.76, are data attributes.
331.88," So that means any object I create that's of type coordinate, I know we'll have a variable"
337.6," x and y associated with it, right?"
340.76, Because I've defined these x and y is using self dot x and self dot y.
344.84," Now in the last lecture, I actually had these parameter lists, the parameters in this list"
349.71999999999997," here be different in the next and y, I think I had x, y, y, and then I had self dot x equals"
356.04," x, y, where this x here to the right of the equal sign is the x from the parameter list."
361.84, Right?
362.84," But, you know, so in that sense, it doesn't matter what these variables are in the parameter"
367.44," list, they're just going to be the same over here on the right hand side of the equal"
370.4, sign.
372.0," But the actual parameters, sorry, the actual data attributes are self dot x and self dot"
378.76, y of my object.
382.44," Okay, so then we had one method that we wrote last lecture, it was called distance and"
387.84, it took two parameters.
388.96," So the first one of course is self and this self represents the thing, this object that"
394.52, you're going to call the method on.
396.47999999999996," I don't have that object yet, so I'm just calling itself for now because this is the class"
401.32, definition.
402.32, And then this other parameter is some other coordinate object that I'm going to run this
407.71999999999997, method on.
409.52," So the body of distance says, all right, well how do I find the distance between two points"
415.76, in the 2D plane?
416.76," It's just pathagoras, right?"
418.76," So that means grab the x value of one of my points, subtract the x value of the other"
423.36," point, square them, same with the y's, square them, add them, take the square root."
428.84, So what's the x value of one point?
431.03999999999996," Well, one of the points is going to be the thing that I'm calling the distance method"
434.59999999999997, on self.
436.0," So I grab the x value of self using this dot notation, self dot x."
440.84, And then what's the x value of this other coordinate point?
444.52," Well, it's called other in my parameter list, so I'm going to grab the x value of other"
449.64, again using dot notation.
452.91999999999996, And then we just do the math.
455.71999999999997, Yes?
456.71999999999997, Can you call functions on a class that we're defining in like this?
464.84," Yes, so you can make methods for a particular class."
469.64," But you can only call those functions that you get to find, that you can't call another"
474.44, one.
475.44," Exactly, yeah."
476.44, Yeah.
477.44, Is there a way we could define a class as something other than an object?
485.56, A class is something other than an object.
487.56," Right, like there we put the coordinate in that object, we could do something else to"
492.0, this one.
493.0, In the parentheses?
494.0," Yes, we can put other things in the parentheses."
495.44, So that's actually what Monday's lecture will be about.
498.24," In that case, the thing in the parentheses becomes the parent of the class that you're currently"
503.84000000000003, writing.
505.0," So I won't go into too much detail, but to have this other object as a parent means that"
510.72," everything that that object can do automatically, your object can do as well."
515.6800000000001," And then on top of that, you can decide a bunch of additional stuff your new object does,"
521.5600000000001," but in a sense, your coordinate object is a, whatever this thing in the parentheses is,"
527.6, and then it can do a bunch of other stuff as well.
530.6, Yeah.
531.6, Similar to how we can copy at least with this square brackets.
537.6, Yeah.
538.6, How can you do that?
540.6," Oh, to make a copy of the object or."
543.6, To make a copy of the class.
546.6," Oh, so here, we're not, you can't make a copy of the class here specifically because we're"
552.0, just defining the class.
553.76," But when you're creating coordinate objects, then you could define a method that copies your"
560.76, object into another object.
564.64," So in essence, it would return a new object of type coordinate with whatever parameters"
569.8, you'd want to do.
572.76," So all, yeah, all these things are possible."
577.2, So let's add one more method to this class.
579.84, Let's call it two underscore origin.
584.24," So this distance method, just to remind ourselves, returned a number."
588.96," So it just took the difference between these two points and it returned a number, just"
593.36, how far away they are.
595.4, But this two origin method is going to do slightly different.
599.2," Essentially, what I'm going to have this method do is to take my point from wherever it is"
603.72, in my 2D plane that it has been initialized to.
607.96," And say, I'm going to reset it back to the origin."
612.72," So to do that, all that means is I'm going to make its x value and its y value be zero."
620.08, So I can manipulate the x and y data attributes of this particular object to be whatever
626.44, I want them to be.
627.44, So I can reset them both to be zero.
629.88, So if I ever call this method on an object whose x and y values are something other than
634.48," zero, they'll be reset to zero."
638.24, So let's actually run the code that we just wrote.
641.76, So here I've got two coordinate objects being created.
644.72, So the beauty of writing this class for us is that now we can create as many coordinate
649.36, objects as we'd like.
650.88, They all will have an x value and a y value associated with them.
654.48, It's just that the specific values for x and y will be different.
658.6800000000001, So here I've got a coordinate object with x3 and y4 being created and it's going to be
664.6, bound by the variable named c.
666.88," And here a coordinate object with x and y values both zero, bound to a variable named"
671.88, origin.
674.24, So then I can use this dot notation that we talked about last lecture to access either
678.84, data or to run methods on the object.
684.48," So in this print statement here, I'm using dot notation on c and origin to grab the"
692.56, x values of c over here and origin over here.
698.5999999999999, And then I'm running the distance method on c.
701.88, So remember dot notation says the thing before the dot is going to be an object.
707.56, The thing after the dot is going to be the method name that can run on this object of type
714.0, whatever this is coordinate.
716.0, And then in the parentheses it's just a function we just pass in all the variables.
721.0, That method expects.
724.72," So c.distance will print whatever, however far away it is, I know five because those are"
729.6, nice numbers.
732.2," So then if we run this function that we just wrote dot two origin, this function just"
737.12, to remind you doesn't actually return anything.
740.64, It just resets the variables x and y for that particular object back to zero.
746.84," So in here, when I call this method here, again dot notation, the thing before the dot"
753.08, is an object.
754.24, It's c.
755.5600000000001, It's x and y values are currently three and four.
759.6," But after I run this function, it returns none, by the way."
764.08, It's x and y values will be changed to zero and zero.
768.2," So if I look at my code here, so here's this printf statement."
775.0, So c's x values three and c's an origin's x is zero.
781.44," And then I've got these two calls here, so c dot two origin, right?"
785.92," I'm making this function call before the function call c's x is three, c's y is four."
790.56," And after the function call, you can see c's x is zero and c's y is zero."
794.72, So I'm literally changing the x and y values of this object c.
799.0," All right, so questions so far?"
807.08, So far so good.
808.32, Hopefully recap.
809.72," Okay, so again, sort of similar to the first slide we started with, right?"
814.24," So we've got this class coordinate object, right?"
816.16, The class name is our type.
817.96, So this object I'm creating is of type coordinate.
820.88," We're defining the class in a generic way and an abstract way, right?"
825.08," So we have to use the self variable, either in the parameter list to tell Python what's"
832.0400000000001, the thing before the dot going to map to?
834.24," Well, it's going to map to self in my parameter list."
838.0400000000001," Or we use the self to tell Python what the data attributes of this object are, right?"
842.84, So anything defined with self dot some variable name will be a data attribute.
848.0400000000001, That's common across all the instances I create from of this type.
852.88," When we create actual instances, that's when our blueprint, our abstract definition now"
859.24, gets put into use.
861.56," And now I'm creating actual objects that I can grab x values from, change x values from,"
867.6, get distances between other objects and so on and so on.
871.64," Okay, so what I'd like to do next is to take this coordinate class and build a circle"
880.4, class with it.
882.28, So this comes sort of hand in hand with the idea of when you're deciding how to create
888.4399999999999," a class, you get to make the design decision, right?"
890.88," So when the finger exercise for Monday's lecture, today's Wednesday, yes, Monday's lecture,"
896.8399999999999," you guys had to create a center, sorry, a circle class, right?"
901.72, But the way we defined the circle class in that finger exercise was basically by that
907.04, circle's radius.
908.56," That's the only sort of way we abstracted that circle, right?"
913.28," But now in this lecture, we're going to make a different design decision and say that,"
919.36," let's say, and say that a circle will now be defined using two things."
924.0," The first is the radius, right?"
926.5999999999999, So I'm going to say that that's an integer.
928.64," And the second is going to be the center of the circle, right?"
932.32," So as in the picture there, I'm going to say that a circle is, you know, based on the"
936.44, center and this radius.
938.88," And the center is not going to be a float, it's not going to be a tuple, it's not going"
943.12," to be an int, it's going to be a coordinate object, right?"
947.8000000000001," The data type that we were just writing, okay?"
951.6400000000001," All right, good."
953.6400000000001," It's not a secret, but it didn't lower my voice on purpose, just wanted to let that sink"
959.96," in, right?"
961.12, One of our data attributes for the circle class is a coordinate object.
966.5600000000001," So we're using an object that we just wrote to create a more complex object, a circle."
972.4000000000001," Okay, so here's my class definition."
975.6800000000001, The data type is called circle.
977.6," Again, it inherits all the parent of circle is just a generic Python object."
983.08, First method we have to write is the init method.
986.92," The first parameter is self, so this thing that I'm creating right now, and I say that"
991.28," to create a circle, I have to give it a center, and I have to give it a radius."
997.64," The data attributes of this circle class, right?"
1001.8," So the two attributes that make up my circle are this self dot center, so this center variable"
1008.4," here, and self dot radius."
1010.8399999999999, So these two things together make up our circle object.
1015.84," And initially, in the init method, right, and when we construct our object, we're just"
1019.6, going to set these two things to be whatever is passed in as parameters in that in the constructor.
1026.2, Okay.
1027.2, All right.
1030.72," So what I'd like to say is that this center parameter will be a coordinate object, and"
1038.8400000000001, radius will be an int.
1040.52," Now notice in this code, I'm not actually enforcing this, right?"
1043.88," I could create a circle object by just passing in two strings, right?"
1050.48," At this point, this code doesn't care, right?"
1053.88," Nowhere am I enforcing the fact that center is a coordinate and radius will be in it, but"
1058.2," you know, that's just something that we know."
1061.8000000000002," So then when we create the actual object down here, right?"
1067.68, My underscore circle is going to be a variable that's bound to my circle object.
1073.0, So here I'm invoking the name of my class circle.
1076.76, And then what are the two parameters I'm passing in?
1079.28," Well, the first one I said right up here that it should be a center, a, a, a, a, a, a, a, a, coordinate"
1084.56, object.
1085.96, So center is a variable name.
1088.96, And what is it?
1089.96," Well, I had to create this coordinate object, right?"
1094.32," So I'm just invoking the name of coordinate, this class that creates for me a coordinate"
1098.08," object, and I happen to put the center of the circle at two comma two."
1104.3999999999999, Yeah.
1105.3999999999999, Okay?
1107.3999999999999," So this center thing is a coordinate object, right?"
1110.1599999999999," It's not a two-puller, float, or whatever."
1111.9199999999998, It's a coordinate object.
1113.24," And then the radius of this circle is two, an int."
1119.96, Everyone okay with that?
1121.8799999999999, Okay.
1122.8799999999999, So what I'd like you to do next is to modify this init method just slightly.
1126.96, Just to show you that the init method doesn't just always set the data attributes and
1132.68, it's done.
1133.68, It can do a lot of initialization code.
1136.56," One of the more important things it can do is to try to enforce the types on the, on the"
1143.76," parameters here, right?"
1145.44, So what I'd like you to do is add to this code to check that the type of center is a coordinate
1153.04, and the type of radius is an integer.
1155.6," And only if those two things are true, then do you set the two data attributes?"
1162.12, And otherwise raise for me a value error.
1167.1599999999999, So that should be around line 48.
1170.9199999999998, Okay.
1171.9199999999998, Does anyone have some code for me?
1176.9199999999998, Yeah.
1178.92, Not equal coordinate.
1185.92, Yep.
1186.92, So that's raise value error.
1190.92, Yep.
1191.92, Cool.
1192.92," So that takes care of one, yep."
1196.92, And then the same for radius.
1203.92, Yep.
1204.92," So if the type of radius, because that's the parameter passed in, not equal to int raise"
1210.92, value error.
1216.92," So if we drop into each of any of these ifs, then we immediately raise the value error,"
1222.48, right?
1223.48, The code doesn't complete.
1224.4," And then only if we didn't drop into this one or this one, do we then go on to create"
1229.88, my object.
1231.88, So then here we are.
1233.16," These two lines here will succeed, right?"
1236.2800000000002, So there's no error raised or anything like that.
1239.1200000000001," But then this line here, raised of our value error, because we tried to create a circle"
1245.0400000000002," where the center is an integer, right?"
1247.2, Obviously not a coordinate object.
1248.88," And then here, again, we raised our value error because we tried to pass in a string as"
1253.68, the radius.
1255.2, Any questions about this code?
1257.48," Oh, yeah."
1258.48, Sorry.
1259.48, Yeah.
1260.48, So just think that it's very important for these students to use this before.
1266.48, Yeah.
1267.48," So it's important to place them before you actually create the object, right?"
1269.6, Because you don't want to create it unless everything's appropriate.
1277.48, Okay.
1281.68, So now let's add one more useful method to our class circle.
1288.52," Now that we've defined a circle using a center point in a radius, we can add this little"
1294.48, function that checks if another coordinate object is inside our circle.
1303.24," So again, I'm not going to be able to enforce that this point is a coordinate object, but"
1310.08," you know, you could do it in the dox string or you could do a check or something like that."
1313.72," But you know, again, we're just going to assume the user using this method is going to follow"
1317.44, the rules.
1318.44, So how is this method going to work?
1320.72," The idea here is that we're going to use the center, which is a coordinate object, and"
1325.92," some other point, you know, P, wherever it may be."
1329.48, What we're going to do is we're going to say what's the distance between this point and
1333.52, the center of the circle.
1335.48," If it's greater than the radius, we know the point is outside the circle."
1339.2," If it's smaller than the radius, we know the point is in the circle, right?"
1343.56, So this code is just enforcing that.
1346.28," So we have just a simple return statement that's going to run the distance method, right?"
1354.16," This is a method that we wrote back in the coordinate class, right?"
1362.28, That's fine because you know what?
1365.24," Point is an object of type coordinate, and self dot center."
1370.0," So the center of this circle object, I'm trying to manipulate, right?"
1373.76," This, tell if another point is inside me or not, is also a coordinate object."
1379.52, So why not?
1381.2, We already wrote the code that calculates the distance between these two points.
1384.76, So let's call it.
1385.76," So here I've got the thing before the dot, a coordinate object, dot notation, the method"
1390.68," I want to run on this coordinate object, and then in parentheses, this is another coordinate"
1395.0, object.
1396.0, So this will just tell me some number for how far these two points are.
1399.52, And all we do is return whether that number is less than the radius.
1403.68, Does that make sense?
1409.84," And again, this only works if point, the thing that's passed in here is a coordinate object,"
1414.84, right?
1415.84," Otherwise, this code will fail because it's going to try to pass in, it's going to try"
1420.08," to run the distance method on a string, for example."
1422.96," And of course, this string doesn't have a distance method, right?"
1427.0," So down here, these two lines are exactly as we had before."
1430.8," We create a circle object whose center is at 2, 2 and radius is 2."
1436.4, And then I've got another coordinate object down here.
1439.56," It's at 1, 1, right?"
1442.16, So clearly within the circle.
1443.96, So that print statement will then print true.
1447.76," Right, so that's just basically what I wrote."
1449.84, This is a coordinate object.
1450.84, This is the method.
1451.96, This is another coordinate object.
1453.92, All right.
1455.72, So let's run it.
1459.92, So this is exactly the code from the slide.
1461.6000000000001," So if I run this method on a coordinate object, that's 1, 1."
1465.16, So we're in here.
1465.96, So true.
1467.32," And otherwise, if I run it on coordinate object, right?"
1470.96," Here, 10, 10, clearly outside the circle, it prints false."
1479.88, Questions?
1486.72," Yes, that's exactly what I said already."
1489.76," OK, good."
1492.0, So now I want you to answer this question.
1494.16, Nothing to code here.
1496.08, But I've got these two is inside methods.
1499.52, So the first one here is inside 1 is exactly the one that we just saw.
1503.6000000000001, Right?
1503.88, It runs this distance method with point and self dot center.
1508.92, Is inside 2 looks slightly different?
1511.32, The differences I've highlighted in this box.
1513.68, What I'd like you to tell me we can do a show of hands.
1515.68, And these two methods functionally equivalent.
1519.92," That is, will they return the same thing given the same input?"
1525.68, So think about it.
1526.88, And then I will do a show of hands.
1535.6000000000001," So who things, yes, they are functionally equivalent."
1540.6000000000001," Like given the same input, they will both return true, right?"
1544.16, And variables.
1545.68," OK, who thinks no?"
1546.76, They are not functionally equivalent.
1549.64," Some, half and half."
1552.44," OK, well, let's think about what the distance method is doing."
1558.8000000000002," It's being run on an object of type, what?"
1567.8000000000002," Coordinate, exactly."
1569.6000000000001," So in here, is point an object of type coordinate?"
1573.6," Yes, OK."
1574.84," And then here, what is the parameter to the distance method?"
1579.3999999999999, Is it object of type coordinate?
1582.84," Self dot center, is it an object of type coordinate?"
1586.08, Yes.
1586.84, So now let's look at is inside 2.
1589.48, What is the type of self dot center?
1593.56, Coordinate.
1594.1999999999998, And we're running the distance method on this object of type
1596.7199999999998, coordinate.
1597.6799999999998, And what is the object in the parameter list here?
1601.56, What's its type?
1603.76, Coordinate.
1605.24," So when we wrote the distance method,"
1607.1599999999999, does it matter which object we call the method on
1611.24, to get the distance between these two points?
1614.6," No, right?"
1615.1999999999998," Because the distance between saying,"
1617.9199999999998, I want the distance between this point and this point
1621.12," is the same as saying, I want the distance between this point"
1624.32," and this point, right?"
1625.12, It's just the order is different.
1629.24," So just the way that this distance method works, right?"
1632.16," It doesn't actually matter which object I call the method on,"
1636.0800000000002, right?
1638.0," As long as they're both coordinate objects, which they are."
1644.0, Does that make sense?
1644.8000000000002, Is that all right?
1645.44, Any questions about this for those who are in the no path?
1648.28, Yeah.
1648.8000000000002, So the most important thing is that a circle up to the wall.
1654.16, Self dot center?
1655.64," Self dot center is an object of type coordinate, not circle."
1660.44," Because self is a circle, right?"
1664.16," Because self is talking about me, the class that I'm currently defining."
1668.72, And the class I'm currently defining is a circle.
1672.3600000000001," But self dot center, right?"
1675.04, We even wrote code.
1676.04," We would like to enforce that it is a coordinate object, right?"
1686.64, So we could have put parentheses around the self dot center
1689.92, if we wanted to and then call the distance on that.
1692.64, Does that make sense?
1695.48, OK.
1697.8400000000001, All right.
1698.68, So that's all I had regarding the circle class.
1701.44, Now we're going to switch gears and we're
1703.0800000000002," going to look at fractions, right?"
1705.16," So numerator, denominator, situation here."
1708.88, So we're going to create a new data type to represent a number as a fraction.
1715.48, So first thing we need to do is make the design decision.
1718.56, What data will represent our fraction?
1721.52, So think about it.
1723.6399999999999," You guys tell me, what do you think?"
1724.84, What's a reasonable set of data that could represent our number as a fraction?
1732.12," When you think of a, yeah."
1734.6, Is it like a set of two things that are greater than the?
1738.72," Yeah, a set of two things, maybe integers, right?"
1742.28," One representing the numerator, the thing above the line,"
1745.48," and one the denominator, the thing below the line."
1748.24, Good.
1748.74, That's exactly what I had in mind.
1751.2, What are some behaviors of fractions?
1754.48, You guys tell me.
1756.76, What things should fractions do?
1760.16, Yeah.
1761.16, Oh.
1762.16," Oh, you can have them."
1763.72, Yeah.
1765.4, Yes.
1765.88," Adding them, multiplying fractions together, dividing them,"
1770.32," inverting a fraction, also something we could do, right?"
1773.16," So one over what it currently is, things like that."
1776.64, All right.
1777.64," So one over what it's going to do is,"
1779.88, we're going to have a fraction of the fraction.
1782.88, So the first thing we're going to do is create this fraction class.
1787.5600000000002," And I'm actually going to name it simple fraction instead of fraction,"
1792.5600000000002, because we're going to improve upon this simple fraction object in a little bit.
1798.1200000000001," So this one, I'm just going to call some of the numbers,"
1802.2, and then we're going to have a fraction of the fraction of the fraction.
1806.2," So this one, I'm just going to call simple fraction."
1809.48," Like before, it's parent is the generic Python object."
1814.68," So again, very, very simple."
1816.88, It doesn't do anything special yet.
1822.0800000000002, The first method we need to write is the init method.
1825.04, So how do we initialize a fraction object?
1827.24," Obviously, we don't want the numerator or the denominator to be empty, right?"
1831.52," So when we create a simple fraction object,"
1833.68, we want the user to tell us the values for the numerator and the denominator.
1838.72, So those are the two parameters that I would love the user to initiate this fraction with.
1845.88, And then what will be the two data attributes that we had decided on?
1851.8," Well, numerator, so self.num and self.dnum will be the two data attributes."
1858.2," So self.num and self.dnum are our data attributes,"
1861.24, and they're going to be set initially to whatever is passed in that constructor call.
1869.56," Okay, so far so good."
1871.72, Let's write a method that helps us multiply two fraction objects together.
1876.32, So we'll call it times.
1878.72," So this times method will be called on an object, the thing before the dot."
1884.28," That object, that thing before the dot, will get mapped to self."
1888.36, And then the thing in the parentheses that one other parameter will be mapped to OTH.
1894.7199999999998," Okay, so how do we multiply two fraction objects together?"
1899.24," Take the numerators, multiply them, take the denominators, multiply them."
1903.08," You got your numerator and you got your new denominator, right?"
1906.7199999999998, So how do we grab the numerators of both of these objects?
1910.4399999999998," So the numerator of the thing before the dot, right, that maps to self is self.num."
1916.2," And the numerator of the other object that's going to be in the parameter list is the name of my parameter, OTH dot, their numerator."
1927.8, No.
1930.52, Everyone okay so far?
1934.04," Yes, okay."
1934.88," I saw some headnuts, that's good."
1937.32," The denominator will be the same, so my new denominator is just multiplying my denominator,"
1942.56," the thing before the dot, what with the thing in the parameters denominator."
1947.36," Okay, so I've got my new numerator, my new denominator, and all I'm going to do is do the division and return this value."
1954.08, What's the type of the return here?
1955.96, What's this method going to return?
1957.24, What type?
1959.08," A float, exactly, yeah, good."
1961.72," Yep, because all I'm doing is dividing one number by another number."
1967.72, Okay.
1970.16," Perfect, so that's what I've already said."
1974.16," Now, we can define another method, plus to add two fraction objects together."
1979.96," Very similar thing, except the top is going to be slightly different, right?"
1983.6000000000001," You take the numerator of one, times the denominator of the other, plus the numerator of other,"
1989.6000000000001," times the denominator of the first one, right?"
1992.8400000000001," The crisscross thing, the denominator is the same, right?"
1995.64, Just multiply the denombs together.
1997.64," And again, we return the division, divided by bottom."
2000.64," Again, the return of this method will be a float."
2005.1200000000001," So even though I'm multiplying or adding these two fraction objects together, my return will be a float."
2010.88, Fine.
2012.2800000000002, So let's run the code.
2014.4, I'm creating two simple fraction objects.
2017.64, First one is going to be accessed using variable named f1.
2021.96, So this one represents the number three over four.
2025.96, Second one is accessed by variable named f2.
2029.92, And this one represents the fraction one over four.
2032.96, Okay.
2035.08," So now, if I access the numerator of f1, Python says, well, what's the object before the dot?"
2041.76, It's f1.
2042.8, So what is your numerator?
2044.1200000000001," Well, I said it to three, so this one tells me it's three."
2047.16, Right?
2047.66, Pretty simple.
2049.6, Same thing with the denominator of f1.
2051.84," Again, it looks at the thing before the dot."
2053.7200000000003, It's a fraction object.
2054.96," It says, do you have a d-nom, a data attribute you do, and its value is four, so that's four."
2062.2," Now, what's the result of f1.plus f2?"
2065.92, Super weird way to write it.
2067.76, But it's what we've got so far.
2070.4, Right?
2070.9, So the thing before the dot is an object.
2074.8, It's a simple fraction object.
2077.52," And the thing before the dot, remember, maps to self in my parameter list."
2083.16, Right?
2083.88, It's just a function.
2085.6400000000003," So like usual functions, a bunch of lectures ago, we basically mapped the actual parameters"
2092.0," when we run the function to the formal parameters, the things for my function definition."
2097.6800000000003," So the actual parameter here for self is the thing before the dot, f1, and the parameter"
2104.32, f2 gets mapped to OTH.
2106.92, Right?
2107.92, That's how we read that.
2110.88," So this is just doing the addition, right?"
2113.16," So this will give me 1.0, because it's a float."
2118.56," Same with the times, the thing before the dot maps to self, and every other parameter in"
2122.96, the parameter list maps to everything else except for self.
2126.8799999999997, So this one will do 3 over 16 to give me 0.1875.
2130.8399999999997, Okay?
2132.8399999999997, Everyone okay so far?
2134.68, Right?
2135.68," The trick here is to remember that the thing before the dot maps to self in the method definition,"
2142.44, then everything else maps to everything other than self.
2147.04, Okay.
2149.56," I'm glad everything's okay so far, because I'm going to get you to write this code here."
2154.2000000000003," It looks like a lot, but the first half of it is just defining the init method for simple"
2160.28, fraction.
2161.52," I want you to write these two methods, and they're going to be one liners basically."
2165.84," So get inverse will return something, and it returns a float representing one over"
2174.36," myself, right?"
2175.6800000000003," So if the input, as is in this example here, if I have a simple fraction object representing"
2180.7200000000003," 3 over 4, if I call get inverse on it right here, f1 dot get inverse, self becomes f1,"
2189.44, and I would like it to return and therefore print 4 over 3.
2194.16, So 1.33333333.
2195.76, Okay?
2196.76," That's get inverse, and then invert is a method that doesn't return anything, so returns"
2203.28," none, and instead it just internally switches the numerator and the denominator of self."
2210.7200000000003, Right?
2211.7200000000003, So self's numerator becomes whatever its denominator is and the other way around.
2216.6," So when you call it, this one doesn't print anything, but instead if we access f1's numerator"
2221.6," and denominator, they will have been switched."
2226.96, So this is down online.
2230.36, 1.33?
2234.56," Give you a couple moments, and then we can write it together."
2237.3199999999997, Should not be a lot of code.
2239.2, Okay.
2240.2, How do we write the get inverse?
2242.24, So remember you have to return something.
2245.32, How do we return?
2246.32," Yeah, 1 over."
2251.0, 1 over self.
2253.6800000000003," So remember self is an object of type simple fraction, right?"
2257.1200000000003, So we need to manipulate its numerator and the denominator if we want to do the return.
2262.0," Because if we just do this, is this one here, then Python says, oops, sorry, it's trying"
2272.04," to divide 1, an integer, by an object of type simple fraction, right?"
2277.8, And that's the error that we get here.
2279.92, And it doesn't know how to do a division between an integer and a simple fraction.
2283.84, So how can we do that by working with actual numbers that are part of my simple fraction?
2292.16, Yeah.
2299.16, Self.denom divided by self.nom.
2308.6," Yeah, we can do that."
2310.6, Yeah.
2311.6, Or 1 over self.nom divided by self.denom.
2313.6," That's also fine, yeah."
2314.6, But this is a little bit cleaner.
2316.6," So now, denom is an integer, right?"
2319.0," Because when we create it, we pass in int int."
2322.84," So denom and num are integers, which means that Python knows how to do a division between"
2327.24, a number and another number.
2329.4, Yeah.
2331.92," So if we run that, now it prints 1.33333, exactly."
2337.76, Okay.
2339.4, How do we do the invert function method?
2342.16, Sorry.
2344.16, Sorry.
2345.64, Go ahead.
2348.64, Yeah.
2355.64, Yeah.
2362.64, Yeah.
2363.64, That's one way to do it.
2381.64, Yep.
2382.64, So you can see now accessing the new numerator and denominator gives me 4 over 3.
2387.64, Any other ways that you've done it?
2389.64, Yeah.
2390.64," The two-pole trick, I like it."
2397.64," So I've done, yep."
2400.64, Perfect.
2401.64, Yes.
2402.64," Oh, okay."
2403.64, Yeah.
2404.64, That also works.
2405.64, Yeah.
2406.64, Perfect.
2407.64, Yeah.
2408.64, Perfect.
2409.64, Yes.
2410.64, I guess it's all that now.
2417.64," Oh, okay."
2418.64, Yeah.
2419.64, That also works.
2420.64, Yeah.
2422.64, Perfect.
2423.64, All very valid ways of doing it.
2425.64, Nice.
2426.64, Yep.
2427.64," So notice, there's no return for this one, right?"
2429.64, I didn't want to return anything.
2430.64, Python will automatically return none.
2432.64, And these internal numerator and denominators will have been flipped.
2437.64, Perfect.
2438.64, Questions about this code?
2443.64, Okay.
2446.64, So let's try it out a little bit more.
2448.64," So here I've got these two additions, right?"
2452.64," So this is exactly what we had previously, the exact same code."
2457.64," What's weird though, and you might have been weirded out by this too when we first"
2461.64," ran it is I am doing operations with two fraction objects, and yet the plus and the"
2468.64," times methods give me floats, which is a little weird, right?"
2473.64," Ideally, if we're working with fraction objects, I would like the return to also be a"
2478.64, fraction object so I can then work with more fraction objects later on.
2482.64, That's one weird thing.
2484.64," Another weird thing is if we then print one of our objects that we've created,"
2489.64," F1 in this case, we use print statements often, right, to debug things like that."
2494.64," If I use the print statement on an object of type that I've created, in this case a"
2499.64," simple fraction, Python spits this out."
2503.64," It says, hey, your object is an object of type simple fraction at this memory"
2508.64, location.
2509.64," No thank you, that's not very useful to me, right?"
2513.64, What I'd like to know is maybe a nice representation of my fraction object like
2517.64," 3 slash 4, right?"
2520.64, I don't care about what memory location it's at.
2523.64," And one more thing we'd like to try to do, this is a class that represents something"
2529.64, numerical.
2530.64, So something that people might instinctually want to do is to use operators like the star
2536.64," or the plus or the slash to divide, add, multiply these fraction things."
2543.64," But if we run the star operator between object of type simple fraction, right,"
2548.64," times another object of type simple fraction, Python gives us an error."
2554.64, And I'll even show you the error.
2557.64, So here.
2563.64," So here I am printing my object, right, so it spits this out, which is fine,"
2568.64, but not what I want.
2570.64," This one, you know, obviously we've seen this, it already prints this out."
2573.64," And then if I try to multiply my two simple fraction objects together, it says,"
2577.64, I don't know how to do that.
2581.64," Right, so it's unsupported operand types."
2584.64, So the operand simple fraction and simple fraction are not supported with the star operator.
2588.64," Well, no surprise there, how is Python supposed to know how to multiply two simple fraction objects together?"
2594.64," Right, right, before I even ran this program, I didn't even know what a simple fraction object was."
2599.64," Right, so we need to tell it all of these details, and we will do just that."
2606.64," So all of these operators print LEN that we've been using star, add, right,"
2614.64, less than greater than even the square brackets to index into something.
2618.64, These are actually shorthand notations.
2621.64," Right, they're really common operations that you want to do."
2625.64, And Python lets you use these common operations instead of writing these really verbose function names.
2634.64," But really behind the scenes, all of these shorthand operations actually run a method."
2642.64," Okay, again, not a secret, I'm not lowering my voice because it's a secret, but it's just, it's really cool."
2647.64," So all of these operations, like the multiplication or the print statement, just gets replaced with a method."
2655.64," Okay, and the method names look like this."
2658.64," They are dunder methods, just like the init method was a special method that Python ran when something special happened, like you're creating an object."
2666.64," Well, when something special happens, like you're using the plus operator between an object of your type and something else,"
2673.64, Python will also run this special dunder method behind the scenes.
2678.64," And same here, if I want to multiply my object with something else, Python will run this special dunder method behind the scenes."
2685.64," If I want to print an object of my type, Python will run this special dunder method behind the scenes."
2692.64," Even something like casting, if I want to cast my object to a float or to a string or something, Python will run this special dunder method behind the scenes."
2701.64," And then, you know, there's a whole bunch of other ones, even indexing into a list, sorry, not a list, indexing into an object of your type."
2708.64," So if you make an object like a queue or a stack, where you know you have a bunch of sequences of objects, you can tell Python how to index into an object of your type into an object that's a queue."
2721.64," So all of these things, all of these methods need to be implemented somewhere."
2728.64," Now, most of them are not implemented in the basic Python object, except for the STR."
2735.64, So the STR method actually just prints the memory location of this object.
2739.64," That's exactly what we had seen, right, by the default behavior."
2742.64," But none of these other ones are really implemented. And so if you want the object that you're currently writing to work with the STR or the plus or the double equal sign to test for equality between this object and something else, you have to write the method in your class definition."
2761.64, So you have to implement it to tell Python that this is what you want to do when somebody uses this special shorthand notation.
2769.64," So let's start with the print, because it's the most basic thing you will probably want to implement when you create a new data type."
2775.64," For debugging purposes, you'll find yourself instinctually saying, hey, print F1 to print this fraction object to see what it looks like."
2783.64, And so the STR method is one of the really basic things you should implement right after the init method.
2791.64," So let's look at it in the context of the coordinate object. So here I've got my coordinate object 3, 4."
2797.64," And even when I print this coordinate object, Python tells me this still an informative message that this object is of type coordinate at this memory location."
2808.64," Okay, I don't care. When instead what I would really like to do is say, hey, I want to represent a coordinate object by something like this, angle bracket, the value of the x coordinate comma, the value of the y coordinate, close angle bracket."
2823.64, So that would be a far more informative print statement than what memory location this thing is at.
2830.64," So let's do that. Well, here we are our coordinate object, the distance, the init like we had before. And here I'm defining my STR method."
2844.64," So double underscore, STR double underscore. No other parameters except for self. So me calling this method on an object."
2853.64," And what is this going to do? It will return not print, return a string. And the string is going to represent the thing you want to be printed out."
2866.64, So it returns a string doesn't print it. However you want to make up the string is up to you. So here I've just used concatenation of a bunch of stuff.
2875.64," So I'm concatenating the angle bracket with the x value of my current object, cast to a string, concatenated with the comma, concatenated with the y value of my current object, cast to a string, concatenated with the closed angle bracket."
2890.64, That's the design decision we made for how a coordinate object should be printed. Everyone okay so far?
2901.64," So if you want to use an f string to make up this thing to return, totally fine. If you want to make a variable in between the return and the definition here that you just keep concatenating with, you can concatenate it with new lines and things like that. Also totally fine."
2918.64, At the end you just have to return that string that represents the thing you want to pre-print it out.
2925.64, So now let's see what happens when we actually run the code. So here I'm creating a coordinate object and then I'm printing that coordinate object.
2934.64, Well Python says hey you just called a special shorthand notation on an object of type coordinate. Let me see if you implemented the STR method.
2944.64," It looks in the class definition, it sees the STR method implemented here and then it runs the code inside and says you want to grab C's x value and C's y value and concatenated with these things here."
2957.64, Sure I can do that for you and then it goes and prints this out to the screen. Very cool right now we can decide how to print objects that we create.
2969.64," So let's try to wrap our minds around types here. So if we print this C, C is an instance of a coordinate object."
2981.64," It's an actual object that we're manipulating. It's not the class definition, it's not anything abstract like that. It's an actual object like the integer 3 is an actual object."
2993.64," So if we print that C, Python uses the STR method. Well what if we print the type of C? Somebody tell me what's the type of C?"
3007.64," Yeah it's the class name that we define. So when we print the type of C, Python says this is a class coordinate. Which makes sense because if we just replace type of C here with what it is coordinate, we'll get the same print statement."
3022.64," If we just print coordinate, Python says this is a class of type coordinate. So those two lines are equivalent."
3030.64, Then let me blow your minds a little bit more. What if we print the type of coordinate? Well what is coordinate? It's a type.
3042.64, We're defining a new type in Python called a coordinate. So coordinate is a new data type in Python. So its type is type.
3054.64," So everything in Python is an object, even types. One more thing. So we've used the type of something equals something else. When we checked that the type of the circles center was a coordinate, that's one way to check for types."
3071.64, Another way is to use this instance function just as an aside. So you can check that C is an instance of type coordinate by using this instance method. And this will tell you true.
3085.64, And just to draw parallel you can say is instance 3 comma int. That would also say true. Because 3 is an object of type integer. So just another way to check for types.
3098.64," So the remainder of this class I would like to go back to our fraction class and make it better. Now that we know dunder methods, right, let's implement a whole bunch of dunder methods to help us to help us and people who want to use our class use it in a more efficient way."
3122.64," So we're going to implement the star operator, the plus operator, we're going to implement the print, and then we're going to implement, implement converting to a float."
3133.64, So the first thing that we should probably add is the str method. Because then it will help us in debugging when we print an object of type fraction.
3144.64," So let's define double underscore str double underscore, right, again no parameters except for self because that's the method we're the object we're calling this method on."
3156.64," And again, however you want to form this string is up to you, you can use f strings or a variable that you keep adding on to. I just did it straight in here with concatenation. So I've got the numerator slash the denominator as a very reasonable way to represent a string, right. So 3 slash 4 as 3 over 4."
3179.64," So one thing I guess to keep keep track of is if you concatenating you just have to remember to cast a string, right, if it's a number or something that's not a string."
3189.64," So let's try it out. I've got three fraction objects here, okay. So the first two we've already seen. So I've got a fraction representing 3 over 4, a fraction representing 1 over 4, and f3 is now going to be a fraction representing 5 over 1."
3207.64," Okay, if we print f1 again Python asks, hey, did you implement an str method in your class definition? Yes, you did. Good job. Let me use it. So then it uses this, right. So grabs the numerator of f1 slash the numerator of sorry, the denominator of f1."
3225.64," So this will print 3, the numerator of 1 slash the denominator of f1. Okay, same with f2, except that now it's going to grab f2's numerator and denominator 1 slash 4."
3238.64," So notice now it's not doing the divisions like it did before or sorry, never mind, we're not there yet. There's nothing to divide. It's just grabbing the numerators and denominators and just printing them out, right. It's not doing any divisions."
3254.64," Now when we print 5, the fraction object representing 5 over 1, it prints 5 slash 1. I don't like that because it looks weird, right. Do you like that? No. So then I'm going to have you fix it."
3274.64," Change the str method just a little bit such that if the denominator is 1, just have it print the numerator, right. And otherwise the representation should be as before numerator slash denominator."
3292.64," So this should be down line 140, where is it?"
3304.64," Very far down, 265. Okay, anyone have some code for me?"
3322.64, Yes.
3329.64, Yep.
3338.64," Yep, we can do an else. That else is not needed. I don't think because if we dropped into the f, we just immediately return. Otherwise we would just do the remaining thing."
3355.64, Perfectly fine. Yep. And let's run it.
3363.64," So the a is a fraction representing 1 over 4, so it nicely printed 1 over 4. And b, the fraction 3 over 1 is just printing 3. Good. Questions about this code."
3379.64," For the remaining lecture, though, we're not going to use this modified this nicer better str method. So let's just forget what we just did and just remember that it looks like this."
3392.64," Okay, so now let's implement the dunder methods for addition, multiplication, division, things like that. So I'm going to do the multiplication just because it's not as long for the numerator."
3404.64," So just convenience factor here. The left hand side, I've got our old simple fraction code. And the right hand side has my new fraction code."
3415.64," Okay, so the old simple fraction code. Remember, had this times method that took itself an OTH, a calculator, a new numerator, a new denominator, and returned this."
3428.64," Okay. Now my new fraction code will no longer need to call times. Right. So we're not even implement a method called times. Instead, we're going to implement the method behind the scenes for the shorthand notation star to multiply two fraction, fraction objects."
3447.64," So we need to implement df double underscore, multiple underscore parameter list is the same because we still have a thing before the star and a thing after the star as the two fraction object we'd like to multiply."
3460.64," Within the code itself, the new calculations of the new numerator and the new denominator are the same as well. Right. We're still grabbing the numerators of self and other, the denominators of self and other multiplying those together."
3474.64," What's different is in the returns, right. What was the return type for the times method? A decimal, yeah, a float, exactly. What's the return type of my new method, the mole, a fraction, exactly."
3496.64," So yes, I am operating with fraction objects. So I'm expecting that the return type of this method, the star, double underscore, mole, is also a fraction object. So then I can just keep working with fraction objects throughout my code, not having to worry about whether this thing is now float or not."
3515.64," So how are we creating this fraction object? Well, just like we would create a regular fraction object up in the previous slides, right. So here, right. Here's an example of us creating a new fraction object, right."
3529.64," The numerator one denominator four. Well, same here. This method will return a new fraction object whose numerator is the thing that I just calculated the top and the denominator is the thing that I just calculated bottom."
3546.64, Does that make sense?
3550.64," Okay. So this one returns a float. This one returns a fraction. Let's run it. So a is fraction one over four, b is a fraction representing three over four. Good. Those are the numbers we've been working with. If we print a, the print statement says this is the fraction object one slash four, right."
3571.64," Now if I use the star operator between a and b, the thing before the star is kind of like the thing before the dot. It's the self. It gets mapped to self in my double underscore mole."
3584.64," And the thing after the star, right, the second parameter, so to speak, is the is the is the one parameter that my method takes, right."
3595.64," So this will create, will run the mole method behind the scenes, right. So Python when it sees that star asks, do you have a mole method implemented in your class fraction?"
3605.64," Because the thing before the star is a fraction object. Yes, we do. What is it return? Well, it does the multiplication. And in the end, the return of this method is this thing here, right."
3617.64," So I literally just made this, I guess copy this from the return using the numbers of a and b. So it creates a new fraction object whose numerator is three and denominator is 16."
3630.64," So C equals fraction parentheses three comma 16, basically just another fraction object."
3638.64," So now when I print C, it's going to use the STR method for a fraction object, right. Because C is a fraction object right there, right. That's exactly what C was."
3650.64, So this will also print the way we ask to print fraction objects numerator slash denominator three slash 16.
3659.64, Everyone okay so far.
3667.64," Okay, so the following lines are all equivalent. Okay. Using the shorthand notation, very nice, very Pythonic way to multiply two fractions together."
3680.64," But behind the scenes, this is just running a method. So of course, if you really want to, you can just use the same old way of calling a method, right."
3692.64," Thing before the dot dot method name parentheses parameter list. So here thing before the dot is a dot the name of my method, double underscore, multiple underscore parentheses, all of the parameter list except for the thing I'm calling it up."
3709.64," So those two are equivalent. And of course, last time I mentioned sort of a way to hopefully demystify running these methods where you know the self becomes this thing before the dot."
3721.64," You could call the method on the name of your data type, right. The type that you're currently creating fraction."
3730.64," So fraction is not an instance, right. A was an instance. It was an actual object that we created, but fraction is just the name of my class."
3738.64," So if you call the method on the name of your class, then Python expects the full parameter list, right. So something for self, something for other, something for whatever parameters you have."
3748.64," And so there we would explicitly pass in both a and b as part of my parameter list because the thing before the dot is not an object. So there's not, it doesn't map it to self."
3758.64," But I would never, ever, ever run line of code like this, this last one here, right. This is just for your information. It's non-piponic. It's just very verbose, right."
3771.64," And so these, these, these dunder methods help us abstract away a bunch of these details, right."
3779.64, So how annoying would it be to always use dot notation when we multiply an integer with another integer. Can you imagine constantly writing three dot double as for multiple four.
3790.64," That would be very bad code. It would take forever to read, right. And so we're abstracting away all the details for calling these methods into these nice little shorthand notations."
3800.64," And as I said, the short and notations exist for a lot of different operations. We saw print. You can do length comparisons like equality, even, you know, indexing into things."
3811.64," You can always, you can abstract all of those away into shorthand notations and behind the scenes, these methods will be run."
3822.64," So big idea, right. Exactly what I said. All these special operations that we've been using already behind the scenes, these methods get run. And these methods were written inside the class definition for the types that we've been using."
3838.64," Right. So when we index into a list, L square brackets, three or whatever, there's a method being called behind the scenes in the list class to grab the element at index three. I don't remember the dunder method name for that, but probably like double and square index, double and square. I don't know. But there is some method behind the scenes."
3859.64," All right, let's do a couple more things. Sorry. You can't ask Python, but you can look at the documentation. I think it's like in Python.org, there's a website that lists basically everything that you can, that's a dunder method. Yeah, under categories like end all the indexing type stuff, all the numerical type stuff. Yeah."
3887.64," Okay, so let's do one more thing. Let's say that we're working with fraction objects. And so the dunder methods that we're writing are now returning other fraction objects."
3900.64," So let's allow the user the opportunity to cast one of these fraction objects to a float. Just in case they would like to grab the, you know, the float value of three slash 60."
3914.64," That's a very reasonable thing they might want to do. So let's, you know, get ahead of them and add that as part of our class definition."
3922.64," So to cast things to a float in this particular case, the dunder method for that is double underscore float, double underscore."
3930.64," And all it's going to do is grab the numerator of self and divide it by the denominator of self. Right. So this will just do a division. Self dot, numbers, a number, self dot, denom is another number. It does the division and this returns a float."
3945.64," So here when we multiply C is equal to a times b, remember that C became a fraction object with numerator three and denominator 16. Right. Remember that."
3957.64," So then when we cast it to a float down here, Python says, hey, did you implement the dunder method, double underscore float, double underscore. Oh, yeah, you did. Let me just go ahead and do the thing that you want me to do inside it."
3971.64, And then we'll see if the three divides it by the 16 and it prints 0.1875.
3978.64," Okay, let's try it out a little bit more. So here I've got two fraction objects. One representing one over four, the other one representing two over three."
3990.64," So let's apply those two together. Again, this gives me a fraction object, right. Because it's running the mold under method and the mold under method gives me a fraction object with a new numerator and denominator."
4002.64," So when I print the return of that, when I print C, this prints the new numerator, which is two times one, divided by the new denominator, which is four times three."
4012.64, So prints 2 over 12. Does that look okay to you?
4018.64," I mean, it looks okay. But suppose you're doing calculations with a whole bunch of numbers. And at some point, you get to really big numerators and really big denominators."
4028.64, But then you stare at it long enough and realize that that big numerator divided by that big denominator is actually something like one over four.
4038.64," So this is not reduced, right, which is fine. Our code is not doing the reduction, but it would be nice to write a method that allows the user to reduce a fraction."
4054.64," That would be really nice. So can we fix this? Yes, we can. Otherwise, we wouldn't be here."
4060.64," So let's write this method to reduce a fraction object. It looks like a lot, but it's not. Trust me. It's just a bunch of if-else's."
4072.64," So the first part of it is a little helper function, not a method, right. Notice there's no self going on in this GCD function, right."
4082.64, This is just a regular function that I will use to help me get the greatest common divisor for the two parameters and D.
4094.64," Because when I have two numbers, right, if I want to reduce them, I find the greatest common divisors. And I'm going to divide the top and the bottom by that divisor. And that will help me reduce it."
4105.64," So this GCD function helps me find this greatest common divisor. Right. So here, I'm just defining the function. I'm not actually using it. And then I've got two, if and L if."
4119.64," So if the denominator is zero, something super weird. So I'm just going to return none, right, because having a fraction where the denominator zero, maybe something went wrong."
4128.64," Else, if the denominator is one, we don't need to do any reduction, right. No reducing is needed. So we just return the numerator."
4137.64," And else, I do have two actual numbers that I could maybe could potentially reduce. So let's just reduce them."
4147.64," The first line here runs this function, this helper function that I wrote on the numerator and denominator to grab the greatest common divisor."
4156.64," So, you know, if it's two over 12, it'll find two. Then the next line here takes the numerator and divides by that greatest common divisor and cast it to an int, right, because I want my numerator to be an int and my denominator to be an int."
4173.64," So take the numerator and divide by, for example, two. Same with the denominator. I'm going to take my denominator and divide by that same GCD I found."
4184.64, Casting to an int. So my new top and my new bottom will now be used to create a new fraction object. That is in reduced form.
4196.64," So one slash six for the example to 12. Right, so here it is. This is my previous example where I multiplied that thing that gave me two slash 12."
4209.64," And then if I do C dot reduce, Python will call the reduce method on C. So the object that's whose numerator is two and denominators 12. And then this will reduce it to one over six and we'll print call the STR method on an object of type fraction to give me one over six."
4231.64, Everyone okay. Yes.
4238.64," You could put it outside the reduce, but since it's being used specifically in the reduce, we'd like to just keep it within. Right, so it's not."
4248.64," If it doesn't need to be used by other things, we'll just keep it only to the sort of scope where it needs to exist. But it can be outside."
4263.64," So one thing is weird here, though. Right, this LF here. What is the type that gets returned from the else? You guys tell me, what's this type here that gets returned down in the else fraction? What is the type being returned in the LF?"
4287.64," Yes, an int. So if the denominator happens to be a one, this method reduce returns an integer. If it's not, it returns a fraction. So if at some point in the future, you're mixing, you know, you happen to reduce something that has a denominator of one, you're now working with integers."
4309.64," And then potentially you'd be doing further operations by mixing that with fraction object. So as an example here, I've got a fraction object, a, four over one, b, three over nine."
4322.64," Reducing a gives me a four. Fine, it's the integer four. And reducing b gives me one over three. It's a fraction one over three. Right."
4331.64," So the type, just to show you exactly, you know, that I'm not lying, the type of the a reduced is an int, right? That's what the code is doing. And the type of b reduced is a fraction."
4344.64," So then when we do the star operator between a, r and b are, Python's going to say, you're trying to multiply an int with a fraction. Did you ever tell me how to do that? No. Right."
4356.64," We told it how to multiply a fraction and another fraction, but not an int with a fraction. And so Python will fail here. Right."
4366.64, So one thing that you can do to fix it is to change this L of here. So let's have everything consistent. So I want you to do this change.
4378.64," Instead of returning self.num, return for me a fraction object representing the numerator. Right."
4387.64," All right. Does anyone know? Just a small change to, instead of returning self.num, what should I return?"
4394.64," How do I make a fraction object? Just invoke the name of fraction, right?"
4399.64, What's the numerator of this fraction object supposed to be? It's already there. Self.num. What's the denominator of this fraction object? Yeah. Exactly.
4411.64, So it just returns a fraction object whose numerator is self.num and denominators one. Exactly. Right.
4419.64," So now all the different cases, except for this randomly weird denominator being zero, right. In case that happens, something's gone wrong maybe."
4428.64," All the other cases are returning a fraction object, which is good, because now it's consistent. Right."
4439.64," Oh, yeah, exactly. So we did say we didn't want it to be five or one, but this is actually using the old STR method where we didn't do that check."
4448.64," So it will print five or one, but if we, you know, if we do the check, if self.dynamicwecal1, then returnsterself.num."
4457.64," Like if we add that, then it won't do that. Yeah. But this is just using the old STR method that doesn't do that nice formatting for us."
4468.64, Questions. Right. We've been working a lot with returning new objects of the same type that we're writing. Right. That's sort of a new thing today.
4482.64," Okay. So what's the purpose of these two lectures? Right. So hopefully it shows that it's very useful to,"
4497.64," to bundle data and behaviors together. Right. So the ultimate goal when we're writing programs is to write code that's modular, organized. Right."
4509.64," Because in the future, you might want to build upon this code. In the future, you might want to read this code to use it for something else."
4516.64," In the future, other people might want to read this code or use this code, this class that you wrote, to build more complex classes. Right."
4523.64," Like we use the coordinate class to build a circle class. Right. Other people might use your circle class to build, I don't know, a sphere class or something like that. Something more complicated."
4532.64," And so it's really nice to create these little data types that aren't organized, right. Modular. And so we're basically bundling together these data. Right."
4543.64, So what makes up your object and behaviors together. So we can use these objects in a nicely consistent way.
4549.64," So remember, back when we were learning about functions, right. The ideas of decomposition and abstraction were very important."
4557.64," Functions basically took a chunk of code and decompose them into one module that we could reuse many, many different places. Right."
4565.64, And we abstracted away the details of the function through doc string. So people didn't have to slog through a whole bunch of code to figure out what the function did. All they did was read the doc string and they knew exactly what we wanted.
4577.64," Now, object-oriented programming and Python classes have that same big decomposition and abstraction energy, right."
4585.64," They've got a bunch of modules that we're creating here where we're bundling together data and behaviors, right."
4591.64," So we can create a whole bunch of objects that behave in the exact same way, nicely consistent."
4597.64," So that we know that if I create a coordinate object here, it's going to have an x and a y value. And if I create another coordinate object, it's also going to have an x and a y value."
4605.64," It's not suddenly going to have an x, y and z value. Right. So creating these objects that work in a consistent way is very, is a very,"
4614.64," you know, decomposition and abstraction are working with the ideas of decomposition and abstraction just like functions did."
4625.64," Okay. So next lecture, we will be starting on, we'll do a little bit more of these classes and then we'll start on inheritance. So having parents, the objects that we created."
4636.64, All right.
