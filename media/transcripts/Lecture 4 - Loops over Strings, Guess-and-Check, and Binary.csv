start,duration,text
0.0,13.68," Okay, so let's get started."
13.68,4.720000000000002, Today we will be continuing talking a little bit about loops and seeing some other
18.400000000000002,2.4399999999999977, couple of nuances of loops.
20.84,4.48," And then we'll get started on our first algorithm, the guess and check algorithm."
25.32,2.84, And then towards the end we're going to start talking about binary numbers in advance
28.16,3.280000000000001, of seeing our next algorithm.
31.44,3.84, So let's do a quick recap of what we learned last time and then we'll do a little coding
35.28,1.9600000000000009, example and then we'll move on.
37.24,3.519999999999996," So we saw last lecture some looping mechanisms, right?"
40.76,2.8000000000000043, We saw wild loops and four loops.
43.56,4.640000000000001, They're both a way for us to control what happens in the code and specifically they're
48.2,5.200000000000003," a way for us to repeat certain lines in the code sort of automatically, so to speak."
53.4,4.799999999999997, So with wild loops the lines of code were repeated as long as some condition held and
58.199999999999996,6.119999999999997, with four loops the lines of code were repeated for some sequence of values.
64.32,5.840000000000003," And the sequence of values was something that we decided it was numerical, that's what"
70.16,1.0, we saw last lecture.
71.16,4.240000000000009, Today we're going to see that the sequence of values can actually be non-numerical as
75.4,2.3999999999999915, well.
77.8,9.840000000000003," So both of those loop types I guess had ended at certain times, right?"
87.64,5.8799999999999955, So the wild loop ended when the condition became false and the four loop ended when we've
93.52,2.799999999999997, exhausted our sequence of values.
96.32,4.6000000000000085, But oftentimes we want to write programs where we break out of the loop prematurely.
100.92,3.9599999999999937, We don't want the wild loop condition to become false and we don't want to exhaust our
104.88,2.5999999999999943, entire set of values of the four loop.
107.48,5.400000000000006, So in order to exit a loop before the natural end comes we can use this thing called a
112.88000000000001,2.039999999999992, break statement.
114.92,5.88000000000001, And the break statement allows us to exit the loop and the loop at exits is going to be
120.80000000000001,3.1599999999999966, the one that immediately surrounds the break statement.
123.96000000000001,5.47999999999999," So here's a little example of a nested, two nested wild loop, so one wild loop and then"
129.44,2.200000000000017, one nested one inside it.
131.64,7.0, The outer one is going to run whenever condition one holds and the inner one runs whenever
138.64,3.039999999999992, condition two holds.
141.67999999999998,5.480000000000018," Now expression A will evaluate when both condition one and condition two hold, right?"
147.16,3.519999999999982, So we enter the first wild loop and we enter the second wild loop.
150.67999999999998,2.640000000000015, Both of those conditions have to be true.
153.32,7.359999999999985," But Python as soon as it sees this break statement, Python will immediately exit the loop that"
160.68,1.2800000000000011, surrounds that break statement.
161.96,5.0800000000000125," So the loop that surrounds the break statement is the one that has condition two, right?"
167.04000000000002,3.3999999999999773, The condition one loop will keep going.
170.44,4.800000000000011, So as soon as Python sees this break statement it's going to immediately stop running the
175.24,1.0, wild loop.
176.24,4.199999999999989," It's not even going to go back up and check the condition two, which means that expression"
180.44,2.5600000000000023, B will actually never get evaluated.
183.0,1.4000000000000057, So this is terrible code.
184.4,4.759999999999991," We don't want to write code like this because expression B will never be run, right?"
189.16,4.400000000000006, But this is just to show you the impact that a break statement would have.
193.56,4.240000000000009, And expression C will then be evaluated whenever condition one is true.
197.8,5.839999999999975," Now condition two may or may not have been true along the way, but expression C will evaluate"
203.64,2.5600000000000023," only when condition one is true, right?"
206.2,4.319999999999993, Condition two would have stopped being true and then we're going at the same indentation
210.51999999999998,3.0, level as this inner wild loop.
213.52,7.840000000000003, It only evaluates the one time it gets A1s and then because the break is there.
221.36,1.0, Exactly.
222.36,1.0," Yeah, that's a great point."
223.36,3.719999999999999, So it only evaluates this expression A one time because right after it evaluates that
227.08,4.1200000000000045, it sees the break and then we immediately exit the wild loop and we're done.
231.20000000000002,1.6399999999999864, That is a great observation.
232.84,1.0, Yeah.
233.84,3.200000000000017, And that's what this code will basically show.
237.04000000000002,4.039999999999992, So here it is us doing the break statement sort of in the same structures on the previous
241.08,2.1200000000000045, slide.
243.20000000000002,4.079999999999984, And what we're going to do is actually just run the Python tutor for this code just to
247.28,5.0, give you some more practice running the Python tutor.
252.28,2.920000000000016, So this is the same code as on the previous slide.
255.20000000000002,3.4799999999999898, I've got a for loop that goes through some sequence of values.
258.68,7.1200000000000045, Can anyone tell me what are the sequence of values this for loop will loop over?
265.8,6.079999999999984," 5, 7, 9 and we stop, right?"
271.88,4.199999999999989, Because 11 is end but we go up to but not including and minus 1.
276.08,2.400000000000034," So 5, 7, 9 are the only three values."
278.48,3.8000000000000114, We would potentially loop over.
282.28000000000003,2.9599999999999795," So hit next, we initialize my sum to 0."
285.24,4.240000000000009," So in our minds we kind of think about the fact that we're going to loop through, make"
289.48,2.759999999999991," this loop variable be 5, 7, 9."
292.24,3.5600000000000023, So the first time through the loop I will be 5.
295.8,4.160000000000025, We're going to add I which is currently 5 to my sum.
299.96000000000004,4.0, So 5 plus 0 makes my sum 5.
303.96000000000004,2.319999999999993, And then we immediately see the break.
306.28000000000003,1.0, Right?
307.28000000000003,5.560000000000002, Because if my sum equals 5 is true so we go inside and we immediately see the break statement.
312.84000000000003,8.239999999999952, This line will never get executed so we're never going to increment my sum by 1.
321.08,3.7200000000000273, So the break immediately breaks out of our loop.
324.8,2.319999999999993," Now the if statement is not a loop, right?"
327.12,1.0, It's a conditional.
328.12,2.2799999999999727, So the loop we break out of is the for loop.
330.4,3.8000000000000114, And then there's no other loop surrounding it so then the program is basically done and
334.2,1.1999999999999886, we print 5.
335.4,1.0, Okay.
336.4,4.399999999999977," Again, bad code."
340.79999999999995,5.0, We would never write code like this but this is just to show you exactly what happens with
345.79999999999995,1.6400000000000432, the break statement.
347.44,5.9599999999999795, So there's the code block for the for loop and this is the code block for the if statement.
353.4,2.6000000000000227," And the break breaks out of our loop, right?"
356.0,6.199999999999989," Which is the lighter purple, not the if statement."
362.2,1.0, Okay.
363.2,2.240000000000009, So let's have you write a little bit of code.
365.44,6.0400000000000205, And this is sort of maybe a little practice with just loops in general that we saw last
371.48,1.0, lecture.
372.48,5.0, There's no break really in this particular program here just a little bit of practice.
377.48,4.519999999999982, So what I want you to do is to write code that basically has a for loop running through
382.0,1.0, this range.
383.0,7.759999999999991," So for I in pick one of these, I want you to write code within that for loop that counts"
390.76,4.080000000000041," how many new how many even numbers are in that range, right?"
394.84000000000003,1.759999999999991, So including the zero.
396.6,6.279999999999973," So for range five, your counter should basically pick up on the fact that zero is even, two"
402.88,3.9600000000000364, is even and four is even and then that's it.
406.84000000000003,5.839999999999975, So it should print three.
412.68,4.439999999999998, So here is the you try it and set the Python file for today.
417.12,6.840000000000032, And I've already started you off with this for I in range five as the first one.
423.96,7.0, And I'll give you a couple minutes to just write the code in here.
430.96,3.319999999999993, Okay.
434.28,6.759999999999991, Would anyone like to start us off with some code?
441.04,7.0, Yeah.
448.04,9.0, Yep.
457.04,6.759999999999991," So this line of code is going to take our eye, right?"
463.8,5.319999999999993," So in fact, what we could do to remind ourselves what I is and this is very helpful for quizzes"
469.12,1.2000000000000455, as well.
470.32,6.920000000000016," We can write a little comment here that says I is zero, one, two, three, four."
477.24,4.9599999999999795," Just so we don't have to remember this fact, we can just always look here and know what"
482.2,2.6399999999999864, I is going to be.
484.84,5.640000000000043," And then this line of code, absolutely correct, is going to take I and grab the remainder"
490.48,4.199999999999989, when I is divided by two.
494.68,5.360000000000014," And if the remainder is zero, that means that the number is even."
500.04,6.039999999999964, And then what do we do inside here?
506.08,7.880000000000052," So when this is true, when it's even, how do we keep track of whether or how many times"
513.96,3.2799999999999727, this condition occurs?
517.24,3.0, Yeah.
521.24,2.32000000000005," Yes, exactly."
523.5600000000001,1.1599999999999682, Should we create a variable?
524.72,1.0, Yes we can.
525.72,3.6399999999999864, So let's call it even numbs.
529.36,3.7200000000000273," And we'll probably want to increment it by one, right?"
533.08,1.5599999999999454, Because here's another number that's even.
534.64,2.6399999999999864, So even numbs plus equals one.
537.28,7.080000000000041," And then let's remember to initialize it right before our loop, right?"
544.36,3.8799999999999955," So initially before we even start our loop, we have zero even numbers."
548.24,5.519999999999982," And then each time through our loop, we see one that's perfectly divisible by two."
553.76,6.639999999999986, We're going to increment this little counter by one.
560.4,2.160000000000082, And not the same variable.
562.5600000000001,6.319999999999936," Oh yeah, not the same variable, thank you, even numbs."
568.88,5.1200000000000045," And the mental model you should have, sort of at this point or beginning is just the"
574.0,3.6399999999999864, fact that these three lines solve our problem.
577.64,3.1200000000000045," It does the automatic counting for us, right?"
580.76,6.399999999999977," Because I will take on zero than one, then two, then three, and then four automatically"
587.16,3.1200000000000045, as the loop goes through the sequence of values.
590.28,4.399999999999977," And so at the end of the loop, so sort of at the same indentation level as the four loop,"
594.68,9.440000000000055, all we need to do is print how many of these numbers we have.
604.12,2.919999999999959," So if we run it, it'll print three."
607.04,4.32000000000005," And if we change this to ten, it'll print probably six, right?"
611.36,2.2799999999999727, Because it counts the zero.
613.64,3.0, Right.
616.64,3.759999999999991," Questions about, yeah, please."
620.4,4.919999999999959, Does it actually look out for the sum two instead of three?
625.3199999999999,6.2000000000000455," So if you're under counting, did you initialize even numbs to something else?"
631.52,5.480000000000018," Or maybe this is not incrementing right, or maybe the range is different?"
637.0,7.0, I'll try to read the same question.
644.0,2.0, Yeah.
646.0,3.0, It worked.
649.0,3.0, Awesome.
652.0,3.0, Okay.
655.0,5.0, So iterating through using four loops to iterate through sequence of values is pretty useful.
660.0,3.0, Let's take another look here at this particular program.
663.0,7.0," So this program is this set of code, this code, and this code actually end up doing the same thing."
670.0,3.0, But let's look at the top one for now.
673.0,6.0," So this is a program that takes in a string s as sort of an input, so to speak."
679.0,5.0," It iterates through the numbers zero to the length of s, right?"
684.0,8.0," So for index in range, len s is basically going to say for index in range 13,"
692.0,4.0," however many letters this string has, right?"
696.0,6.0," D E M O space, all those letters, there's probably 13 of them or something like that."
702.0,6.0," So this line of code here is going to have our index take on the values zero through 13,"
708.0,4.0," representing the index in s, right?"
712.0,6.0," So the lower case D will be at index zero, the lower case E will be at index one, and so on."
718.0,7.0," So with this index in hand, the next bit of code, if s square bracket index, equal i,"
725.0,8.0," will check for me if this particular character is an i, or that particular character is a u."
733.0,5.0," And every time that happens, I'm going to have this print out, print out to the screen."
738.0,9.0," There's an i or u. So inside my code here, this is the first one."
747.0,7.0," And I run it, it's going to print out that sentence twice, because there's only two eyes are used in here."
754.0,7.0," And if it repeats, it'll print out twice. So there's one u and one i."
761.0,5.0, But this code can actually be written a lot simpler.
766.0,8.0," Notice it took me a little bit of a while to explain it, and probably at first glance it would take you a little bit of time to figure out what it's doing."
774.0,6.0," And that's because we're actually relying on the index as kind of a middleman, right?"
780.0,11.0," We're iterating our for loop through the index, and then we're indexing into that index variable to grab the particular letter."
791.0,8.0," It turns out that with for loops, right, I told you you can iterate over any sequence of values, not just numbers."
799.0,6.0," And remember that strings are actually just a sequence of characters, right? Case-sensitive characters."
805.0,8.0," So in Python, we can actually write code like this. So the middle box right here."
813.0,5.0, It has our for loop iterating through each character in the string directly.
818.0,8.0," So no longer are we looking at the index, 0 through 12, but we're looking at the letter directly."
826.0,12.0," So our loop variable, which I called char, but you can call whatever you'd like, is now going to take on values that are the letters themselves, one at a time."
838.0,9.0," So the first time through the loop, char will be lowercase d, the next time through the loop, char will be lowercase e, the next time char will be lowercase m, and so on."
847.0,16.0," And so now we've got the sequence of values, that's the letters directly. So when we check if the letter is an i or u, all I need to do is check if that character, right, char, my variable, is equivalent to i or equivalent to you."
863.0,13.0," And it's going to be the same, and it's exactly the same code. So this is the one we had before, and this is the one I just went through, and again it prints out that sentence twice, right, because it's the same starting string."
877.0,8.0," So the sequence of values now is our characters direct, right, it's the letters directly, it's not the index itself."
885.0,12.0," And it turns out there's actually a much more python way to write the code, this middle box down here. So in the bottom box, the only part that I've changed is the if statement."
898.0,11.0," And I'm using this in keyword to test whether the character that I have in hand, lowercase d, lowercase e, lowercase m, and so on, is in this sequence of characters, i or u."
909.0,10.0," And for this case, it's not so important, right, because in the middle box, we could do if char is equal to i or char is equal to u, which is fine."
919.0,12.0," But if we were, if we wanted to test if the character is one of the digits zero through nine, this if or or or would become a really long line, right."
931.0,13.0," And so all we can do is, you know, if char is in some particular sequence of characters, python will automatically turn that into that longer if it's this or if it's this or if it's this or if it's this or if it's this and so on."
945.0,10.0," Okay, so the big idea here with four loops is that yes, we're iterating through a sequence of values, but we're not limited to just numbers."
955.0,12.0," And that's the cool thing about four loops, you can iterate through characters directly, and we're going to see later on, we can iterate through lists of numbers, lists of strings and a whole bunch of other things."
968.0,9.0," So let's write a slightly more complex program. This was version 0.01 of the true leader robots, you see up in the corner there that I wrote."
977.0,11.0," The robots are not mine, but the code is so here's a little bit of code that kind of puts together iterating through strings directly and iterating through numbers directly."
988.0,10.0," So let me show you what this program is actually doing, and then we'll go over the code. Somebody give me some noun you're really excited about."
998.0,2.0, What is that?
1000.0,3.0, What?
1003.0,6.0, Never mind. Give me something else that I know.
1009.0,5.0," What is it? Pineapples. Okay, pineapples."
1015.0,8.0," Okay, so it's going to cheer for us about pineapples, and let's say we're enthusiastic level eight about pineapples."
1023.0,7.0," Alright, so this is my cheerleader program, so I typed in a word, and I typed in an enthusiasm level for pineapples."
1030.0,10.0," And then all it does is, and notice the repetition, which computers are really awesome for. Give me a p, p, give me an i, i, give me an n, and so on."
1040.0,9.0," Right? What does that spell, and then it does pineapples with three exclamation marks eight times, because that's how enthusiastic I'm about pineapples."
1049.0,14.0," Alright, so let's look at the code that actually does this. Notice there's two parts to it, right? There's the part that does the spelling, and then there's the part that does repeating the word some number of times."
1063.0,9.0," So these are two separate loops. The spelling is up here, this for loop here, and then repeating some number of times is down here."
1072.0,11.0," Okay, so the part where we do the spelling has a for loop that iterates through the letters in the word directly. Right?"
1083.0,11.0," I'm not doing anything special with these letters, so I can just iterate through the letters directly, so for w in word, where word is the input that I grabbed from the user."
1094.0,10.0," W is a loop variable, that's going to first be p, then i, then n, then e, then a, and so on. Right?"
1104.0,14.0," And then I have an if else here, and if you look carefully, the only difference between the if, what we do inside the if and what we do inside the else is whether we type in on, and then a letter, or a, and then the letter. Right?"
1118.0,7.0," Because some letters make sense to say give me on a, as opposed to give me a, a, it just doesn't sound right in English."
1125.0,10.0," The letters where it makes sense to do on are defined up here, so notice they're just defined as a really long string."
1135.0,19.0," And so the if statement uses that in keyword we saw in the slide, right? It says if w, so if that particular character is one of these is in this sequence of characters, then print give me on, and that particular character."
1154.0,10.0," And otherwise it's, you know, it's not one of these letters where it makes sense to say on, so then you just print give me a, and then that letter."
1164.0,12.0," Here I just rewrote these two print statements using f strings, which we talked about back in lecture two, just to show you how you could, how you could rewrite it with f strings."
1177.0,14.0," But it can be done both ways. Okay, so at the end of this we've done the spelling, and then we have a print statement that says what is that spell, and then the last part is to repeat that word, some n number of times, whatever the user told us."
1191.0,12.0," So I save that number of times in a variable called times, and then all I do here is I have a nice little for loop that goes through however many, how much, how much that number is, right?"
1203.0,6.0, So range times means it's going to be zero all the way up through and including times minus one.
1209.0,9.0," That's a total of eight, eight times in this particular case that it loops through, and then all we do is print the word with three exclamation marks."
1218.0,12.0," Notice that this print statement that's inside the bottom for loop is not actually doing anything with our loop variable, right? Our loop variable here is I, but we're not doing anything with it."
1230.0,13.0," And that's totally fine, right? Because all we're using in the times in the loop variable in this particular case is to do this action some number of times, right? We don't always have to do something with that loop variable."
1243.0,5.0, Any questions about this code?
1248.0,5.0, Yeah. Could you also have you if statements for the prints?
1253.0,7.0," Could you use if statements for the prints, which one which prints these ones? How so?"
1260.0,8.0, To evaluate the w's instead of having to come to cap me?
1268.0,15.0," Oh, F strings. Yeah, we could have done it like this. Yeah, so this is how it is F, and then we do the characters themselves inside the curly brackets. Yeah, oh, no, it's okay. It's okay. Yeah, there's a question. Yeah."
1283.0,16.0," How that last four reports since we're not actually doing it on the I. Yeah, so the last four loop is still going to iterate through times times, right? And the loop variable each time through the loop will be zero than one, then two, then three."
1299.0,12.0," We're not doing anything with the I, right? The stuff that's indented is going to get done, but we're just not using the fact that I is zero or one or two at all."
1311.0,7.0," Yeah, it increments itself automatically. We're just not using it. Yeah, exactly."
1318.0,7.0," Okay. And that's what I said. Okay, so let's have you write a little bit of code."
1325.0,8.0," So let's assume you're going to be given a string of lowercase letters. Right? So we're not going to bother uppercase. Lowercase, just assume you're given lowercase letters."
1333.0,19.0," It's stored in a variable S. So as an example, S is equal to ABCA. I would like you to write some code that counts how many unique letters are in this string. Right? So notice A occurs twice, but the count that your code should do for this particular, in this particular string should just be three, right?"
1352.0,8.0," We don't want to double count the A. So there are three unique letters in ABCA. They are A, B, and C."
1360.0,17.0, So I do have a little hint. It involves the use of an extra variable as these programs usually go. Try to think about having this extra variable be a string that contains everything you've seen so far.
1377.0,10.0," So as soon as you see a letter that you haven't seen before, add it to this string variable that you've marking that you've now seen this letter."
1387.0,18.0," And then use this seen variable to write the rest of it. So as you go through your letters, make sure that you're going to check whether you've seen it already before recounting it."
1405.0,11.0," So as usual, it's in here, around line 76. This is the code to do it. So I'll give you a couple minutes and then we can write it together."
1416.0,13.0," Okay. So let me just work through it. And this is something that I think is pretty useful in a quiz situation. It's just writing things on paper first, just because it's a no programming computer science class."
1429.0,13.0, So it's really helpful to just kind of put some ideas down on paper. So the way I would go about this problem is clearly I have to touch each character right in the string S.
1442.0,11.0," So already for me that's I need to have a loop. So as I'm looking at each character, I'm going to keep track of it. So if it's not something I haven't seen."
1453.0,10.0," So if it's something I haven't seen before, what I want to do is say, okay, I have now seen this a. So I'm going to add it to a seen variable."
1463.0,8.0," And then I'm going to increment a counter, right? I've seen it once. So count maybe equals one."
1471.0,11.0," The next time I look at the next letter, I'm going to say, what's it be? Have I seen it before? No. Let me add it to my seen variable and increment my count."
1482.0,9.0," Next time I'm going to look at the letter C. I have, have I seen it before? No, I'm going to add it to my scene. And then I'm going to increment my count."
1491.0,14.0," And then the last time I'm going to look at this letter A, I'm going to say, is it already in my scene? Yeah. So I'm not going to do anything with this one, right? So when I see a letter, I've, that's already seen that I've already added to my seen variable."
1505.0,8.0," I basically do nothing in my code, right? So the most of the work happens when I encounter something I have never seen before."
1513.0,12.0, So does anyone have some starter code or something we can write? We don't have to write it perfectly top to bottom. We can write pieces here and there.
1525.0,6.0, Yep.
1531.0,27.0," So if you want to say if it's not in scene, we can just say if char or car, however you pronounce it, is not in scene."
1558.0,13.0," So that takes the inverse of true or false, whatever this is, right? Because in scene will either be true or false and not that will be false or true."
1571.0,5.0, So that's perfect. Yeah.
1576.0,20.0," So we can use not when we're dealing with Booleans, right? So something that expression that evaluates to true or false, that's when we use not and then not equal. So the exclamation mark equal is used with other expressions when we're testing for equality, right?"
1596.0,12.0," Like three not equal to or like a not equal b or something like that, right? So things that are that could be numerical, not necessarily just true and false."
1608.0,9.0," Okay. So if char is not in scene, so if I haven't seen it before, what do I want to do?"
1617.0,7.0, Yep.
1624.0,17.0," Yep. So we can append the character that we just looked at to our scene list, right? Just as we had done incrementally here."
1641.0,6.0, So that takes care of adding the character one by one if we haven't seen it to our scene.
1647.0,13.0," Good. Anything else we want to do or we can even test it out like this, right? So we can print scene each time through our loop."
1660.0,10.0," Right? So first it's a, then it's a b, then it's a b c, and then the last time it should still be a b c, and it is."
1670.0,14.0," Okay. And the last step is to just do what the problem asks us to do, which is to print how many characters are, how many unique characters are in this list or in this string."
1684.0,5.0, Yep.
1689.0,8.0, Yep.
1697.0,13.0," Yep. We can have a counter that is initially zero before the loop, and every time we add a new thing to our scene, string, we can increment our counter."
1710.0,7.0," And then that takes care of the bulk of the work, right? This does all the counting, all the adding to the unique scene."
1717.0,9.0," And so at the end of the loop, we have this number in hand, and then we can just print it. So with this particular case, it's three."
1726.0,6.0," If we add more a's in random spots, it's still going to be three. Right? Yeah."
1732.0,8.0," Out of the, yeah. So now that we have some code that, that basically, that works really well, we can make improvements to it."
1740.0,14.0," So one improvement that suggests it is, instead of keeping a counter variable, we can actually just recognize the fact that the length of our scene is just all the unique characters we've seen already. Right?"
1754.0,14.0," Because when we double up on something, we don't read it. So all we can do to, to print out the number of unique characters is to just say, I'm going to print out the length of scene."
1768.0,12.0, Okay? And now there's no need to increment any sort of counter. And so that still gives us three.
1780.0,6.0, Questions about this code? Does it make sense?
1787.0,16.0," Okay. Notice there's no else, right? We just have a nice little if there's no else because there's nothing to do when we've already seen the character. So we could have else pass and pass is just some, it's just a keyword in Python."
1803.0,8.0," You see it's turned blue because it's a keyword in Python. It just means do nothing. Right? So we wouldn't write this, obviously."
1812.0,6.0," That's that that you know if we had an else case that that's what we do, we just do nothing."
1818.0,5.0, Okay. Other questions about the code?
1823.0,8.0, All right.
1831.0,7.0, Say again. Why are we printing the length of scene here?
1838.0,17.0," So we're printing the length of scene because because we see that whenever we add a unique character to this scene variable, it's one that we haven't actually seen before."
1856.0,13.0," And so the only things I'm adding to my scene are things that are new. And so even as I was going through manually here, I said I've seen the A, I've seen the B, I've seen the C, I added them one by one."
1869.0,15.0," And then when I saw the duplicate A, I didn't add it to my here, right? And so basically the scene already contains all the unique characters in my list, in my in my strict original string."
1886.0,5.0, Yeah.
1891.0,9.0," Okay. So quick summary of what we've seen so far before we start looking at our first algorithm. So we've seen objects, right? That's how we write Python, Python programs."
1900.0,5.0, We manipulate objects by saving them to variables. So the values are more easily accessible.
1905.0,11.0," We have expressions that evaluate to different things, integers, floats, bullions, things like that. We added branching as a way to control as a control flow mechanism to our program, right?"
1916.0,7.0," It says, hey Python, either evaluate this set of statements or this other set of statements depending on whether this condition is true."
1923.0,15.0," And then we added the last mechanism for control flow, the looping mechanism that said, you know, either loop or repeat this code while some condition is true or loop this code for this sequence of values."
1938.0,11.0," Okay. So really with that in hand, we've basically have a really nice toolbox of things that we can use to write interesting programs. That's kind of all we need."
1949.0,10.0," But this is not the end of the class. We're going to look at other things that will make our code neater, more readable. We can write more of it more efficiently, things like that."
1959.0,7.0," But really if you want to just start writing the algorithms, this is all we need in terms of Python syntax."
1966.0,8.0, So the first thing we're going to apply this knowledge to is our very first algorithm called the guess and check algorithm.
1974.0,5.0, So another word for the guess and check algorithm is exhaustive enumeration.
1979.0,8.0, So the idea here is that we're given a problem. We can guess a value for a solution.
1987.0,6.0, Okay. We'll just do a guess and then we'll test whether this guess is correct. Does it solve our problem?
1993.0,13.0," If it does, we're done. We found a solution to our problem. If it doesn't solve our problem, we're just going to keep making guesses until we've exhausted our set of possible guesses."
2006.0,6.0, So either we find a solution or we say we weren't able to find a solution to this problem.
2012.0,9.0," Doesn't mean that one doesn't exist. It just means that with guess and check and exhaustively enumerating all these possible values, we were not able to find a solution."
2021.0,7.0," So in terms of a flow chart, the way this looks is we have an initial guess. We ask, is this guess correct? If it is, we're done."
2028.0,4.0," And if it's not, we're going to choose a next guess."
2032.0,6.0, So let's look at finding the root of a perfect square.
2038.0,10.0, And that's our problem. And we're going to say either we found the root of this perfect square or we say this is not a perfect square.
2049.0,12.0," So with guess and check, we can say, well, what if we want to find whether seven is a perfect square? If it is, what is its root? And if it's not, say that it's not a perfect square."
2061.0,7.0," Well, we can make an initial guess. Six, that's not the right solution. We can make another guess nine. That's not the right solution."
2068.0,5.0, We can make another guess two. That's not the right solution. We can make a guess zero. That's obviously not the right solution.
2074.0,10.0," We can keep guessing randomly like this, but it's not going to be very efficient. What we want to do is use the power of computers and computers work with these sort of patterns in hand."
2084.0,4.0," Remember range starting from zero, following a pattern, going up to some number."
2088.0,9.0," So the idea is to be systematic. And then we can really harness the power of programming and computers being able to do things really, really quickly for us."
2098.0,10.0," So for that same problem, finding out whether a number x is a perfect square, let's be systematic and start with a guess of zero."
2108.0,8.0, Two cases. The number we're trying to find the square root of is a perfect square. Let's say four.
2116.0,14.0," We're going to start with a guess of zero, zero squared, solve our problem, no increment. Does one squared solve our problem, no increment. Does two squared solve our problem? Yes, we are done."
2130.0,10.0, What if x is not a perfect square? Let's say ten. Let's use the same systematic approach of guess and check.
2140.0,10.0," We're going to need to add a little bit of algebra, though, because if we don't, we're at risk of potentially doing something that will lead to an infinite loop."
2150.0,11.0," So the algebra we need to add to solve our problem is to say if we're looking at a number that's not a perfect square, we need to find a way to stop."
2161.0,8.0, We don't want to guess something that's infinite. This is guess and check. So we need an exhaustive set of potential solutions.
2169.0,9.0, So we're going to use algebra and we're going to say we're going to stop as soon as our guess squared becomes bigger than x.
2178.0,8.0," So we're going to start guessing zero than one, then two, then three, then four. And at some point that number, that guess squared will be bigger than x."
2186.0,4.0, And we know we can stop because numbers bigger than that will definitely be bigger than x.
2191.0,10.0," So our first guess would be zero squared, obviously less than ten. One squared less than ten. Two squared less than ten. Three squared less than ten, right? That's nine."
2201.0,15.0, Four squared becomes sixteen. And we say this is where we stop. And we have not found a square root for ten. Right? So ten is not a perfect square.
2216.0,3.0, Does that make sense? Is that all right?
2219.0,10.0," So our exhaustive set of potential solutions is zero through four because that brought us closest to ten. And at four, we've gone over ten."
2229.0,9.0," And we don't need to check five, six, seven because there's definitely not going to be those values squared will definitely be bigger than ten."
2238.0,4.0, So this is the code that solves that problem.
2242.0,9.0, We get input from the user. So what number do you want to find whether it's a perfect square or not? And what is it if it is a perfect square?
2251.0,8.0, We have a while loop that checks one condition. Right? That's our stopping condition here.
2260.0,13.0," We're going to iterate through the loop when guess squared is less than x. Right? So on that number line, we're going to keep incrementing by one as long as our square is less than x."
2273.0,4.0, So that's this while loop here.
2277.0,6.0, And what we're doing inside the loop is incrementing our guess. Right? Guess equals guess plus one.
2283.0,8.0," And then at some point, if we haven't found a perfect square or if we have found a perfect square, this condition becomes false. Right?"
2291.0,9.0, Because this is false when we have the opposite of this less than sign. So guess squared becomes greater than or equal to x.
2300.0,8.0, Now that's two very different things. Right? Guess squared greater than x means we haven't found this perfect square.
2308.0,12.0, But guess squared is equal to x means we have found a perfect square. Right? And both of those cases trigger us to leave the while loop.
2320.0,7.0," So then right after the while loop, we need to have an if else. The if else checks for one of those two cases."
2327.0,8.0, So the if guess squared is equivalent to x means that we exited the while loop because we found that it was a perfect square.
2335.0,10.0," So like four for example, right? If x was four when we hit two, that while loop becomes false and we exited because four was a perfect square."
2345.0,13.0, But the 10 for example would fall within the else clause here. Right? Because we have exited the loop because guess squared for or squared 16 was greater than 10.
2358.0,7.0, And so that's then we would print x is not a perfect square.
2365.0,10.0," Okay. So this works for many different values as big as you'd like, but it doesn't work for it doesn't work for negative values."
2375.0,6.0, And the reason it doesn't work for negative values is because the loop never actually enters in the first place.
2381.0,12.0," So for example, if we look at this whether negative two is a perfect square, we're going to start with guess is zero just because that's how we implemented the algorithm."
2393.0,6.0," Right? On the previous slide, it says guess is equal to zero right at the top."
2399.0,12.0," And so guess is zero we say is zero squared less than x? No, zero is not less than negative two and that while loop never even enters at all."
2411.0,12.0," Which is fine, right? Because negative two does not or negative four you know negative numbers are not perfect squares unless we're talking about imagining numbers, but we're not in this particular case."
2423.0,8.0," However, we might want to handle the case when the user gives us a negative number. Maybe they accidentally typed in the negative sign or something like that."
2431.0,8.0, So we can actually take care of that case by adding a little bit of extra code around what we already wrote.
2439.0,8.0, So the stuff that's boxed in red is the extra code we write. Everything else is exactly the same as two slides ago.
2447.0,10.0, So the only thing we want to do when we encounter a negative number is flag it using a new variable that's either true or false.
2457.0,8.0, And then at the end we can handle that flag. So if it's true we do something and if it's false we do something else.
2465.0,10.0," So in this particular case we've got a negative flag initially false which means that we're going to initially assume the user gives us a positive value, right?"
2475.0,2.0, So negative flag equals false.
2477.0,11.0, We get input from the user and then we check if the user gave us a negative number. So if the x is less than zero then we're going to change the value of this flag.
2488.0,5.0, So the flag equals to true. So we're going to change the value from false to true.
2493.0,6.0," And then the rest of it is the same, right? This is all the same as what we had two slides ago."
2499.0,6.0, Except that at the end we're going to check to see if the user actually gave us a negative number.
2505.0,8.0, We can check with them did you actually mean the positive version of that number or something like that?
2513.0,13.0, And so in code the way this looks is follows. So if we run it and we give it four obviously it tells us it's a perfect square and what its square root is.
2526.0,6.0, Nine works ten. It says it's not a perfect square.
2532.0,10.0, And then when we give it a negative number square or not it just tells us negative four is not a perfect square and then it says just checking the do you mean four.
2542.0,7.0, So does this extra print statement when the number was negative?
2549.0,1.0," Yeah, question."
2550.0,5.0, I don't quite get to explain this but false and then the other one.
2555.0,8.0," Yeah, so I can explain that again. So the negative flag equals false is just a variable, right? I just called it neg flag."
2563.0,5.0, It's a variable I initialize to false just to say hey the number I'm going to assume is not negative.
2568.0,6.0, And then we only flag it to we only change its value to true if the number was negative.
2574.0,6.0, So in fact we could have just had a little if else here. Right. So we get the act we don't have this line up here.
2580.0,7.0, We have x is equal to int and then we say if x is less than zero neg flag equals true else neg flag equals false.
2587.0,6.0, We could have done that as well.
2593.0,4.0," Okay, so the big idea with guess and check is we can't test an infinite number of values."
2597.0,5.0, We have to stop at some point. Right.
2602.0,5.0, So now we've been working with the code that that looks like something on the left side right.
2607.0,2.0, We've been using wild loops.
2609.0,7.0, But we've seen that we can actually write very efficient code using for loops as well.
2616.0,6.0, And in fact the guess and check method may be intuitively lend itself better to a for loop than a wild loop right.
2622.0,5.0, Because we're trying to iterate through an exhaustive set of values right.
2627.0,3.0, So we're going to see the number zero through some number right.
2630.0,4.0, And so maybe a for loop is a better way to write such a guess and check algorithm.
2634.0,3.0, And we're going to see how to rewrite that in a little bit.
2637.0,7.0, But in terms of a flow chart the way the for loop would go is we sequentially go through all the possible values when we've exhausted all the values.
2644.0,2.0, We say we didn't find a solution.
2646.0,7.0, And otherwise the for loop just automatically grabs for us the next value in the sequence.
2653.0,2.0, So let's have you work on this for a little bit.
2655.0,3.0, I want you to hard code for me a number as a secret number.
2658.0,2.0, This is kind of what we did last lecture.
2660.0,4.0," So secret equals, you know, seven, five, whatever you'd like it to be."
2664.0,7.0, And then I want you to write some code that goes through all of these numbers from one to ten inclusive let's say.
2671.0,4.0, And prints that it found the secret number.
2675.0,6.0," So if the secret number is within the range zero through ten, print that you found the number."
2681.0,2.0, Otherwise don't print anything.
2683.0,4.0, So if you don't find the number print nothing.
2687.0,13.0, And as you're working on that and if you finish that code think about how you would change that code to do one thing differently if it's not found print that you didn't find it.
2700.0,4.0, So in the first version if you don't find it do nothing.
2704.0,5.0, But in the second version if you don't find it tell me that you didn't find it.
2709.0,6.0, So these codes are in this Python file.
2715.0,5.0, And the easier version is about line 129.
2720.0,12.0," And then if you work on, you know, after you finish that if you're done you can just copy that code to lines about 144 and try to modify it to the new specification."
2732.0,5.0, So if you don't find it print that is you didn't find it.
2737.0,4.0, Okay. So tell me some code for the first one.
2741.0,12.0, So if we find the number print we found it and otherwise do nothing.
2753.0,6.0, What's better? Why loop or for loop?
2759.0,2.0," For loop, yeah."
2761.0,12.0," For, let's say I in range, how do I get numbers 1 to 10 inclusive?"
2773.0,3.0," 1 comma 11, exactly good."
2776.0,3.0," So this, and again I can write a little message for myself."
2779.0,6.0," I is 1, 2, 3, 4 dot, dot, dot 11."
2785.0,12.0, What do I do to make the check whether this number i is my secret?
2797.0,8.0," Yep, if i equal secret, let's say print found."
2805.0,7.0," Run it, obviously 4 is within that range, obviously 100, not in that range."
2812.0,6.0, So when we had 4 it printed found and when we had 100 it did nothing.
2818.0,5.0, Okay. I'm going to copy this code and paste it down here.
2823.0,6.0, So let's try the version now where we just make one small change to our specification.
2829.0,5.0," And now we request the code to say if you don't find the number within this range,"
2834.0,4.0, print that you did not find it.
2838.0,7.0," What are some things we can try? Else, okay."
2845.0,5.0, Print not found. Okay.
2850.0,13.0," So 4, obviously, was found, but we also printed all these not founds."
2863.0,5.0, Why? Yes.
2868.0,5.0, So you can try to print it out of the form.
2873.0,3.0," Yeah, we'll print it out because it's iterating through the whole range."
2876.0,6.0," Every time I check an i, I'm either printing found or not found."
2882.0,8.0," So we could break, I guess, when we found it, right?"
2890.0,4.0," Break, run it."
2894.0,4.0, Okay. Then we print not found until we find it and then we break.
2898.0,5.0," So we're getting there, right? It's looking a little bit better."
2903.0,4.0, What else can we try? Yes.
2907.0,3.0, Another break?
2910.0,8.0," We can try another break after not found, but then the 4 is not found."
2918.0,3.0, Yeah.
2921.0,18.0, I like the idea. Yeah.
2939.0,4.0, You can try to do a Boolean flag.
2943.0,3.0, Let's try to do the Boolean flag way.
2946.0,5.0, Let's delete the breaks. Let's go back to what we had before.
2951.0,11.0," So basically, our idea is, I think, what we're trying to get at is we only want to print not found when we've gone through all the numbers in the range."
2962.0,3.0, Right? So kind of something like this.
2965.0,6.0, Right? I want to print the not found only once at the end of my loop.
2971.0,7.0, Okay? But this code doesn't work either because I'm always printing not found.
2978.0,3.0," No matter if I do this extra print inside here, right?"
2981.0,4.0, Because this not found at the end here is at the same indentation level as the 4 loop.
2985.0,5.0," So the suggestion from a couple of you is to actually set a flag, right?"
2990.0,6.0," So we can set a found flag to be originally, let's say, false."
2996.0,2.0, Right?
2998.0,5.0," Before I even start my loop, let me just assume it's false."
3003.0,7.0, And I'm going to use this flag to trigger.
3010.0,8.0," I'm going to, I guess I'm going to change this flag whenever I found the number."
3018.0,3.0, Right? So found is originally false.
3021.0,6.0," And the place in my code where I know I found the number is here, right?"
3027.0,2.0, When I is equivalent to my secret.
3029.0,4.0, And then I can set my found flag to be true.
3033.0,4.0, I only call it a flag because it flags that an event happened or not.
3037.0,2.0, So it's kind of a bully an event.
3039.0,2.0, But it's really just a variable.
3041.0,6.0, Right? Nothing special about the word flag. It's just a variable.
3047.0,1.0, Right?
3048.0,6.0," Okay. So now, I think the suggestion was, now that we've set our flag to true or false,"
3054.0,8.0," depending on what happened in the code, we can say if found, or I guess in this particular case,"
3062.0,8.0," if not found, right, the inverse of my Boolean, print not found."
3070.0,5.0," Right? There's no else because the else was already taken care of when we had the secret,"
3075.0,3.0, when we found the secret within the code.
3078.0,3.0," So now, we print found when it's four."
3081.0,6.0," And if the number is obviously outside the range like 100, we print not found."
3091.0,5.0," We can make a small change to it, I guess, so we don't have to print found down in there."
3096.0,8.0," For maybe consistency or making things even, we can just say else, print found, or something like that."
3105.0,3.0, And I think that should work as well.
3108.0,5.0," So 100 is not found, and 4 is found."
3113.0,3.0, Right? So now we're doing things kind of consistently.
3116.0,2.0, We're printing out whether we found it or not down here.
3118.0,7.0," And inside the for loop, we're just dealing with the logic of the binding or not binding it."
3125.0,6.0, Any questions about this code? Does it seem all right? Does it make sense?
3132.0,8.0, So I'm showcasing these Boolean flags just because they're very useful for signaling that things happened in your code.
3140.0,8.0," Right? So when you find yourself asking, how do I know that this thing happened or something like Boolean flag is the answer."
3148.0,12.0," Right? Just set it to true or false, 0 or 1, A or B, whatever you want, and then check the value of that variable later on in the code to see if the event happened or not."
3161.0,10.0," So these are the two codes that we had just written, kind of side by side, just to show you exactly what the difference is."
3171.0,6.0," So here is the code where if we don't find the number, we don't print anything."
3177.0,3.0, Right? So it's just the for loop with an if and we say we found it.
3180.0,4.0, And the one on the right is the code where we did find it.
3184.0,4.0," Where if we didn't find it, we printed that we didn't find it."
3188.0,5.0, So the only things that are added in addition to the code on the left is the stuff that's bolded.
3193.0,3.0, Right? So I just have this flag that I initially said to false.
3196.0,3.0, I said it to true when this event happened.
3199.0,2.0, That is I found the number.
3201.0,5.0, And then I do the check at the end to print or not print out.
3212.0,3.0, I don't use else in the if or down here.
3216.0,1.0, Any if.
3217.0,11.0," So we don't use the else inside the if, iqq secret because that if or else will be done every time through the loop."
3228.0,5.0, Right? And I only print that we didn't find it one time at the end.
3233.0,8.0," Right? If I have an else inside the for loop, it's basically asking if i is the secret number."
3241.0,3.0, So zero is not the secret number. We would hit the else.
3244.0,2.0, One is not the secret number. We would hit the else.
3246.0,2.0, Two is not the secret number. We hit the else.
3248.0,4.0," And only when I get to seven in this case, it is the secret number."
3252.0,2.0, So I hit the if and so on.
3254.0,2.0, So it's not something I want to do every time through the loop.
3256.0,3.0, But I put it at the end because I only need to do it once.
3265.0,2.0, Is that something?
3267.0,3.0, Okay.
3270.0,7.0, So Boolean variables are a variable that is in one of two states.
3277.0,6.0," I used here true or false. But as I mentioned, you can use zero or one a or b as long as you as the programmer."
3283.0,4.0, Remember what values you're expecting this this variable to take on.
3287.0,4.0, Boolean variables can be used as signals that something happened in the code.
3291.0,3.0, Right? So this could be useful in a quiz situation.
3294.0,3.0," We call these Boolean flags. But again, it's just a name."
3297.0,7.0, It's just a variable that changes state depending on if some event happened in the code.
3304.0,3.0, Okay. So I'm coming back to the idea of while in four loops.
3307.0,4.0," And we've already seen that there are many situations where four loops are a lot more,"
3311.0,3.0, a lot easier to use than while loops.
3314.0,4.0, Okay. So when we have four loops that are rate through a sequence of values.
3318.0,5.0, So the guess and check algorithm actually lends itself a little bit better to four loops than while loops.
3323.0,5.0," So here's an example of us trying to find the cube root in this particular case,"
3328.0,6.0," not the square root of a number. And again, we're only asking if this number x is a,"
3334.0,4.0," or this case, cube is a perfect cube. Okay."
3338.0,7.0, So the way the code works with a four loop is we're going to iterate through all the possible values.
3345.0,5.0," So we have four our guess in range, some number."
3350.0,4.0, So we're going to check all the values zero all the way up through cube plus one.
3354.0,4.0," The reason why we did the plus one is because if the user gives us number one,"
3358.0,5.0," we want to check one itself. Right. If we didn't have cube plus one,"
3363.0,3.0," if we just had cube, we would mistakenly stop at zero,"
3366.0,3.0, even though one is a perfect cube.
3369.0,5.0," Okay. And then inside the four loop, we just have if guess cubed is equal to cube,"
3374.0,5.0, then we have found our perfect cube.
3379.0,4.0," Okay. If we have negative numbers with cubes,"
3383.0,5.0," it's just adding a little bit of extra code,"
3388.0,4.0," but it's not as weird as with the square root, right?"
3392.0,5.0, Because the cube root of a negative number is just the cube root of that positive version of that number
3397.0,3.0, with a negative sign in front of it.
3400.0,4.0," So all we're doing with a negative number as the input is saying,"
3404.0,6.0, I'm going to iterate through all these values and through zero all the way up to the positive version
3410.0,2.0, of whatever the user gave me.
3412.0,5.0, So this is taking the absolute value of the number the user gave me and adding one to it.
3417.0,3.0," So just kind of like the code on the previous slide,"
3420.0,2.0, except we're doing the absolute value of it.
3422.0,4.0," We're checking if the guess cubed is equivalent to the absolute value of cube,"
3426.0,2.0," exactly the same as on the previous slide,"
3428.0,3.0, except taking the absolute value of the cube.
3431.0,5.0, And then we have this extra little bit that checks if the user actually gave us a negative number.
3436.0,5.0, So do we need to put a negative number in front of our guess?
3441.0,3.0," So if the user actually did give us a negative number,"
3444.0,5.0," let's just take, do minus whatever value we just found for the cube,"
3449.0,7.0, and then we can print the cube root of this perfect cube.
3456.0,4.0," So again, same code as before, the only difference is absolute value of cube"
3460.0,7.0, and adding this check to deal with negative numbers.
3467.0,4.0," Okay, so we can actually make this code a little bit faster because,"
3471.0,2.0," for example, when we're checking the, you know,"
3473.0,2.0," checking the cube root of 27,"
3475.0,4.0," the numbers we're checking are zero, one, two, three, four, five, six,"
3479.0,4.0," in our four loop all the way up to 27, right?"
3483.0,6.0," But we can recognize the fact that when we reach, or 27, fine."
3489.0,1.0, Let's say 26.
3490.0,4.0," We can recognize the fact that when we hit three,"
3494.0,6.0," the guess cubed is actually 27, right?"
3500.0,5.0," And so in our four loop, it doesn't make sense to keep checking four, five, six, seven,"
3505.0,4.0," to see if those numbers are then going to match,"
3509.0,4.0, or BRR cube root for a potentially perfect cube.
3513.0,2.0, And so that's what this code is doing.
3515.0,4.0, It's going to have a little if statement in here.
3519.0,2.0," So again, this is the same as before."
3521.0,5.0," But we're going to have a little if statement that says if the guess cubed is greater than or equal to,"
3526.0,3.0," not just equal to, but greater than or equal to."
3529.0,3.0, Let's break out of the loop.
3532.0,1.0, Okay?
3533.0,5.0," And so when this condition is false, or sorry,"
3538.0,4.0," when this condition is true, guess cubed is greater than or equal to,"
3542.0,5.0," we have exited the loop, but now just like with the square root code, with the y-loop,"
3547.0,2.0, we have to see why we exited the loop.
3549.0,3.0, Why did we break out of this loop prematurely?
3552.0,1.0, Okay?
3553.0,4.0," One is we exited because the guess cubed was equal to the cube,"
3557.0,3.0, or the guess cubed was greater than the cube.
3560.0,7.0, And so then we have a little if else a conditional here that says if we exited
3567.0,5.0," because it's not equal, greater than, then it's not a perfect cube."
3572.0,7.0," And otherwise we exited because it was equal to, which is the same code we had on the previous slide."
3579.0,3.0," Check whether the user gave us a positive or negative value,"
3582.0,7.0," put the negative sign in front of our guess, and then print the perfect cube root."
3589.0,1.0, Okay?
3590.0,3.0," So all variations of the same sort of starter code,"
3593.0,6.0, we're just adding little bits of functionality and making the code slightly more efficient here and there.
3599.0,5.0," So I have another example, and this example is probably the point in this class where you're like,"
3604.0,4.0," aha, this is what computational thinking means."
3608.0,4.0," So remember these word problems from childhood, right?"
3612.0,4.0," You see a math problem, you have basically a system of equations."
3616.0,4.0, Algebraically you could probably solve it within a minute or so.
3620.0,5.0, You can actually apply computation to solve problems just like these.
3625.0,2.0, So we don't need to do it algebraically.
3627.0,4.0," We can just tell the computer, here's a bunch of values I want you to try."
3631.0,6.0, Try them to see if they match these systems of equations and then print out the answer.
3637.0,4.0," So here's an example I've got, Alyssa Ben and Cindy selling tickets to a fundraiser."
3641.0,3.0," Ben sells two fewer than Alyssa, Cindy sells twice as many."
3644.0,4.0, Ten total tickets were sold. How many did Alyssa sell?
3648.0,4.0, Here's some code that could solve this problem for us.
3652.0,7.0, I'm basically figuring out all the possible combinations for tickets that Alyssa and Ben and Cindy could sell.
3659.0,4.0," So I've got three loops, each nested."
3663.0,5.0," So Alyssa could have a could sell zero or one ticket or two tickets and so on,"
3668.0,5.0," but for every value of Alyssa, Alyssa can have can sell zero one or two tickets."
3674.0,4.0," For every one of those, Ben can sell zero one or two tickets."
3678.0,6.0," So Alyssa can sell zero, Ben can sell zero, Cindy can sell zero, Alyssa can sell zero, Ben can sell one, Cindy can sell zero."
3684.0,5.0, So we're basically having these three four loops that make all the possible combinations of tickets.
3689.0,4.0, So here I have Alyssa Ben and Cindy trying to sell tickets to a fundraiser.
3693.0,3.0, And then I have my system of equations here.
3696.0,2.0," So in total, they sell ten tickets."
3698.0,4.0," So here, total two less than twice are all Boolean variables."
3702.0,5.0, So A plus B plus C is equivalent to ten is the first condition I need to hold.
3707.0,8.0, B is equal to A minus two is the second condition I need to hold and C is equivalent to two times A is the last condition I need to hold.
3715.0,3.0," Those are the conditions from the previous slides, right?"
3718.0,7.0," And so these three Booleans, whenever they hold, total is true and two less is true and twice is true."
3725.0,5.0," When all these three things hold, I have found the solution to my problem."
3730.0,7.0," So inside my code, this is Alyssa Ben and Cindy trying to sell tickets."
3737.0,3.0, And the code automatically tells me they sold this many each.
3740.0,4.0, And what's cool about this code is we can then change something about it.
3744.0,4.0, And then we can run it again and immediately it tells us what the new solution is.
3748.0,5.0, We don't have to do it algebraically and solve it all over again.
3753.0,5.0, The problem with this code and the way I wrote it specifically is it's really slow for big numbers.
3758.0,7.0," If I change it to a thousand tickets being sold by three people, right, and then a couple other changes here."
3765.0,9.0, Just this year fact that I've got Alyssa iterating through zero to a thousand and Ben iterating through zero thousand and Cindy iterating through zero to a thousand takes really long time.
3774.0,9.0," And so that particular code, I'm not even going to run it, will take a really long time if I change the values to be a thousand, twenty and twice."
3783.0,5.0, But instead we can use kind of a mix of algebra and computation to solve the problem.
3788.0,4.0," We recognize we actually only need a loop through one loop, right?"
3792.0,6.0, I only care about maybe checking Alyssa's number of tickets being zero through potentially a thousand tickets sold.
3798.0,8.0," And then I can use my other two equations, right, Ben and Cindy, how many did they sell with respect to Alyssa?"
3806.0,6.0," And then I've got my two other equations here, which will tell me how many buttons Cindy sold."
3812.0,4.0," With respect to Alyssa's loop, right?"
3816.0,7.0, And then my last equation here is that Ben and Cindy and Alyssa altogether had to sell a thousand.
3823.0,9.0," And so with this particular code, I'm able to find the answer to the question, which is how many tickets they sold."
3832.0,9.0," And again, this is really awesome because now I can make small changes to the numbers and solve the problem basically immediately like that."
3841.0,7.0, I don't need to go back and solve it algebraically as I would if I were to do math.
3848.0,4.0, Okay. So we can apply computation to many different problems.
3852.0,8.0," I hope that this is a really good showcase, this word problem of what we mean by computational thinking and the kinds of things we want you to come away from."
3860.0,3.0, Come away with in this class.
3863.0,4.0," The last thing I wanted to talk about, and I'll just do a quick intuition, is binary numbers."
3867.0,7.0," And this is actually a precursor to the next algorithm we're going to see in the next lecture, an approximation algorithm."
3874.0,4.0, It's going to be an improvement on the guess and check algorithm.
3878.0,7.0," So so far we've seen numbers in Python. They can be integers, which are whole numbers and floats, which are real numbers."
3885.0,6.0," But in programming, some interesting things happen when we deal with floats."
3891.0,7.0, And this is going to be our motivation for talking about binary numbers and then fractions and then floats in this lecture and then the next one.
3898.0,5.0, So here's an example of some code.
3903.0,5.0," So I've got, is exactly what's in the slides. I've got an integer x."
3908.0,5.0, And all I'm doing in this code is I have a loop through range 10. So that means it's going to loop through 10 times.
3913.0,6.0," And I'm adding 0.1, 10 times. So 0.1 plus 0.1 plus 0.1, 10 times."
3919.0,7.0," And I'm going to print whether x, the sum, 0.1 plus 0.1 plus 0.1, is equal to 1."
3926.0,9.0," And just to show you, I'm not pulling your leg, I'm going to run it and print whether x, so 0.1 plus 0.1 plus 0.1, 10 times is equivalent to 1."
3935.0,3.0, And this code prints false.
3938.0,4.0," Not intuitive, right? If I'm adding 0.1, 10 times, I should be getting 1."
3942.0,7.0," But I'm not in programming. And just to show you the actual answer we get, let's print what the value of x is"
3949.0,5.0, and then ask whether that's the same as just multiplying 0.1 by 10.
3954.0,8.0," So doing the loop where we add this number 10 times, gives me actually 0.9999999."
3962.0,6.0, Whereas just multiplying 0.1 by 10 gives me 1 as I expect.
3968.0,7.0," And this is the motivation for, or I guess the precursor to our next algorithm, the approximation algorithm."
3975.0,9.0," So we have this thing called a floating point error. And why does it happen? And since it happens, we can't do equivalency, right?"
3984.0,10.0," We can't use the equal sign between floats because we get things like this that are going to completely mess up our program when we expect, you know,"
3994.0,7.0, something as simple as adding 0.1 to itself 10 times to be 1 and it's not.
4001.0,4.0, And so the big idea here is we have operations on floats.
4005.0,7.0," And the way, because of the way floats are actually starting computer memory, these operations introduce a very small error, super, super small."
4012.0,8.0," Every time you do an operation with a float. But the more you do this operation that has this tiny error, the more this error gets magnified."
4020.0,9.0, Right? And so then we see surprising results like that. And so that comes about with the way that floats are actually stored in the computer.
4029.0,8.0," So what we have in the computer is we work with binary, zeros and ones. But humans actually work in base 10, right?"
4037.0,11.0," We think from 0 to 9. But the computer works in base 2, either 0 or 1. And the reason it works through 0 and 1 is because of the way that the computer hardware is built."
4048.0,7.0," Right? It's easy for the computer hardware to say that a magnetic spin is up or down, right? 0 or 1."
4055.0,10.0," It's easy for the hardware to say that it has a voltage that's lower high. Right? If it would be a lot harder for the computer hardware to say, hey, I have a voltage that 0 low."
4065.0,7.0," High, let's say 1, or it's 1 1 1 1 1 1 or 2 1 1 1 1. There would be too many errors introduced."
4072.0,8.0," And so it's a lot easier for the computer hardware to just be in one of these two states, 0 or 1. Right? So that's where binary comes in."
4080.0,11.0," And so when we're dealing with integers, this is not a problem because we can easily convert numbers that are in base 10 to base 2."
4091.0,6.0," That are whole numbers, integers. The problem will come when we do floats. So you don't need to know how to do the conversion."
4097.0,13.0," But it will give you an intuition for what's going to happen. So the number 1,507 in base 10, so that's what we have up here is 1,500 plus 0 times 10 plus 7. Right?"
4110.0,7.0," In base 2, we have a similar pattern. We have some whole number multiplied by some power of 2."
4117.0,6.0," Here, we had the whole number be either number 0 through 9 multiplied by some power of 10."
4123.0,6.0," But in base 2, we're going to have either 0 or 1 multiplied by some power of 2."
4129.0,16.0," And if we're trying to convert the number 1,507 from base 10 to base 2, I guess humanly speaking, the way we'd think about it is what is the biggest power of 2 that we can have that takes us close to but not over 1,507."
4145.0,7.0," And that's 10, 2 to the 10, 1024. Because 2 to the 11 is 2,000 something and that's already too big."
4152.0,9.0," And then you ask yourself, what's the next biggest power of 2? I can add to this number, 1024 that brings me close to but not over 1,507."
4161.0,11.0," That's going to be 256. Notice we skipped 2 to the 9 because adding 2 to the 9 takes us over 1,507. It's adding 512 to 1024."
4173.0,10.0," And so we repeat this process where we're basically trying to figure out what are the biggest powers of 2 we can add in order that makes up 1,507."
4183.0,10.0," And it turns out it's going to be 2 to the 10 plus 2 to the 8 plus 2 to the 7 plus 2 to the 6 plus 2 to the 5, 2 to the 4, 3 and 2 are all going to be 0's and 2 to the 1 and 2 to the 0."
4193.0,8.0," And the bits, right, 1 times through the 10, 1 times through the 8 is basically what gets represented here, right?"
4201.0,9.0, These whole number portions that we multiply the powers of 10 by. And that's how we convert from a decimal number to a binary number.
4210.0,11.0," But again, this is kind of a human way of converting. We can actually do it in a more systematic way, a more not a more imperative way, a recipe way."
4221.0,13.0," And some way that a computer can actually use to take a number and convert it to binary. And you would never have to come up with this way, but given this way of converting the binary, you should be able to code it up."
4234.0,9.0, So the idea here is we're going to take a number and we're going to look at the remainder when we divided by 2.
4243.0,10.0," Right? If it's an odd number, obviously the remainder is 1, if it's an even number, the remainder is 0. And that remainder actually gives us the last bit, the farthest right bit."
4253.0,9.0, And then we can take that number and divide it by 2 fully. And then that gives us the remaining 4 digits. So you see everything else just gets shifted over.
4263.0,10.0," And the way the code looks is just doing successive divisions and figuring out the remainders. So I'm just going to look at the Python tutor real quick, and then we can stop."
4273.0,9.0," So if we're trying to convert the number 1507 following this particular recipe, all we do is we look at the remainder when we divide the number by 2."
4282.0,8.0," So this is an odd number, obviously the remainder is going to be 1. So we add a 1 to our binary representation."
4290.0,11.0, And then we're going to keep adding what happens when we divide the remaining numbers by 2. We're going to keep adding the remainder to the front of this string here.
4301.0,12.0," So if we divide the number 1507 by 2, that gives us 753. And now we ask is 753 odd or even? It's odd, so we add another 1 to the front of this string, the result string."
4313.0,11.0," Divide 753 by 2, it's 376. This is even. So now we add a 0 to the front of my string. So notice what happens to this string as we go step by step."
4324.0,13.0," 376 divided by 2 is 188. What is this even number? So we add a 0 to the front of this string. 188 divided by 2 is 94. Again, it's an even number. So we add a 0 to the front of this string."
4337.0,15.0," 94 divided by 2 is 47. It's odd, so we add a 1. 47 divided by 2 is 23. It's odd, so we add a 1. 23 divided by 2 is 11. So we add an odd. So we add a 1. 11 divided by 2 is 5. So it's odd, so we add a 1."
4352.0,6.0," And then 5 divided by 2 is even. We add a 0. And then 1 is our last number, so we add a 1."
4358.0,15.0," And notice this is the exact same number we had when we did it in this human thoughtful way, where we were trying to figure out the highest powers of 2 we can take to go up to, but not over the number 1,507."
4373.0,15.0," But we did this using just this very iterative, very nice loopy code. And if we wanted to do a negative number, we would just add these 2 boxes here. It just basically means we add a negative sign in front of it."
4388.0,2.0, Yeah.
