start,duration,text
0.0,14.92," All right, so let's get started with today's lecture."
14.92,5.92, We're going to look at a lot more code where we basically figure out the complexity class
20.84,1.9600000000000009, of that given code.
22.8,3.719999999999999," So first, let's remember what we learned at the end of the last lecture."
26.599999999999998,7.440000000000001, We introduced this theta notation as a notation to mark the order of growth of a particular
34.04,2.6000000000000014, function or a particular piece of code.
36.64,6.359999999999999," And the theta, we preferred over big onotation because the theta allowed us to get this asymptotic"
43.0,4.1200000000000045, upper bound on the worst case runtime of our function.
47.120000000000005,3.519999999999996, So we wanted an asymptotic bound as opposed to an upper bound because that upper bound
50.64,3.280000000000001, can be anything that grows faster than our function.
53.92,4.079999999999998, So we preferred this theta as the asymptotic bound.
58.0,5.0," So at the end of last lecture, we basically said that given some function, the theta for"
63.0,5.320000000000007, that function is going to be the dominant term of that function.
68.32000000000001,4.279999999999987," So if we have a whole bunch of terms, we focus on the one that grows the most."
72.6,5.560000000000002," We drop any additive constants, any multiplicative constants, and all the other terms that don't"
78.16,3.960000000000008, grow as fast as that biggest one.
82.12,3.719999999999999, So we ended up with some classes of algorithms that we're going to go over today.
85.84,3.4000000000000057, We're going to see a bunch of codes that fall within those classes of algorithms.
89.24000000000001,6.3999999999999915," But before we go into that, I wanted to just quickly recap sort of the end of last lecture."
95.64,5.920000000000002," So we saw an example that was pretty similar to this one, if not the same."
101.56,5.240000000000009," So we know that given some function, we can grab the theta of that function by focusing"
106.80000000000001,1.6399999999999864, on that dominant term.
108.44,2.3600000000000136, But how do we get at that function?
110.8,6.040000000000006," So given some piece of code, the idea to get at that function was to first start by looking"
116.84,1.8799999999999955, at the inputs to the function.
118.72,5.200000000000003," So we have three inputs in this particular case, L, L, L, L, and L2."
123.92,5.320000000000007," Once we figure out the inputs to this function, we go on and look at everything within the"
129.24,3.0, code that depends on these input parameters.
132.24,5.519999999999982," So they could be direct, like a loop that goes over something related to the input, or"
137.76,3.8799999999999955," it could be indirect, as we're going to see in some examples later today."
141.64,7.039999999999992, But we basically look at just the parts of the function that deal with this input.
148.67999999999998,8.280000000000001," If we want to be exact, we start by finding out the exact number of operations that we"
156.95999999999998,2.0, do within this code.
158.95999999999998,4.360000000000014, That's something that we did when we counted the number of operations given some function.
163.32,7.439999999999998," So we're going to count the number of operations given this code in relation to L1, L2, and L."
170.76,6.039999999999992, So we've got this relationship that we can come up with that relates the number of operations
176.79999999999998,3.7600000000000193," run as a function of L, L1, and L2."
180.56,7.680000000000007, So the one over here is constant because we just have an assignment here for some variable.
188.24,3.240000000000009, The next term here is not constant.
191.48000000000002,5.759999999999991," There are five constant things that we're doing, assigning i to be a value in range, grabbing"
197.24,2.319999999999993, indexing into L at i.
199.56,6.1200000000000045," That's two, indexing until i, L1 at i, that's three, checking the equality that's four, and"
205.68,2.3600000000000136," then setting an L1 to be true, that's five."
208.04000000000002,4.519999999999982," So there's five operations, but these are repeated how many times?"
212.56,6.800000000000011, So they're repeated length L1 times because this loop goes through length L1.
219.36,6.9599999999999795," So this term here, this four loop here, is length L1 times five number of operations."
226.32,5.200000000000017," Then the one here is this assignment over here, and then this loop down at the bottom is"
231.52,7.0," exactly the same as the loop up at the top, except that now this bottom loop repeats length"
238.52,1.4799999999999898, L2 times.
240.0,4.800000000000011," So as L2 gets bigger, this loop will take longer to run."
244.8,1.5999999999999943, That's how we think about that.
246.4,4.639999999999986," And then lastly, the plus two at the end of that relationship is finding the end of these"
251.04,3.920000000000016, two variables and then doing a return.
254.96,5.0800000000000125, So that leads us to simplify it as five times length L1 plus five times length L2 plus
260.04,1.0, three.
261.04,4.1200000000000045, And this becomes the function that we can then grab the theta of.
265.16,5.360000000000014," So now we just use the regular rules of theta, law of addition and law of multiplication."
270.52000000000004,5.159999999999968," If there's anything to add or multiply, in this particular case, let's say that L1 and"
275.68,4.480000000000018," L2 are all the same length, and then we can simplify the above function to 10 length L plus"
280.16,1.0, three.
281.16,5.319999999999993," And then the theta of that becomes just theta of length L. Because we dropped the three,"
286.48,8.600000000000023," we dropped the 10 multiplying L, and then we just keep length L."
295.08,4.079999999999984, So this is how we get at the theta of a particular function.
299.15999999999997,2.0400000000000205, This is when we looked at last time.
301.2,4.800000000000011," But as we look at more functions today, we're going to get better at just identifying the"
306.0,4.159999999999968, parts of the code that just deal with our inputs.
310.15999999999997,4.520000000000039," This in L1 equals false, this in L2 equals false, this return, this end."
314.68,2.4399999999999977, Those are all constant things that are happening.
317.12,1.8799999999999955, So we don't need to focus in on those.
319.0,3.7199999999999704, We just maybe glance at them really quickly to make sure there's nothing funky going
322.72,3.160000000000025, on that's dependent on the length of our lists.
325.88000000000005,4.439999999999998," But we can just basically say, well, we've got our inputs, we've got one for loop that"
330.32000000000005,3.0399999999999636," goes through the length, another for loop that goes through the length."
333.36,4.639999999999986," They're in series, so we use the law of addition to say that this function is theta of length"
338.0,1.9600000000000364, L1 plus length L2.
339.96000000000004,4.599999999999966, And so then we can quickly tell the theta of that function just by looking at the parts
344.56,2.8800000000000523, that depend on the input.
347.44,6.8799999999999955," So at the end of last lecture, we ended up with looking at these, sorry, deciding that"
354.32,6.720000000000027, these are the complexity classes that we can categorize a lot of our functions in.
361.04,3.4399999999999977," So theta of 1 is constant, theta of log n is log rhythmic."
364.48,3.6399999999999864, Here n is assuming n is the input to my function.
368.12,7.9599999999999795," Theta of n is linear, theta of n log n is log linear, theta of n, if n is my input to"
376.08,4.759999999999991," some constant, like n squared and cubed, runs in polynomial time."
380.84,4.840000000000032," And then theta of some constant to the n, where n is my input, is going to be exponential,"
385.68,1.599999999999966," like 2 to the n, 3 to the n."
387.28,3.080000000000041, Those are all considered exponential time algorithms.
390.36,7.8799999999999955," And when we write our algorithms, we want to be up in this maybe top four, maybe top five,"
398.24,4.279999999999973, though polynomial is going to grow pretty quickly as our input gets big.
402.52,4.519999999999982, So if we can take our code and just quickly glance at it and classify it within one
407.03999999999996,7.0," of these algorithms, that can guide us towards deciding whether the algorithm we wrote was"
414.03999999999996,1.6400000000000432," good or bad, right?"
415.68,4.079999999999984," If we glance at it and say, hey, this algorithm is exponential or this function that I wrote"
419.76,4.399999999999977," is exponential, maybe we want to rethink our approach to the problem and try to get"
424.15999999999997,4.360000000000014, it into one of the upper complexity classes.
428.52,3.660000000000025, So what we're going to do the rest of this class is just go through a bunch of these
432.18,4.0, complexity classes and we're going to see some codes that belong to these complexity
436.18,6.659999999999968, classes and hopefully give you an idea of what code looks like that fits in one of these
442.84,2.160000000000025, complexity classes.
445.0,3.159999999999968, So the first one we'll look at is the constant complexity class.
448.15999999999997,1.5200000000000387, It's pretty simple.
449.68,3.1199999999999477, It's not really very interesting.
452.79999999999995,4.400000000000034," If your code belongs in this constant complexity class, that means that it does not depend"
457.2,1.0, on the input at all.
458.2,2.3999999999999773, It always runs in constant time.
460.59999999999997,7.32000000000005," So your code can have loops or it can have some sort of recursive structure, but that loop"
467.92,3.7999999999999545," or that recursive structure doesn't depend on the input at all, right?"
471.71999999999997,1.3199999999999932, So it's fine to have loops.
473.03999999999996,4.400000000000034," It's just as long as it doesn't depend on the input, it's considered constant."
477.44,3.4799999999999613, So there are some built-in operations that are constant time.
480.91999999999996,5.160000000000025," So if you see any of these operations like indexing into a list, appending to a list,"
486.08,5.600000000000023," having the value associated with the dictionary, those are all constant time."
491.68,3.519999999999982," So if you see them in your code, you don't need to account for them at all."
495.2,5.600000000000023, But we're going to see in a few slides that there are some operations on list and dictionaries
500.8,3.359999999999957, that do add some non-constant complexity.
504.15999999999997,1.920000000000016, So you can't just brush them off.
506.08,3.240000000000009," All right, let's look at a couple examples of code."
509.32,5.28000000000003," So here's a very simple function, add x, y, so x and y are my inputs."
514.6,5.039999999999964," There is no loop or nothing recursive, nothing that takes time here, that nothing that"
519.64,1.759999999999991, repeats in this code.
521.4,2.400000000000091, So the complexity of this code is theta of 1.
523.8000000000001,2.159999999999968," Okay, that's it."
525.96,1.0, Here's another example.
526.96,2.2799999999999727, This is our kilometer example.
529.24,2.6800000000000637," Taking in miles, all it does is a multiplication."
531.9200000000001,1.5599999999999454," Again, theta of 1."
533.48,4.440000000000055," There's nothing interesting going on here, no loop, no recursive."
537.9200000000001,3.8799999999999955, Here's a function that does have a loop within it.
541.8,2.4400000000000546," The first thing we look at, though, is my input."
544.24,1.7999999999999545, What variables my input here?
546.04,1.8400000000000318," It's x, right?"
547.88,3.919999999999959, So which part of my code here depends on x?
551.8,7.559999999999945," Well, there's something that I'm adding here, so I'm adding x onto some number."
559.3599999999999,3.400000000000091," And I do have a loop, but does the loop depend on x?"
562.76,5.599999999999909," No, it depends on some number that is just 100 within my function."
568.36,6.32000000000005," If y equals x here, then this code wouldn't be constant, right?"
574.6800000000001,2.67999999999995, Because this loop will go through x times.
577.36,4.600000000000023," But here y is just 100, so this code is theta of 1 complexity."
581.96,5.199999999999932, There's nothing here that depends on x as x grows.
587.16,3.240000000000009," All right, so not very interesting examples there."
590.4,7.920000000000073," So let's move on to the next simplest class of functions, the linear complexity class."
598.32,8.440000000000055," And these functions will be usually denoted by one loop, or maybe many loops in series,"
606.7600000000001,1.5599999999999454, or something like that.
608.32,3.919999999999959, But these loops all depend just linearly on n.
612.24,6.400000000000091, You could also have a recursive function that repeats that's also linearly an n.
618.6400000000001,2.4799999999999045, So we're going to see an example of a recursive function in a little bit.
621.12,5.8799999999999955, But first we'll start out with just some functions that loop linearly with it.
627.0,5.1200000000000045, There are some built-in operations though that are linear in time.
632.12,6.0," So if we ever see these operations within our code, we can't ignore them."
638.12,5.279999999999973, Because they will contribute a theta of n complexity to our code.
643.4,1.6800000000000637, So we have to account for them.
645.08,6.439999999999941," If we have some e in n within some other loop, we can't just say this e in n is constant."
651.52,5.360000000000014, We'd have to use the law of multiplication or something like that to account for it.
656.88,5.559999999999945, So checking if an element is in a list obviously is linear because you have to look at each element
662.4399999999999,4.240000000000009, in the list to determine that e is in it or not.
666.68,6.5200000000000955," Making a copy of your list is also linear in time, even though we're making a copy of half"
673.2,8.0," of our list, so the first half of our list, it's still linear because copying 0.5 times"
681.2,3.4799999999999045, length L is still theta of length L.
684.68,3.9600000000000364, And that multiplicative constant on the front of our length L is 0.5.
688.64,4.039999999999964," So if we drop it, that's still theta of length L."
692.68,3.7200000000000273, Checking for equality between two lists is also constant because you have to look at each
696.4,4.519999999999982," element in the list, compare them to make sure that they're the same or not."
700.92,4.600000000000023, And deleting an item in a list is also linear in time.
705.52,3.0," Sorry, this one was constant in time."
708.52,1.7200000000000273," Sorry, this one was linear in time."
710.24,5.159999999999968, This is also linear in time just because of the way lists are stored in memory.
715.4,6.080000000000041," So if you delete an item in the end of from your list, Python will count that as linear"
721.48,2.2000000000000455, time complexity.
723.6800000000001,1.6399999999999864, So let's look at some examples.
725.32,3.439999999999941, First we'll just start out with just some regular functions with loops and then we'll
728.76,2.3999999999999773, look at one recursive function.
731.16,3.6399999999999864, So here I've got multiply x by y.
734.8,8.799999999999955, It loops through range y and it just adds x plus x plus x y times.
743.5999999999999,1.5200000000000955, So I've got two parameters here.
745.12,4.7999999999999545, So I need to think about the complexity of this function with regards to both of them.
749.92,4.399999999999977," So the complexity with respect to y is theta of y, right?"
754.3199999999999,3.32000000000005," Because I've got one loop, that's a function of y."
757.64,2.480000000000018, So this loop will repeat however big y is.
760.12,5.080000000000041," So if y increases, the time this loop takes will also increase, right?"
765.2,5.839999999999918, So the theta complexity of this function is theta of y with respect to y.
771.04,4.360000000000014, But what's the complexity of this function with respect to x?
775.4,3.759999999999991," I have no looping structure here that's with respect to x, right?"
779.16,3.1200000000000045, All I'm doing to x is just adding on to some number.
782.28,3.080000000000041, So the complexity with respect to x is just theta of 1.
785.36,4.1200000000000045, So the overall complexity of this function is just going to be theta of y.
789.48,6.1200000000000045, x does not contribute anything to the runtime of this.
795.6,6.2000000000000455, So this and the previous loop function from the constant kind of tells us that we need to be
801.8000000000001,2.1200000000000045," careful about what the inputs are, right?"
803.9200000000001,5.919999999999959," When we report the complexity, we have to report it with respect to the inputs to our function."
809.84,4.919999999999959," We don't always just say theta of n or theta of n squared or theta of length n, whatever"
814.76,0.6800000000000637, it is.
815.44,2.480000000000018, We have to relate it to the inputs to our function.
817.9200000000001,5.960000000000036," And if we have more than one input, we have to be careful to account for all of the inputs"
823.8800000000001,1.7199999999999136, that contribute to the complexity.
825.6,3.519999999999982," All right, let's look at another example."
829.12,4.840000000000032, So here's one where you take in a string s.
833.96,3.1200000000000045, We loop through each character in s.
837.08,4.039999999999964, We cast each character to an integer.
841.12,1.6400000000001, And then we add on to some value.
842.76,5.759999999999991," So we're essentially just adding on all of the characters in s, in the string s."
848.52,4.519999999999982, So this has one loop that loops through all the elements in s.
853.04,4.32000000000005," Now, if s is a string, what's going to make this program slower?"
857.36,5.8799999999999955," Is it that the string, like, so the numerical value of the string is bigger?"
863.24,5.960000000000036," No, because if I'm looping through the string 1, 0, 0, 0, it's going to take the same"
869.2,3.519999999999982," amount of time as if I'm looping through the string 9, 9, 9, 9."
872.72,2.5599999999999454, It's the length of the string that matters.
875.28,1.9600000000000364," So that's what this loop is doing, right?"
877.24,3.080000000000041, It's taking into account the length of the string.
880.32,3.919999999999959," So if my string is longer, then it's going to take longer to run."
884.24,3.6800000000000637, So the complexity of this function is just theta of length s.
887.9200000000001,4.759999999999991, Because that's the length of the string contributes to slowing down my function.
892.6800000000001,2.3600000000000136, Everything else that we do is constant.
895.0400000000001,3.0799999999999272, So the overall complexity is theta of length s.
898.12,3.7200000000000273," Or if it's simpler, you can just say theta of n, but then you have to say, all right,"
901.84,1.080000000000041, here's another example.
902.9200000000001,4.67999999999995, This is a factorial program that does it iteratively.
907.6,9.680000000000064, So it's going to use a loop to keep multiplying on i to calculate the factorial of some n.
917.2800000000001,2.0799999999999272," So in this case, my input is n."
919.36,5.159999999999968, So now I'm going to look through my function to see what part of my function depends on
924.52,1.240000000000009, n.
925.76,2.0400000000000773, So here n is just a number.
927.8000000000001,3.7199999999999136, And I'm looping through from 2 all the way up to n plus 1.
931.52,6.399999999999977, So I'm going to loop through n minus 1 times overall.
937.92,3.800000000000068," Since I'm looping through n minus 1 times, there's nothing else really that's contributing"
941.72,1.4799999999999045, to the complexity.
943.1999999999999,4.400000000000091," So theta of n minus 1 is just theta of n, right?"
947.6,6.399999999999977, So the complexity of this function is just theta of n.
954.0,1.8400000000000318," Everyone OK so far, right?"
955.84,7.279999999999973, So very simple programs that just have one loop just depends on the input linear.
963.12,5.2000000000000455," OK, I will make a little note about the factorial because this is kind of something important."
968.32,4.279999999999973," It's going to tell us kind of the difference between theory, which is what this class is"
972.6,4.240000000000009," mostly about, or this set of lectures, and the real world."
976.84,4.360000000000014, So I actually ran the iterative version of factorial on the computer.
981.2,3.080000000000041," And you can see here, I've multiplied the input by 2."
984.28,2.3600000000000136," So 40, 80, 160, 320, and so on."
986.64,5.840000000000032," So as I'm multiplying the input by 2, if I'm expecting this function to be linearly"
992.48,6.439999999999941," related to the input, right, I'm expecting that the time that this function takes to run"
998.92,2.840000000000032," is going to be approximately twice as long, right?"
1001.76,3.8799999999999955," If the input increases by 2, the time it takes for this program to run should just increase"
1005.64,2.1200000000000045, by 2 as well.
1007.76,1.4800000000000182," And it does, right?"
1009.24,4.639999999999986, It does all the way up to somewhere between 640 and 1280.
1013.88,1.0, Right?
1014.88,5.639999999999986," So if we do the math, that's approximately times 2 each time."
1020.52,2.6000000000000227," Minus, you know, because we're just doing times here."
1023.12,6.919999999999959," But then, after somewhere within 640 and 1280, the time that it takes to run my program"
1030.04,3.1200000000001182, no longer follows this linear pattern.
1033.16,5.0," In fact, it starts to grow faster than linear, and from, you know, at a first glance, it"
1038.16,4.160000000000082," looks like it grows squared, right, polynomially."
1042.3200000000002,5.439999999999827," So instead of, you know, if you increase the input by 2, it looks like the time it takes"
1047.76,5.8400000000001455, for this program to run increases by 4 after some point.
1053.6000000000001,6.279999999999973," And that's because in the real world, I've got, you know, Python running on the machine,"
1059.88,5.399999999999864," there's only some set number of bits that my computer can hold, right, when it deals,"
1065.28,2.240000000000009, when it stores numbers.
1067.6,8.200000000000045, The factorial of some number within between 640 and 1280 becomes so large that when Python
1075.8,6.440000000000055," and the machine is trying to deal with multiplying these big numbers by these big numbers altogether,"
1082.24,5.039999999999964, it's just taking a really long time to run because it can't store these big numbers
1087.28,3.599999999999909, as efficiently as it could store these smaller numbers.
1090.8799999999999,5.080000000000155," And so in the real world, what ends up happening is after some, you know, after I'm trying to"
1095.96,5.440000000000055," store some really large value and doing the operations with some really large values,"
1101.4,6.559999999999945," the time complexity goes down dramatically, right, and squared is a pretty big jump."
1107.96,4.599999999999909," And so this is kind of shows the difference between theory and the real world, right,"
1112.56,3.9600000000000364," so in the real world, we can't store these values as efficiently as they get bigger."
1116.52,11.680000000000064," So, I guess, you know, the value is the general."
1128.2,5.0," Yeah, so if we use like a machine that had more bits to store values, then we'd be able"
1133.2,6.919999999999845," to be more efficient farther along, right, yeah, exactly."
1140.12,4.440000000000055," And we could, I guess we could, if we had a language that was maybe doing some smarter"
1144.56,4.839999999999918," things and storing these big values in a much smarter way, that could also have an impact"
1149.3999999999999,3.480000000000018, in the timing as well.
1152.8799999999999,4.160000000000082," But for the purposes of this class, we're just interested in the theoretical, you know,"
1157.04,1.9600000000000364," the theoretical happenings here, right."
1159.0,5.7999999999999545," So as the input increases by x, we expect that the time that it takes to run the program"
1164.8,4.079999999999927," will be x times as long, right, because we're looking at values that are really, really"
1168.8799999999999,2.480000000000018, big in theory.
1172.36,2.2000000000000455," Okay, so let's look at another example."
1174.56,4.960000000000036, So this is a factorial function that does it recursively.
1179.52,2.199999999999818, We've seen this function before.
1181.7199999999998,2.4400000000000546, We just looked at the iterative version of factorial.
1184.1599999999999,3.0399999999999636, Now we're looking at the recursive version of factorial.
1187.1999999999998,0.9200000000000728, So what do we have?
1188.12,7.2000000000000455," We have one base case, right, that our code will eventually get down to and a recursive step,"
1195.32,5.039999999999964, which is just n times factorial and minus 1.
1200.36,4.519999999999982, So how do we do the analysis of a recursive algorithm?
1204.8799999999999,4.120000000000118," Because in this recursive algorithm, we don't have a loop, right."
1209.0,4.7999999999999545," In the previous examples, we had a loop that we could definitively say, hey, this loop"
1213.8,6.0," will repeat this many times, so clearly increasing n will increase the time it takes for this"
1219.8,1.4800000000000182, loop to run.
1221.28,5.079999999999927," So when we're dealing with recursive functions, we think about how many times the recursive"
1226.36,2.5599999999999454," function is going to be called, right."
1228.92,5.440000000000055," Because when we call factorial, right, we have factorial of some, you know, five or whatever"
1234.3600000000001,1.3999999999998636, it is.
1235.76,5.080000000000155," And this calls factorial of four, and this calls factorial of three, right."
1240.8400000000001,8.0, And so we have this chain of function calls where we get down to the base case.
1248.8400000000001,7.0," And once we get down to the base case, we start to kick off the step that returns the"
1255.8400000000001,1.9199999999998454, result one at a time.
1257.76,7.0," So when we're talking about recursive functions, what we really care about is how many times"
1264.76,3.4400000000000546, we call the function.
1268.2,3.5599999999999454," That's our quote unquote loop for recursive functions, right."
1271.76,4.920000000000073, It's just the function calling itself to ask itself to do the work.
1276.68,4.3599999999999," And it does the work with a slightly changed parameter, right."
1281.04,5.680000000000064, So what we need to do is think about how many times does this function call itself.
1286.72,5.2000000000000455," And on top of that, is there some sort of overhead that's not constant."
1291.92,5.039999999999964," In this particular case, when we call factorial recursive, we're going to go essentially"
1296.96,3.0," theta of n times, right."
1299.96,3.7999999999999545," Because we start with n, then we do n minus 1, n minus 2, and minus 3 all the way up"
1303.76,1.6400000000001," down to 0, right."
1305.4,2.8799999999998818," So effectively, we've called ourselves about n times."
1308.28,1.6800000000000637, So theta of n.
1309.96,4.839999999999918, And the overhead for each one of those calls is constant because all I'm doing to n is
1314.8,1.2000000000000455, subtracting by 1.
1316.0,1.9200000000000728," And that's a constant thing, right."
1317.92,1.5199999999999818, And minus 1 is theta of 1.
1319.44,3.2000000000000455, It's just constant.
1322.64,6.959999999999809," So the overall complexity of this is just theta of n, where n is just my input, okay."
1329.6,5.160000000000082, So what we notice is that the iterative and the recursive versions of factorial are
1334.76,2.3199999999999363," both theta of n, right."
1337.08,5.160000000000082," Which means that generally speaking, if we were trying to decide whether to implement"
1342.24,5.039999999999964," factorial recursively or iteratively, it won't really matter in the long run."
1347.28,3.0399999999999636, Because the worst case complexity is theta of n.
1350.32,1.1200000000001182, It's the same for both.
1351.44,2.9199999999998454," So it will be your choice, which one to actually use."
1354.36,6.480000000000018," All right, so then it maybe comes down to readability or other factors."
1360.84,3.2800000000002, All right.
1364.1200000000001,1.0, Another example.
1365.1200000000001,1.0, So this is compound.
1366.1200000000001,1.0, We saw this last lecture.
1367.1200000000001,3.3199999999999363," We actually timed it and counted how many, actually, did we count?"
1370.44,1.0, I don't remember.
1371.44,6.119999999999891," I think we counted the number of operations, or maybe we did, but we definitely timed it."
1377.56,3.800000000000182, So this function took in three parameters.
1381.3600000000001,3.199999999999818, So we can have to be careful which one of these parameters or
1384.56,4.400000000000091, which parameters of these actually contribute to my complexity.
1388.96,5.079999999999927, So this function calculates the amount of money I have.
1394.04,8.920000000000073, If I invest some monthly amount at some monthly interest over some number of months.
1402.96,3.3599999999999, So the loop here iterates through number of months.
1406.32,3.400000000000091," And then everything else seems to be constant, right?"
1409.72,2.3199999999999363, I have gone one loop.
1412.04,2.3199999999999363, So the inside of the loop is constant.
1414.36,2.7999999999999545," I do have to double check that, but so far so good."
1417.1599999999999,1.9600000000000364, It's just it's not looping anything else.
1419.12,3.3200000000001637, It's not a function of anything else.
1422.44,5.400000000000091," The loop itself though is theta of n months, right?"
1427.8400000000001,4.7199999999998," So the overall complexity of this function is theta of n months, or we could say theta"
1432.56,3.9600000000000364," of n, where n is equal to n months."
1436.52,3.1200000000001182, None of the other parameters contribute to my complexity.
1439.64,2.9199999999998454," And that's exactly what we saw when we ran the code, right?"
1442.56,4.600000000000136, We ran it by changing each one of the parameters and we saw only n months contributed to a
1447.16,5.559999999999945, slowing program.
1452.72,6.6400000000001," If we really wanted to, we could have done this analysis in depth, right?"
1459.3600000000001,4.079999999999927," As we've done last lecture to actually count the full number of operations, or as we did"
1463.44,1.759999999999991, at the beginning of this lecture.
1465.2,2.880000000000109," So you know, total equals zero is theta of one."
1468.0800000000002,5.119999999999891, The loop is theta of n months multiplied by four operations.
1473.2,8.559999999999945," So I grabbing a value in range, taking multiplication, addition, and then saving that into total."
1481.76,5.600000000000136," That's four multiplied by theta of n, where n is n months, plus theta of one to do the"
1487.3600000000001,1.0, return.
1488.3600000000001,5.1599999999998545," So that ends up being theta of one plus four and plus one, which just simplifies to theta"
1493.52,2.240000000000009," of n, where n is n months."
1495.76,1.0, Yeah.
1496.76,7.0," So why did it take the whole theta of one, and then it might be like, right?"
1503.76,3.0," Which is the average, but then I need less."
1506.76,2.519999999999982, Because it's simply a little bit complicated.
1509.28,1.0, Yeah.
1510.28,1.400000000000091," So we're just looking at operations, right?"
1511.68,5.720000000000027," We're doing calculations with interest and invest and multiplying it with total, right?"
1517.4,5.0," But the fact that interest is bigger, like if the interest is one dollar or if the interest"
1522.4,6.839999999999918," is a thousand dollars, is this going to make that line of code much slower?"
1529.24,1.0," No, right?"
1530.24,3.040000000000191," Because all we're doing is a multiplication between two numbers, right?"
1533.2800000000002,2.0399999999999636," So that's why the inside is theta of one, right?"
1535.3200000000002,4.679999999999836," But having a loop where we repeat this over and over again, is going to slow the program"
1540.0,1.0, down.
1541.0,1.0, Yeah.
1542.0,3.480000000000018, Okay.
1545.48,3.0, How about this Fibonacci function?
1548.48,2.759999999999991, So this is an iterative version of Fibonacci.
1551.24,2.599999999999909," We have, I don't know if we've seen this before."
1553.84,6.240000000000009," Again, we could do sort of a rough quick analysis where we just briefly glance at every single"
1560.08,7.560000000000173, line and ask ourselves whether it's contributing theta of one or something worse to our total
1567.64,3.5599999999999454," analysis, total runtime analysis."
1571.2,5.039999999999964," So we've got this first part here, which is just constant, state of one, right?"
1576.24,1.8800000000001091, One here is loopy.
1578.1200000000001,6.439999999999827," There's no recursive going on, nothing that depends on the input in a non-constant way."
1584.56,4.080000000000155," In the else, we've got this constant, again, just assigning two parameters."
1588.64,1.4800000000000182, We've got a loop.
1590.1200000000001,4.959999999999809, So now this loop is going to be non-constant.
1595.08,3.6000000000001364," The stuff inside the loop is constant though, right?"
1598.68,3.119999999999891," So the loop itself depends on n, my input."
1601.8,2.480000000000018, So that's going to be theta of n.
1604.28,2.9600000000000364, But that theta of n is multiplied by theta of one.
1607.24,2.3199999999999363, The stuff inside the loop is just constant.
1609.56,3.240000000000009," So that's theta of n times theta of one, which is just theta of n."
1612.8,3.240000000000009," And then the return, of course, is theta of one."
1616.04,4.0," So we could do a calculation like this, or you could just quickly scan and say, hey, I've"
1620.04,4.3599999999999," just got a loop that depends on n, and that's theta of n."
1624.3999999999999,4.2000000000000455," So the overall complexity of this, if we wanted to be detailed, is this, right?"
1628.6,4.7999999999999545, Theta of one plus theta of one plus theta of n times theta of one plus theta of one.
1633.4,4.480000000000018," But overall, that just gives us theta of n, because that loop is the only thing that"
1637.88,3.3599999999999, depends on my input.
1641.24,2.1200000000001182, Everyone all right so far?
1643.3600000000001,1.240000000000009, Okay.
1644.6000000000001,1.5199999999999818, Perfect.
1646.1200000000001,4.879999999999882, So now let's move on to the second easiest complexity to kind of identify.
1651.0,2.160000000000082, That's the polynomial complexity.
1653.16,6.880000000000109," So polynomial complexity generally deals with functions that have nested loops, right?"
1660.04,5.240000000000009," So if we have two nested loops that linearly depend on my input, that's going to be a function"
1665.28,1.759999999999991, that's n squared.
1667.04,3.759999999999991," If I've got three nested loops that all depend on my input linearly, that's going to be"
1670.8,2.3599999999999," n cubed, right?"
1673.1599999999999,3.2000000000000455, So let's see some examples.
1676.36,3.880000000000109, So here I have a really simple nested loop situation.
1680.24,7.480000000000018," I've got a function called g, and it's going to take in an input n."
1687.72,3.4400000000000546, So I'm going to look for everything that depends on n.
1691.16,5.559999999999945," Well, I've got a for loop here that's going to iterate n times, that's theta of n."
1696.72,2.119999999999891, And I've got an inner for loop.
1698.84,8.240000000000009," So for each thing in my outer for loop, I'm going to do the inner thing n times as well."
1707.08,3.8400000000001455, And then the stuff inside my inner for loop is constant.
1710.92,4.680000000000064," So that's theta of n, and the stuff outside of my loops are, sorry, the stuff inside my"
1715.6,4.519999999999982," inner for loop is theta of 1, and the stuff outside of any of the for loops are theta"
1720.12,1.0, of 1 as well.
1721.12,2.400000000000091, So they contribute nothing to this complexity.
1723.52,5.839999999999918," So the only thing that I need to account for is my outer loop, which is theta of n, and"
1729.36,7.039999999999964," law of multiplication says my inner loop is going to be multiplied, it's complexity"
1736.3999999999999,2.5599999999999454, to my outer loop's complexity.
1738.9599999999998,3.4400000000000546," So the overall complexity of this function is theta of n squared, because the number"
1742.4,7.0, of times that I'm going to do this operation is going to be n squared times.
1749.4,1.0, Okay.
1750.4,3.6400000000001, All right.
1754.0400000000002,2.8799999999998818, So now let's look at some examples with lists.
1756.92,2.519999999999982, We haven't seen those yet.
1759.44,2.880000000000109, So now we have to think about the input.
1762.3200000000002,2.480000000000018," In this case, it's going to be two lists."
1764.8000000000002,4.079999999999927," And when we're dealing with lists, one of the things that are the most common thing we're"
1768.88,6.6400000000001," interested in is what happens to the behavior of the function as the lists get bigger,"
1775.5200000000002,1.0, right?
1776.5200000000002,5.519999999999982," As we saw in last lecture, the size of the elements within the list typically don't"
1782.0400000000002,6.279999999999973," matter, but the fact that I have more elements to do stuff with does matter, right?"
1788.3200000000002,5.240000000000009," So if my list now has twice as many elements, this program, or most programs, will probably"
1793.5600000000002,2.9199999999998454, be twice as slow.
1796.48,5.759999999999991," So here's a function called is subset, takes in two lists, L1 and L2."
1802.24,5.039999999999964, I've added two little examples up here to help us figure out what this function does.
1807.28,6.319999999999936," So it's going to tell us whether the elements of L1 are in L2, right?"
1813.6,7.440000000000055," So in the first example here, elements in L1 are 3 and 5 and 2, and L2 does have the 3"
1821.04,3.400000000000091," and the 5 and the 2, but it also has other stuff."
1824.44,1.0, It's totally fine.
1825.44,2.519999999999982, All the elements in L1 are in L2.
1827.96,5.160000000000082," So this function will return true for those examples, those L1 and L2."
1833.1200000000001,2.9600000000000364, And then here's an example where it will return false.
1836.0800000000002,6.1599999999998545," So the elements of L1 are 3 and 5 and 2, and L2 is missing the 3."
1842.24,1.6800000000000637," So then that one will return false, right?"
1843.92,3.9200000000000728, The elements of L1 are not all in L2.
1847.8400000000001,1.4800000000000182, So it's not a subset.
1849.3200000000002,2.439999999999827," All right, so what's this function doing?"
1851.76,3.160000000000082," Well, it's iterating through all the elements in L1."
1854.92,3.3599999999999," So it's going to first look at the 3, then the 5, and the 2."
1858.28,5.2000000000000455, It's going to look through each element in L2 for every one of those L1 elements.
1863.48,4.759999999999991," So it's going to look at the 3 and the 2, the 3 and the 3, the 3 and the 5, the 3 and the 9."
1868.24,4.240000000000009," Then it's going to look at the 5 and the 2, the 5 and the 3, 5 and 5, 5 and 9."
1872.48,1.0, Right?
1873.48,1.3599999999999, It's going to keep doing that.
1874.84,7.599999999999909," And it's going to keep track of this Boolean, called matched."
1882.4399999999998,9.920000000000073," And it's going to, as long as it finds this element, E1 within my L2, it's going to save matched to be true."
1892.36,8.6400000000001, And it's going to keep doing this until it keeps finding matches.
1901.0,2.7999999999999545," It's long, sorry, until it finds a match."
1903.8,5.440000000000055," As soon as it finds a match, it breaks because there's no need for it to keep looking at the remaining elements of L2."
1909.24,3.240000000000009, It already found one that matches.
1912.48,5.759999999999991, So this code could actually be rewritten by saying kind of the inverse.
1918.24,0.2400000000000091, Right?
1918.48,6.2000000000000455," If E1 is not equal to L2, we can just immediately return false."
1924.68,4.759999999999991," Because we've already found an element that from L1, that's not an L2."
1929.44,5.680000000000064," So we could have rewritten this code in many different ways, but the ultimate analysis will be the same."
1935.1200000000001,4.0, So let's look at the analysis for this function.
1939.1200000000001,2.2799999999999727," Well, we have two inputs."
1941.4,7.7999999999999545," So we have to be careful about both of these inputs, which parts of this function depend on L1 and L2?"
1949.2,2.839999999999918," Well, we've got an outer for loop."
1952.04,7.160000000000082, So what happens to the complexity with regards to this loop?
1959.2,5.319999999999936," Well, if I have more elements in L1, then this loop will go through more times."
1964.52,5.680000000000064, So this loop will be executed length L1 times.
1970.2,4.680000000000064, So the theta for this outer loop is going to be theta of length L1.
1974.88,1.5199999999999818, But there is an inner loop.
1976.4,6.039999999999964," So for each element in my outer loop, I'm also going to do everything in this inner loop."
1982.44,5.720000000000027," So in the worst case, I need to look through each element in L2 to find a match."
1988.16,6.2000000000000455," So the inner loop will execute at most length L2 times, again, in the worst case."
1994.3600000000001,3.7999999999999545, So the inner loop will be theta of length L2.
1998.16,5.440000000000055," So the overall complexity, since I've got this nested loop situation, law of multiplication,"
2003.6000000000001,4.480000000000018, says that it's going to be the theta of my outer loop multiplied by the theta of my inner loop.
2008.0800000000002,4.639999999999873, So theta of length L1 times length L2.
2012.72,0.40000000000009095, Okay.
2013.1200000000001,0.6800000000000637, Everyone else?
2013.8,6.279999999999973, Yes.
2020.08,12.279999999999973," So here in this if, yes, if the if had something like using an in, right, which where in is linear,"
2032.36,5.279999999999973," then yes, there would be another, like, it would be like there was another loop at the"
2037.6399999999999,1.0, third level.
2038.6399999999999,1.0, Yeah.
2039.6399999999999,1.0, So then it would be un-cubed.
2040.64,6.720000000000027," So polynomial, but I'm cute."
2047.3600000000001,5.639999999999873," So if L1 and L2 are the same length, which, you know, sometimes we put on to simplify"
2053.0,5.480000000000018," the complexity, put this condition on to simplify the complexity, then we say that it's theta"
2058.48,2.4400000000000546," of length L1 squared, right?"
2060.92,3.0399999999999636, It's still polynomial complexity.
2063.96,3.0, Okay.
2066.96,4.320000000000164," Let's look, sorry, question."
2071.28,1.0, Yes.
2072.28,3.0," If there were not the same length, you have to denote it in terms of the both."
2075.28,1.0, Yeah.
2076.28,1.0, Okay.
2077.28,2.6399999999998727, Let's look at another example.
2079.92,5.679999999999836, So here's a function that grabs the intersect of two lists.
2085.6,5.0," So again, I've got a little example up here, example L1 and L2."
2090.6,4.2800000000002," So the intersect are going to be the common elements within L1 and L2, but I'm only going"
2095.28,1.6799999999998363, to do duplicates.
2096.96,2.6399999999998727, So I'm just going to keep the unique numbers.
2099.6,4.880000000000109, So here I've got L1 and L2 contain 352 and 2359.
2104.48,6.119999999999891, So notice the two and the three and the five both occur in both lists.
2110.6,5.0, So the intersect of these two lists is 23 and five.
2115.6,5.680000000000291," This example here on the right side is going to be a little bit trickier, right?"
2121.28,1.9600000000000364, It's kind of a unique edge case.
2123.24,1.9200000000000728, But the code still works for that edge case.
2125.16,4.440000000000055, It's if I have L1 that has duplicates of some number and L2 that has duplicates of that
2129.6,6.199999999999818," same number, the returned list of the intersect should just be seven, right?"
2135.7999999999997,4.599999999999909, That one number once.
2140.3999999999996,3.4400000000000546, So how does the code achieve this?
2143.8399999999997,2.0, So you notice a nice little structure here.
2145.8399999999997,2.5599999999999454," I've got kind of two blocks of code, right?"
2148.4,6.079999999999927, I've got something here which is going to actually help us build this list of all of
2154.48,3.2800000000002, the elements that are common within the two lists.
2157.76,5.679999999999836, And then something down here where I'm going to call that list to keep only the unique values.
2163.44,1.0799999999999272, Right?
2164.52,6.079999999999927," So up here this has a nested loop situation, just like in the previous example."
2170.6,7.0," I have to look at all of the pairs, right, from L1 and L2 to figure out which are common,"
2177.6,1.0, right?
2178.6,5.400000000000091," So this for loop over L1 is going to go through the three, the five, and the two."
2184.0,5.360000000000127," And then the inner for loop through L2 is going to basically match, take a look at, does"
2189.36,1.0, the three match the two?
2190.36,1.199999999999818, Does the three match the three?
2191.56,1.0, Does the three match the five?
2192.56,1.2799999999997453," Does the three match the nine, right?"
2193.8399999999997,3.3200000000001637," And then the five match the two, five match the three, and so on."
2197.16,1.8400000000001455, So that's what those loops are doing.
2199.0,5.599999999999909," And as soon as we find a match, we're going to append it to this temporary list."
2204.6,3.7199999999998, And it's OK if we have duplicates in this list.
2208.3199999999997,5.2400000000002365, So if you look at the example on the right-hand side there with the seven duplicated many
2213.56,6.279999999999745," times, that's actually going to create a temporary list, right?"
2219.8399999999997,3.680000000000291, That's going to contain nine times that seven.
2223.52,3.2399999999997817," So it's going to look at the seven with the seven, and it's going to say, hey, that's"
2226.7599999999998,1.0, a match.
2227.7599999999998,1.0, Let me add it.
2228.7599999999998,3.1600000000003092," Then it's going to look at the seven with the middle seven and L2, and it's going to"
2231.92,1.4800000000000182," say, let me add that."
2233.4,3.3600000000001273," And then it's going to look at the first seven and L1 with the last seven and L2, and it's"
2236.76,2.1599999999998545," going to say, let me add that, right?"
2238.92,3.400000000000091, And then it's going to do that same thing all over again when it looks at the middle seven
2242.32,3.0, and L1 along with each element in L2.
2245.32,3.0399999999999636, So it's going to add the seven three more times.
2248.36,5.199999999999818," And then again, when it looks at the last seven and L1 along with each seven and L2."
2253.56,1.0, So that's totally fine.
2254.56,2.2400000000002365, That's just what this code is doing.
2256.8,8.239999999999782," And then the bottom part down here is going to take this temporary list that we created,"
2265.04,2.6400000000003274," and it's going to just keep the unique values within it, right?"
2267.6800000000003,5.0," So it's going to create that unique list, and it's going to say, if I haven't seen this"
2272.6800000000003,4.960000000000036," value in the unique, add it, and if I have, don't do anything."
2277.6400000000003,5.839999999999691," So in the end, this code down here is going to take that big list here and just keep"
2283.48,3.0, the unique values.
2286.48,3.0," All right, so let's do the analysis for this."
2289.48,5.760000000000218, So I've got my outer for loop and my inner for loop up in the top half of my code here
2295.2400000000002,5.479999999999563," that generates my temporary long temporary list, potentially long temporary list."
2300.72,4.040000000000418, So that we already know from the previous example is theta of length L1 times theta of length
2304.76,1.0," L2, right?"
2305.76,1.5199999999999818, Pretty simple.
2307.28,3.2399999999997817, Now what about this bottom half here?
2310.52,3.1599999999998545, Because we have to be careful about this bottom half.
2313.68,4.720000000000255," This one could also contribute to the complexity, right?"
2318.4,6.039999999999964," It's looping through a temporary variable, a list variable that we created."
2324.44,6.880000000000109," But this list is created by doing something to L1 and L2, right?"
2331.32,3.0799999999999272, By looking at elements in L1 and L2.
2334.4,4.839999999999691, So it's actually indirectly related to L1 and L2.
2339.24,5.8400000000001455, So we can't just cast it aside because it could potentially contribute to the complexity
2345.08,2.7599999999997635," of my program, right?"
2347.8399999999997,6.320000000000164," And in the worst case, I create this temporary variable that looks like this, right?"
2354.16,6.599999999999909," So in the worst possible case, my temporary variable's length is going to be length L1 times"
2360.7599999999998,1.2400000000002365," length L2, right?"
2362.0,5.359999999999673," I basically added that character every time I compared a value, right?"
2367.36,5.679999999999836," So I, this list at worst case is length L1 times length L2 block."
2373.04,6.320000000000164," So if I'm iterating through that list, then the complexity of that second half is also"
2379.36,9.840000000000146," theta of length L1 times length L2 in the worst case, right?"
2389.2000000000003,6.079999999999927, So the overall complexity of the function is theta of length L1 times length L2 up here.
2395.28,7.0," So in this particular case, the fact that I'm iterating over temp didn't actually increase"
2402.28,7.0," my complexity, but you can imagine code where something doing something funky like this,"
2409.28,5.0," where you indirectly reference, have some loop over something related to the input,"
2414.28,2.0, could affect the complexity.
2416.28,5.0," So in this case, the overall complexity is still theta of length L1 times length L2."
2421.28,7.0, Questions about this one?
2428.28,5.0, Okay.
2433.28,1.0, Yeah.
2435.28,6.0, Yeah.
2441.28,7.0," Why didn't it not, like, again, because here, here, you're impending a certain number of them,"
2448.28,1.0," like, how do you know this?"
2449.28,3.0," Like, if I just did a very brief problem."
2452.28,2.0," It varies for each problem, right?"
2454.28,5.0," But in the analysis, we're interested in the worst case scenario, right?"
2459.28,3.0, The asymptotic behavior of the worst case.
2462.28,7.0," And in the worst case, we've added this number, length L1 times length L2 times."
2469.28,4.0," Right. Most of the time, of course, it's not going to be this bad, right?"
2473.28,4.0, It's just in this one particular case that it is this bad.
2477.28,4.0," Oh, I see the answer."
2481.28,1.0, Okay.
2482.28,2.0, Let's look at one more function that's polynomial.
2484.28,1.0, So here's diameter.
2485.28,2.0, We saw this last lecture.
2487.28,3.0," Basically, if we have a bunch of points in a 2D plane,"
2490.28,6.0," this function tells us the distance, sorry, the maximum distance between any two points."
2496.28,4.0, Right. So I drew that picture in the 2D plane.
2500.28,5.0, So this one is going to have nested loops again.
2505.28,6.0, So the outer loop iterates through length L times.
2511.28,5.0," So remember, our L is just a list of two poles representing these x, y coordinates."
2516.28,6.0," So the outer loop easily goes through length L times, but what does the inner loop go through?"
2522.28,5.0," Right. The inner loop is actually starting at i, not zero, right?"
2527.28,5.0," If it started at zero, the inner loop would be clearly theta of length L."
2532.28,3.0," But it's not, right? It starts at i."
2535.28,5.0," On average, though, how many times does that inner loop go through?"
2540.28,3.0," Well, the first time it goes through that inner loop,"
2543.28,6.0, it's going to look at length L minus one elements.
2549.28,5.0," Next time, it's going to look at length L minus two elements."
2554.28,4.0," Next time, it's going to look at length L minus three elements, right?"
2558.28,6.0, Until we get to the end where it's going to look at one and then zero elements.
2564.28,5.0," Right. So if we think about how many times that inner loop actually iterates,"
2569.28,8.0," it's going to be, what is it? Like, length L minus one multiplied by length L over two."
2577.28,4.0," Is that the function, I think, to add all these together? Something like that."
2581.28,5.0," Which is basically still something that's a function of length L, right?"
2586.28,4.0," Like, we can simplify it to be zero point five length L."
2590.28,7.0," Right. So it's still a function of length L, even because the coefficient in the front of that length L is point five."
2597.28,7.0, Right. So the overall complexity of the inner loop is still theta of length L.
2604.28,5.0, Right. Everything else within this code is constant.
2609.28,11.0, So the overall complexity is just theta of length L squared.
2620.28,2.0, Sorry. Where did the one half come?
2622.28,6.0," It's the formula to add like, if you add one plus two plus three plus four plus all the way up to n,"
2628.28,4.0," like, what's the formula to do that? I think it's like n times n plus one over two."
2632.28,7.0," Something like that. So this is not exactly half, but it's like something on the order plus, I don't know, something."
2639.28,4.0," Right. Whatever this calculates, too."
2643.28,6.0," But in effect, it's like something that's smaller than length L, but it's still a function of length L."
2649.28,7.0," Right. And so that front coefficient on, right before length L just goes away, right."
2656.28,4.0," Even like if it was 10, we would still cast it away."
2660.28,3.0," In this case, it's zero point five or whatever it is. Right."
2663.28,6.0," So it's still less than one, but we still cast it away because we're interested in the theta of this."
2669.28,1.0, Yeah.
2670.28,6.0," I would, and that's the part of the group."
2676.28,6.0, But would it be an n squared group?
2682.28,6.0," I mean, the inner loop could just not depend on the input at all."
2688.28,2.0, Right.
2690.28,5.0," Like here, it's n squared because the, both of the loops depend linearly on the input."
2695.28,9.0," But if the inner loop, like if the outer loop went through range length L squared, then the overall complexity would be length L cubed, in this case, right."
2704.28,4.0, Because it's length L squared times length L.
2708.28,7.0," Or if one of the loops doesn't depend on the input at all, then it contributes nothing constant and it is nothing linear."
2715.28,6.0, So it's constant. Yeah.
2721.28,7.0, Okay. Let's have you think about this question for a bit.
2728.28,8.0," So think about the input, think about parts of the function that depend on the input, and then what is the complexity."
2736.28,8.0, Okay. What's the outer loop theta of?
2744.28,3.0, Yeah.
2747.28,6.0, Yes. Nums is a list. So the outer loop is theta of length of Nums. Correct.
2753.28,6.0, Good. What's the inner loop theta of?
2759.28,5.0," Yeah. Is that what you're going to say? Theta of 1. Exactly. It's the length of digits, but digits is not my input."
2764.28,2.0, Right. Nums is my input.
2766.28,7.0," So the inner loop will always just iterate through 10 times. So in the eyes of the inputs to the function, that's just constant."
2773.28,8.0, Right. So the input is Nums. The outer loop is theta of Nums. The inner loop is theta of 1. So the overall complexity is theta of length of Nums.
2781.28,4.0, Perfect. How about this one?
2785.28,7.0, What are my inputs? Do any loops depend on these inputs?
2792.28,7.0, All right. What's the outer loop complexity?
2799.28,12.0, Yeah. Yeah. Sayed of length L1. Exactly. What's the inner loop complexity?
2811.28,7.0, Sayed of length of L2. Perfect. And is there anything else that contributes to the complexity here?
2818.28,10.0, What's that? The if statement. Yes. What about it is making you question that the complexity is not constant.
2828.28,16.0," Exactly. Yes. Very nice. So in iterates through the length of L3. Right. Looking for an element in L3, E1 and L3 is not constant. Right. You have to look through the whole length of L3 to figure out where it's there or not."
2844.28,10.0," So the this inner bit here, right, is not constant. It's theta of length L3. In fact, it's, you know, two times length L3. Right."
2854.28,9.0, So the overall complexity of this function is theta of length L1 times theta of length L2 times theta of length L3. Right.
2863.28,9.0," Okay. Cool. Let's look at the exponential complexity. So this is a complexity that grows really, really quickly."
2872.28,13.0," We never want the algorithms that we write to land within this class. Unfortunately, there are just some problems in real life that we have to compute that are just naturally part of this complexity class."
2885.28,14.0," There are some techniques to deal with making these algorithms a little bit faster. But inherently, there are just exponential algorithms that we just can't do any better than exponential in solving some of these problems."
2900.28,13.0," All right. So let's look at Fibonacci again. We looked at Fibonacci a few slides ago, iterative version. And the iterative version was theta of N."
2913.28,14.0," But if we look at the recursive version of Fibonacci, it's not theta of N at all. In fact, as you can see, it's in this exponential set of slides, the iterative, the recursive version of Fibonacci is actually exponential."
2928.28,12.0," So let's recall what this code is doing. So there's two base cases, right. Fibonacci of 0 and 1. And then the recursive step is Fibonacci of N minus 1 plus Fibonacci of N minus 2."
2940.28,12.0," So for every level that we go down, there's going to be times two more paths that we need to explore to grab the values from. Right."
2952.28,15.0," So for the very first N, we've got just one value to grab. For the next N, we've got times 2 that value to grab. The next level, for the next N, we've got two times more values to grab. And so on. Right."
2967.28,16.0," So the fact that there are two recursive calls in this recursive step leads us to this little inverted tree kind of structure, right. And we even drew this when we looked at how many function calls are being run. Right."
2983.28,10.0," Remember when we're figuring out the complexity with a recursive function, we need to figure out how many of these function, how many recursive calls are we actually doing."
2993.28,13.0," Right. So because of this tree structure, every time we add a new level, we basically have two completely separate paths to explore further, right. And those two paths have their own two paths and so on."
3006.28,12.0," So this leads us to this tree structure, which is actually going to lead to the total number of recursive calls to be exponential. So theta of 2 to the N."
3018.28,15.0," Now, if we looked at the actual recursive call tree, right, we looked at this, and it looked something like this, right, a bunch of lectures ago, you might notice that the tree actually spins out a little bit to the right."
3033.28,14.0," Right. It's not a full tree with the leaves nicely all the way down. That's because well, the left path calculates fib 5, but the right path calculates fib 4, so N minus 1 of the left path."
3047.28,12.0," But that's fine. It's not that we are actually going to speed up anything by some sort of order of magnitude, right."
3059.28,7.0, Just because the tree spins out a little bit on the right hand side is not going to speed up the overall complexity of this function.
3066.28,12.0, And it's going to be theta of 2 to the N minus some theta that's less than 2 to the N. So that subtraction is not going to really decrease the overall complexity of our function.
3078.28,5.0, So the order of this is still exponential.
3083.28,11.0, Here's another example of an exponential code. So this is a function that is going to generate all the subsets of a list.
3094.28,9.0," So again, I've added a little example here to help us understand what it's doing. So here I've got three numbers, a list with three numbers, 1, 2, and 3."
3103.28,14.0," And to generate subsets, what this means is that I'm going to create a new list of all of the possible combinations of numbers within my original list of all the possible lengths."
3117.28,9.0," So first, one subset of this list could be just the empty list, so that's not taking any of my original numbers at all."
3126.28,7.0," So this one is a list with just one of the numbers in it, so either the one or the two or the three."
3133.28,9.0," Next subset of my list could be taking just two of the elements, so 1, 2, 1, 3, and 2, and 3."
3142.28,12.0," And then lastly, I can just grab all the elements, so 1 and the 2 and the 3. I don't care about the order. I just care that I have all of these different combinations of all of the different lengths in my final list."
3154.28,15.0," So does everyone understand the goal of this function? Okay, so how do we achieve this? Well, you might not be surprised. We're going to do it recursively. That's really the only reasonable way to write this code."
3169.28,13.0," So I'm going to go through this slide, kind of just explaining what each line does, but on the next slide I'll have a little animation that shows step by step how the function creates this subset list."
3182.28,14.0," So first thing, it's recursive, so I've got my base case up there. It's if I have a list of length 0, then the subset of an empty list is just going to be this list with the empty thing inside it."
3196.28,15.0," So if I have no elements, there's only one subset that's the empty list. Then if I have more than one element inside it, I'm going to do the same idea that we saw when we worked with lists back in the recursion lectures."
3211.28,12.0," I'm going to extract one of my elements. I'm going to work on the remaining list, and then I'm going to do something by taking that element and tacking it back onto the result."
3223.28,14.0," So in this particular case, the thing that I'm extracting is the last element in my list. So if my list is 1, 2, and 3, at a step here, I'm going to extract the 3 and make it into its own list."
3237.28,13.0, So that's what that step is doing. It extracts the last element in the list. Then I make a function call to generate subsets on everything except for that last element.
3250.28,17.0," So I say, hey, function, that I'm currently writing right now. If you can generate for me the subset of all the elements, the subset for this list, then you're going to come up with something that looks like this."
3267.28,12.0," It's going to be the empty list, the 1, the 2, and the 1 and the 2 together. So the subset of this list is going to be this group of elements here."
3279.28,8.0, So that's what this is going to do. So this is again us trusting that the function we write will generate something that looks like this.
3287.28,7.0," If we've got to this point, then smaller is going to be a list that looks like this."
3294.28,13.0," So the next part of the code is going to take that little extra thing that I had saved previously, and it's going to tack on that 3 to every element within this list."
3307.28,14.0," So then I'm going to basically say, I'm going to take this 3 and make a list with the 3 in it, a list with the 1 and the 3 in it, a list with the 2 and the 3 in it, and a list with the 1 and the 2 and the 3 in it."
3321.28,10.0," So I've just taken that 3 and added it to everything that resulted from this line of code here, from my function calling itself."
3331.28,11.0," And then all it does is return smaller plus new. So if I add these 2 together, this is going to generate for me my final subset that I was interested in."
3342.28,9.0," I've got the empty thing, I've got the 1, the 2, and the 3 by itself, I've got the 1, 2, the 1, 3, and the 2, 3 by itself, and then the 1, 2, 3 all together."
3351.28,2.0, So that's the big idea here.
3353.28,13.0," Okay, so let's just go through step by step recursively calling ourselves. So this is me finding out the, kicking off my function call saying, hey, generate the subsets for the list 1, 2, 3."
3366.28,10.0," I'm going to keep the extra side. I need to make another function call because I'm not at my base case. So I'm going to call Gen subsets on 1, 2."
3377.28,9.0," This is also not my base case. So I'm going to take my last element, put it aside, and I'm going to call Gen subsets on just the 1."
3386.28,8.0," Still not the base case. I'm going to take this extra, put it aside, and I'm going to call Gen subsets on the empty list. And this is where I reach my base case."
3394.28,5.0," So far, nothing has been returned at all. No work has been done."
3399.28,7.0," So the base case, Python, will say, I know what this is, is going to be the list with just the empty thing in it."
3406.28,16.0," All right, cool. Next, that gets returned, so this function call goes away. So now what is it going to do? Well, it's going to take that extra, I set aside, take the smaller list that I just returned, and basically double that smaller list."
3422.28,9.0," And this is my smaller list, and then I'm going to double that by saying, I'm going to put this 1 to the end of everything in my smaller list."
3431.28,5.0," Maybe this is not so apparent at this step, but let's go one more step and see what happens."
3436.28,15.0," So now this function also terminates. It returns this empty list and 1 in it, and says, all right, here with this function call, I had saved the 2 separately, and said, I'm going to now tack on this 2 to the end of everything that I had just done."
3451.28,12.0," So this is smaller. This is smaller over here, and all I'm going to do is take this extra thing and tack it on to the end of everything that was in smaller."
3463.28,10.0," So I'm going to tack it on to the end of this empty list, so it just gives me this 2, and tack it on to the end of this 1, so it gives me the 1 comma 2."
3473.28,9.0," So I've basically doubled my list at this stage. One more step. This gets returned, and now this is my original function call."
3482.28,12.0," The thing that I had extracted was the 3, so now we're basically at this step here. I extracted the 3, the function just below it, returned this smaller."
3494.28,18.0," So that means that this 3 is going to get appended to the end of everything that was in smaller. So it's going to be appended to the end of this empty list to give me just the 3, to the end of the 1, to give me the 1 and 3, to the end of the 2, to give me the 2 and the 3, and to the end of the 1, 2, to give me the 1, 2, 3."
3513.28,12.0," Now this is the final answer, so I basically keep what I had returned from the previous function call, and concatenate that with the thing that I had just created, where I tacked on my 3."
3525.28,11.0," And this is my final answer. It's just sort of out of order to what we intuitively would have written by hand, but it hits on all of the elements that I wanted to have anyway."
3536.28,8.0," So I've got the empty list, everything with just one element in it, everything with the 2 elements in it, and everything with all 3 elements in it."
3544.28,10.0," So let's look at the complexity analysis of this. We've got two things going on here. One is how many of these function calls are actually being done, right?"
3555.28,8.0," Like with the inverse tree structure, how many of those function calls do we need to do to get to the end of our, to our base case?"
3563.28,7.0," And on top of that, that, sorry, that will tell us how many actual elements in the list we will have."
3570.28,8.0," And on top of that, we have actually a time complexity that's not constant, that's to copy our list."
3578.28,7.0," So copying a list is not constant, right? Because it takes some time to take all the elements in a list and make a copy of them."
3585.28,8.0," So if we think about the time it takes to make our list at each step, right? How many of these sub elements we're creating?"
3593.28,13.0," Well, at the very base case, we have one element. At the case just above it, we had two elements. At the case just above that, we had four elements. At the case just above that, we had eight elements."
3607.28,9.0," So at each step, the number of sublists that we were generating was basically twice as much as the previous step."
3616.28,12.0, So the overall number of subsets was on the order of two to the end. But there was also a time complexity to make a copy of the list within each one of those subsets.
3628.28,9.0, So we're multiplying the complexity it takes to make all those function calls and generate all those subsets by the time it takes to make a copy of the list.
3637.28,14.0," So the overall complexity is actually going to be theta of n times two to the end because it's a little bit harder, it's a little bit worse than exponential, just purely for the fact that we're copying the list at each step."
3652.28,17.0," Okay. All right. So let's move on to logarithmic complexity. This one's going to be a little bit tricky because right off the bat, we're not going to be able to see a direct relationship between the input and what loop we actually have."
3670.28,9.0," So here I've got a function called digit ad. It's going to take in a number. So like one, two, three, four, something like that."
3679.28,8.0, Number one thousand two and thirty four. The code casts it to a string. So it takes in a pure numerical value.
3687.28,6.0, It makes a string out of it and then it rates through the string.
3694.28,13.0, So the function here in terms of time complexity is theta of length s. Here we're iterating through the string backward basically four than three than two than one.
3707.28,10.0, But what's my input? It's n. It's not s. So the time complexity of this function while it's linear in s.
3717.28,13.0," s is not linear in n because when my number is 83, my loop only iterates twice. If my number has four digits in it, 4,271, my loop iterates four times."
3730.28,11.0," So this relationship is not linear. So what is it exactly? Well, let's think about what that loop is actually doing."
3741.28,13.0," If I have a number with four digits in it, something in the thousands. When I iterate through the number, this number has a string."
3754.28,11.0, I'm basically taking that one and keeping it in my running sum. Then it's kind of like I divided that number by ten.
3765.28,12.0, I grabbed the remainder when I divided that number by ten and that's the thing that I just added. The whole number left over when I divided by ten is this bit here.
3777.28,11.0," So now, think of it like taking this to take this last element here. It's like I take this number and divide by ten again. I grabbed the remainder when I divide by ten and added to my running total."
3788.28,12.0," And the whole number I'm left over when dividing by ten is just this. One more time, I take the two. The remainder when I divided that 42, what is two. And the whole number I was left over with is four."
3800.28,5.0," And then lastly, I can do that last thing again."
3805.28,11.0," So what's the relationship between the magnitude of n, right? This 4,000 something or this 80 something, to how many times I have to loop through to get every digit in my number?"
3816.28,10.0," Well, the trick here is to think about taking my magnitude, my n, my magnitude of n and dividing it by ten a bunch of times."
3826.28,11.0," How many times do I divide by ten to basically grab every single element, every single digit in my n? Well, length s times."
3837.28,9.0," That's kind of like taking each character one at a time, right? To take each character one at a time that's like dividing by ten to grab the remainder."
3846.28,5.0," And then I've done that length s times, right? That's what this loop is doing."
3851.28,12.0," So the relationship between the magnitude of n and how many times I go through the loop is this. N divided by ten, some number times length s times is equal to one."
3863.28,6.0," That means I've finished going through this entire element, this entire number, all the digits within the number."
3869.28,9.0, So the relationship between n and length s is length s is equal to log of n.
3878.28,9.0," And now that I have this nice relationship, well, I said that this function was linear and length s. So if it's theta of length s, it's going to be theta of log n."
3887.28,9.0, I just mapped those two together. Questions about this? This trick can work in many different ways.
3896.28,11.0," What's important to realize is that here there's kind of an indirect relationship between what's actually happening in the code and my input, right? It's not as clear cut."
3907.28,12.0, But there is some relationship which is not constant and not linear.
3919.28,10.0, So the overall complexity of this function is theta of log n where I don't actually care about the base when I report the complexity in terms of log.
3929.28,8.0," In this case, it's base 10, but if it was base two, it would be the same log."
3937.28,7.0," Okay, so we saw a bunch of examples, just one of logarithmic complexity."
3944.28,9.0, But we're going to see next that searching for an element in the list will also be logarithmic complexity.
3953.28,11.0," Before we get to that, I'd like to just put this slide up to remind you that there are several functions built in functions with lists and dictionaries that aren't constant."
3964.28,12.0," So like that example you guys did where we use the in operator, right, we had to be careful if you ever see these operations being done in the code, don't just push them aside."
3976.28,6.0, You have to account for them within the complexity analysis.
3982.28,5.0," Okay, so next we're going to look at some searching algorithms."
3987.28,6.0," These algorithms, we're going to see a bunch of different codes that implement searching."
3993.28,5.0," Again, they'll be very similar to the ones that we actually timed last lecture."
3998.28,4.0, So we're going to look at searching for an element in a list.
4002.28,9.0, We're going to look at a bunch of different implementations of the plain brute force searching element in a list.
4011.28,11.0," So we're going to look at the sorted or unsorted as long as you just brute force your way from the beginning of the list to the end of the list, you'll be able to find the element you're looking for or say that it's not there."
4022.28,3.0, So we're going to look at some linear search functions.
4025.28,5.0," And then we're going to look at the bisection search, a couple bisection search implementations."
4030.28,4.0, And that's where we divide the list in half and discard one of the halves.
4034.28,6.0," Those implementations, though, will need our list to be sorted."
4040.28,4.0, So the brute forcing our way doesn't really matter whether it's sorted or not.
4044.28,5.0, But the bisection search only gives the correct answer if the list is sorted to begin with.
4049.28,5.0," So first, let's look at linear search on an unsorted list."
4054.28,5.0, This is code that is going to search for element E in list L.
4059.28,9.0, It loops through the length of the list and keeps this Boolean flag in mind if it finds the element we're looking for just sets the flag.
4068.28,5.0," And at the end of iterating through the whole list, it tells us whether it found it or not."
4073.28,9.0, So the worst case scenario analysis says that we have to look through the entire list to determine the element is there or not.
4082.28,5.0, So the theta of this particular function is theta of length L.
4087.28,7.0, There's only one loop depends on the length of L that nothing really special about this function.
4094.28,4.000000000000455, Now you might notice that there's something inefficient about this function.
4098.280000000001,9.0," And that once it finds an element, let's say at the beginning of the list, this function actually just sets the flag and keeps going through to the end of the list."
4107.28,9.0," So we can actually do a little bit of a speed up with this bit here and say that, hey, if we find it, just return true right away."
4116.28,3.0, No need to keep going to the end of the list.
4119.28,4.0, So what's the analysis for this code?
4123.28,6.0," Well, again, we're doing worst case analysis. So in the worst case, the element is not there."
4129.28,6.0, So we still have to search through every single element in the list beginning to end to determine it's not there.
4135.28,7.0," So the worst case, you know, theta analysis for this function is that we still have to go through to the end of the list to determine it's not there."
4142.28,7.0," So it's still going to be, sorry, it's still going to be theta of length L."
4149.28,3.0, Time.
4152.28,3.0, So this is on an unsorted list.
4155.28,4.0, But what if we look at a sorted list?
4159.28,4.0, So we can do a little something clever in our code.
4163.28,8.0," If the list is sorted, we can say, we're going to start at, let's say it's increasing sorted, right?"
4171.28,4.0," We can start at the beginning of the list, look through each element."
4175.28,3.0," If we find it, return true."
4178.28,5.0," If we reach an element that's bigger than the one we're looking for, the list is sorted."
4183.28,5.0, So all the remaining elements in the list are also bigger than the one we're looking for.
4188.28,3.0, And then we can just return false right away.
4191.28,8.0," Well, we think we're pretty clever, but the worst case analysis says that the list is, the element is not even in the list at all."
4199.28,6.0, So we still have to go through and look to the end of the list to figure out that that element is not there.
4205.28,4.0, So we still have to touch each element in the list to determine it's not there.
4209.28,6.0," So the theta, worst case, theta complexity analysis still says that this is theta of length L, right?"
4215.28,4.0, Because everything else is constant.
4219.28,2.0, Okay.
4221.28,2.0, So now let's look at bisection.
4223.28,9.0," So as far as we can tell, just doing a linear brute force search way is not going to give us anything better than theta of n."
4232.28,10.0," But when we looked at the timings in last lecture, we saw that this binary search, or bisection search on an element in the list, was actually much faster, right?"
4242.28,5.0," It grew out of something faster rate than linear, but not quite constant."
4247.28,3.0, So let's remember how that code looked.
4250.28,3.0, So we basically had a list with a bunch of elements in it.
4253.28,3.0, We looked at the element at the middle of the list.
4256.28,3.0," And we said, are you the one we're looking for?"
4259.28,2.0," In the worst case, it's not, right?"
4261.28,4.0," So then we have to ask, are you bigger or smaller than the one we're looking for?"
4265.28,5.0," If it's bigger, then we know we have to look in the lower half of the list."
4270.28,9.0," And now that we either look in the lower or the upper half, we notice we have the exact same problem to solve."
4279.28,5.0," So this should ring a little bell that says we should use recursion, right?"
4284.28,2.0, Now we have the same problem to solve.
4286.28,4.0," An element e in a slightly smaller list, is it in that list?"
4290.28,5.0, So that's exactly what we're going to implement.
4295.28,3.0," So visually speaking, this is what we're going to do."
4298.28,5.0, We're going to have an original list with n elements in it.
4303.28,2.0, We're going to look at the halfway point.
4305.28,2.0," Worst case, it's not the one we're looking for."
4307.28,4.0, So we're going to decide on one of the sides to next search through.
4311.28,2.0, Now we have n over two elements to look through.
4313.28,1.0," Again, it's not there."
4314.28,1.0, Worst case.
4315.28,2.0, So we have to decide on which half to look through.
4317.28,2.0, Now we have n over four elements to look through.
4319.28,1.0, We keep doing this.
4320.28,5.0, We keep sort of having more and more recursive calls until we reach a base case.
4325.28,6.0, And the base case is that we now have a list with one element in it.
4331.28,4.0," Either that element is the one we're looking for, or worst case, it's not."
4335.28,6.0, And we've determined that the element we're looking for is not in these n elements at all.
4341.28,4.0, So our base case is down here.
4345.28,3.0, And we started with n elements over here.
4348.28,6.0, So the bisection search algorithm will repeat this task of dividing the list in half.
4354.28,3.0, Let's say i times.
4357.28,5.0, So this is quote unquote how many iterations we would have made.
4362.28,3.0," But since this is recursion, there's no iterations."
4365.28,4.0, This is how many function calls we have until we reach the base case.
4369.28,2.0, i function calls.
4371.28,6.0, So if we take our original n elements and we divide them by two so many times
4377.28,5.0," that we have only one element left to search for, that's when we found our answer."
4382.28,7.0," So we now have a relationship between how many elements we had,"
4389.28,7.0," originally n elements, and how many times we had to divide our loop to get to our answer."
4396.28,3.0, How many of these levels we have?
4399.28,2.0, N divided by two to the i equals one.
4401.28,2.0, That's our relationship.
4403.28,5.0," So in the bisection search algorithm, how many times are we calling this recursive function"
4408.28,2.0, to get to the base case?
4410.28,3.0, So what is i in terms of n?
4413.28,5.0, Well the relationship between i and n is similar to the one we had over here.
4418.28,3.0, Where we divided this number by 10 each time.
4421.28,3.0, Except that now we're dividing a list of n elements by two each time.
4424.28,4.0, So the relationship is to logarithmic.
4428.28,4.0," It relates the number of elements I originally had, n."
4432.28,4.0," With how many times I had to divide my list to get to one element,"
4436.28,4.0, whether it's the one I'm looking for or not.
4440.28,6.0," So the complexity of just the pure bisection search algorithm is theta of log n,"
4446.28,2.0, where n is the length of the list.
4448.28,7.0, That's how many subdivisions I need to do to get to one element to decide and stop the one I'm looking for.
4455.28,5.0, So now we're going to look at two different implementations of the code to do bisection search.
4460.28,2.0, One will be more efficient than the other.
4462.28,5.0," Let's start with the one that's simpler to write, but less efficient."
4467.28,4.0," So this code, you can see here, it looks for element e and list L."
4471.28,2.0, It has two base cases up there.
4473.28,2.0, Those are both constant.
4475.28,2.0, And one recursive step here.
4477.28,2.0, So either we do this one or this one.
4479.28,3.0," So this one is if we decided we need to look in the lower half,"
4482.28,5.0, and this is if we decided we need to look in the upper half for the element.
4487.28,10.0," So this is just pure bisection search, which on the previous slide we decided is theta of log of length of the list, theta of log n."
4497.28,6.0," Now that's fine, but what do we have as a parameter here?"
4503.28,4.0," It's half of my list, right?"
4507.28,4.0," So in addition to doing bisection search and just doing the algorithm,"
4511.28,5.0," having a bunch of bisection search calls that take me to that list of one element,"
4516.28,6.0," on top of that, each time I make that bisection search call, I'm copying my list."
4522.28,3.0, So this is not constant.
4525.28,3.0," It's theta of length L over two, right?"
4528.28,2.0, I grab half of my list.
4530.28,6.0, So the complexity of that code is theta of n times log n.
4536.28,3.0," Theta of log n for the bisection search bit,"
4539.28,8.0, but theta of n tacked on to each one of those calls because I have to grab a copy of my list with each function call.
4547.28,3.0, So it's not quite that efficient.
4550.28,4.0, Now let's look at a slightly different implementation.
4554.28,5.0, This particular one is going to use integers to keep track of endpoints.
4559.28,7.0," So instead of copying my list, let me just keep track of a number for my low endpoint and a number for my high endpoint."
4567.28,7.0," The complexity analysis for the bisection search is going to be exactly the same because even though I'm just keeping track of these high and low endpoints,"
4574.28,3.0, I'm still dividing the list in half with each call.
4577.28,4.0, But I'm doing it by keeping track of integer indices.
4581.28,4.0, So the size of the problem is still reduced by two at each step.
4585.28,2.0, I'm keeping track of these integer indices.
4587.28,2.0, I'm not copying the list at this point.
4589.28,6.0," I'm just changing an integer value from, you know, 10 to 5 or whatever it is."
4595.28,6.0, So the complexity analysis of the theta of the bisection search is theta of log n.
4601.28,5.0," The code looks a little bit messier, but overall it still does the same sort of things."
4606.28,6.0," It's messier because now I want bisection search to look for an element e in list L,"
4612.28,5.0," but I'd like my recursive call to keep track of two endpoints, right?"
4617.28,5.0," These integers low and the integer high, the thing that I want to search my list between."
4622.28,5.0," So I'm going to create another function that I kick off down here,"
4627.28,10.0," which looks for an element e in list L, but I'm also going to keep track of my low and high endpoints as parameter to my bisection search function."
4637.28,5.0, So bisection search helper here is now going to take in these four parameters.
4642.28,8.0," The rest of the code, you know, it's just details, but what's important is everything is constant except for my two bisection search calls."
4650.28,8.0," Here, I'm changing my high, if I want to look in the lower half of the list, and here I'm changing my low,"
4658.28,3.0, if I want to look in the upper half of the list.
4661.28,5.0," So the bisection search calls are still going to be theta of log n, but what's the overhead now?"
4666.28,2.0," The overhead is nothing, right? It's constant."
4668.28,5.0, This L is the same one. I'm not making a copy of it. I'm just passing it through.
4673.28,6.0," E is just a number, low is just a number, and mid minus one is just a constant operation."
4679.28,4.0," There's nothing being copied here. So the overall complexity of this code,"
4683.28,4.0," while it looks a little bit messier, is just theta of log n, right?"
4687.28,5.0, Because the overhead is constant on each one of those function calls.
4692.28,4.0," So that brings us to this final question, right?"
4696.28,4.0," Clearly, bisection search on a sorted list is faster."
4700.28,5.0," It's theta of log n, then pure brute force search on a list."
4705.28,2.0, That could be sorted or unsorted.
4707.28,6.0," So the question is, when does it make sense to sort the list first?"
4713.28,6.0," So given an unsorted list, when do you sort the list and use this fast binary search"
4719.28,5.0, versus just using a straight up linear search?
4724.28,4.0," Well, that's when the time it takes to do the sort, right?"
4728.28,9.0, When an initial sort plus the complexity to do binary search is less than doing the straight up linear search.
4737.28,3.0, Because the list has to be sorted for this to work.
4740.28,10.0," Well, what is that true? Well, this implies that the time it takes to do the sort is less than theta of n."
4750.28,7.0," So that means, what, can you sort a list without even looking at all the elements once?"
4757.28,6.0," No, right? Like you have to look at all the elements once to even say that, hey, this list is already sorted."
4763.28,3.0, So this is actually never true.
4766.28,2.0, Right? So what does that mean?
4768.28,5.0, Does that mean we never want to do binary search on the list unless it's already sorted?
4773.28,2.0, Kind of.
4775.28,8.0," But in fact, you know, there are various situations when it does make sense to do the sort first and then use binary search."
4783.28,8.0," And that's the case where you, you're given a data set and you want to do a whole bunch of searches on that data set."
4791.28,7.0," So if you can take that sort, do it once and then amortize the cost."
4798.28,4.0, It took you to do that sort over K different searches.
4802.28,9.0, Then it makes sense to pay the price to do the sort once and then do it over and then do the binary search over all these searches.
4811.28,9.0," And so as K gets really big, the time it takes for you to do the sort becomes irrelevant."
4820.28,13.0," Right? The theta of doing this thing on the left becomes just the theta to do the search, the search logarithmically, then it does to do the search linear."
4833.28,6.0," Okay, so if you're only doing the search once, please do not sort your list and then do a binary search."
4839.28,6.0, That's going to take longer than just looking at the elements in your list straight through using brute force.
4845.28,6.0," But if you're going to do a whole bunch of searches, make sense to do the sort and then do the search."
4851.28,1.0, Right?
4852.28,1.0, That's all I've got.
4853.28,6.0," Next lecture, we're going to look at a bunch of different sorting algorithms and we'll have a quiz."
4863.28,3.0, You
